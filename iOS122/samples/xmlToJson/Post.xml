<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.2.4" created="2015-10-28 07:52" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>iOS122</title>
	<link>http://www.ios122.com</link>
	<description>有态度的iOS第三方资源聚合网站</description>
	<pubDate>Wed, 28 Oct 2015 07:52:11 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://www.ios122.com</wp:base_site_url>
	<wp:base_blog_url>http://www.ios122.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>yanfengstyle</wp:author_login><wp:author_email>yanfengstyle@163.com</wp:author_email><wp:author_display_name><![CDATA[iOS122 运营组]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>http://wordpress.org/?v=4.2.4</generator>

	<item>
		<title>AwesomeMenu,仿Path主菜单效果</title>
		<link>http://www.ios122.com/2015/08/awesomemenu/</link>
		<pubDate>Tue, 18 Aug 2015 01:34:04 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=13</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>项目主页: <a href="https://github.com/levey/AwesomeMenu">AwesomeMenu</a></p>

<p>实例下载: <a href="https://github.com/levey/AwesomeMenu/archive/master.zip">点击下载</a></p>

<h2>入门</h2>

<h3>通过创建菜单各个单元项来创建菜单:</h3>

<pre><code class="objc">UIImage *storyMenuItemImage = [UIImage imageNamed:@"bg-menuitem.png"];
UIImage *storyMenuItemImagePressed = [UIImage imageNamed:@"bg-menuitem-highlighted.png"];
UIImage *starImage = [UIImage imageNamed:@"icon-star.png"];
AwesomeMenuItem *starMenuItem1 = [[AwesomeMenuItem alloc] initWithImage:storyMenuItemImage
                                                           highlightedImage:storyMenuItemImagePressed
                                                               ContentImage:starImage
                                                    highlightedContentImage:nil];
AwesomeMenuItem *starMenuItem2 = [[AwesomeMenuItem alloc] initWithImage:storyMenuItemImage
                                                           highlightedImage:storyMenuItemImagePressed
                                                               ContentImage:starImage
                                                    highlightedContentImage:nil];
// "开始"单元格,类似于 Path 的"添加"按钮.
AwesomeMenuItem *startItem = [[AwesomeMenuItem alloc] initWithImage:[UIImage imageNamed:@"bg-addbutton.png"]
                                                   highlightedImage:[UIImage imageNamed:@"bg-addbutton-highlighted.png"]
                                                       ContentImage:[UIImage imageNamed:@"icon-plus.png"]
                                            highlightedContentImage:[UIImage imageNamed:@"icon-plus-highlighted.png"]];
</code></pre>

<h3>然后,初始化菜单和选项:</h3>

<pre><code class="objc">AwesomeMenu *menu = [[AwesomeMenu alloc] initWithFrame:self.window.bounds startItem:startItem optionMenus:[NSArray arrayWithObjects:starMenuItem1, starMenuItem2]];
menu.delegate = self;
[self.window addSubview:menu];
</code></pre>

<h3>你也可以使用使用菜单的各个属性,自定义:</h3>

<pre><code class="objc">// 重新确定”添加”按钮的位置:
menu.startPoint = CGPointMake(160.0, 240.0);

//设置旋转角度:
menu.rotateAngle = 0.0;

// 设置整个菜单的按钮角度:
menu.menuWholeAngle = M_PI * 2;

// 设置每个菜单项之间动画延迟执行的时间间隔:
menu.timeOffset = 0.036f;

// 适应弹动动画:
menu.farRadius = 140.0f;
menu.nearRadius = 110.0f;

// 设置”添加菜单”与其他菜单单元格之间的距离:
menu.endRadius = 120.0f;
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[仿Path主菜单效果]]></excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date>2015-08-18 09:34:04</wp:post_date>
		<wp:post_date_gmt>2015-08-18 01:34:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>awesomemenu</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="awesomemenu"><![CDATA[AwesomeMenu]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[awesomemenu%e4%bb%bfpath%e4%b8%bb%e8%8f%9c%e5%8d%95%e6%95%88%e6%9e%9c]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AwesomeMenu-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>MBProgressHUD 优雅地去提示</title>
		<link>http://www.ios122.com/2015/08/mbprogresshud/</link>
		<pubDate>Tue, 18 Aug 2015 04:01:24 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=33</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a></li>
<li>实例下载: <a href="https://github.com/jdg/MBProgressHUD/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<p>当执行需要较长时间的任务时,使用MBProgressHUD最重要的一点是: 保证主线程是空闲的,这样可以使UI实时更新.因此: 建议在 主线程中使用 MBProgressHUD, 把其他你想要执行的任务放到其他的线程里:</p>

<pre><code class="objc">[MBProgressHUD showHUDAddedTo:self.view animated:YES];
dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
    // 执行某些任务...
    dispatch_async(dispatch_get_main_queue(), ^{
        [MBProgressHUD hideHUDForView:self.view animated:YES];
    });
});
</code></pre>

<p>如果你想配置 HUD,你可以使用由 showHUDAddedTo:animated: 方法返回的 MBProgressHUD 的实例.</p>

<pre><code class="objc">MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
hud.mode = MBProgressHUDModeAnnularDeterminate;
hud.labelText = @"Loading";

// doSomethngInBackgroudWithProgressCallback: 代指某个和进度有关的 自定义方法.
[self doSomethingInBackgroundWithProgressCallback:^(float progress) {
    hud.progress = progress;
} completionCallback:^{
    [hud hide:YES];
}];
</code></pre>

<p>UI 更新,应该通常总是在主线程完成.但是某些 MBProgressHUD 设置器,考虑到了”线程安全”,并且可以在后台线程里被调用.这些设置器,具体指的是: setMode:,setCustomView:, setLabelText:, setLabelFont:, setDetailsLabelText:,setDetailsLabelFont: 和 setProgress:.</p>

<p>如果你需要在主线程执行需要长时间运行的任务,你应该在短暂的延迟后再执行这个任务,这样在你的任务阻塞主线程之前, UIKit 就有足够的时间来更新UI(如,绘制HUD).</p>

<pre><code class="objc">[MBProgressHUD showHUDAddedTo:self.view animated:YES];
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, 0.01 * NSEC_PER_SEC);
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    // 执行某个 耗时较长的操作.
    [MBProgressHUD hideHUDForView:self.view animated:YES];
});
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[优雅地HUD提示]]></excerpt:encoded>
		<wp:post_id>33</wp:post_id>
		<wp:post_date>2015-08-18 12:01:24</wp:post_date>
		<wp:post_date_gmt>2015-08-18 04:01:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mbprogresshud</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mbprogresshud"><![CDATA[MBProgressHUD]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[mbprogresshud-%e4%bc%98%e9%9b%85%e5%9c%b0%e5%8e%bb%e6%8f%90%e7%a4%ba]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MBProgressHUD-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>DACircularProgressView 环形进度条</title>
		<link>http://www.ios122.com/2015/08/dacircularprogressview/</link>
		<pubDate>Tue, 18 Aug 2015 10:20:51 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=37</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/danielamitay/DACircularProgress">DACircularProgressView</a></li>
<li>实例下载: <a href="https://github.com/danielamitay/DACircularProgress/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<p>可以使用纯代码:</p>

<pre><code class="objc">self.progressView = [[DACircularProgressView alloc] initWithFrame:CGRectMake(140.0f, 30.0f, 40.0f, 40.0f)];
self.progressView.roundedCorners = YES;
self.progressView.trackTintColor = [UIColor clearColor];
[self.view addSubview:self.progressView];
</code></pre>

<p>你也可以在 xib/storyboard 中使用: 添加一个 UIView 控件,并把它的类指定为 DACircularProgressView</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[环形进度条]]></excerpt:encoded>
		<wp:post_id>37</wp:post_id>
		<wp:post_date>2015-08-18 18:20:51</wp:post_date>
		<wp:post_date_gmt>2015-08-18 10:20:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>dacircularprogressview</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dacircularprogressview"><![CDATA[DACircularProgressView]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_DALabeledCircularProgressView-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ACTimeScroller 仿PATH 时光轴效果</title>
		<link>http://www.ios122.com/2015/08/actimescroller/</link>
		<pubDate>Tue, 18 Aug 2015 10:53:06 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=42</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/andrewroycarter/TimeScroller">ACTimeScroller</a></li>
<li>实例下载: <a href="https://github.com/andrewroycarter/TimeScroller/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<p>通过 initWithDelegate: 方法,创建对象即可.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[仿PATH 时光轴效果]]></excerpt:encoded>
		<wp:post_id>42</wp:post_id>
		<wp:post_date>2015-08-18 18:53:06</wp:post_date>
		<wp:post_date_gmt>2015-08-18 10:53:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>actimescroller</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="actimescroller"><![CDATA[ACTimeScroller]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[actimescroller-%e4%bb%bfpath-%e6%97%b6%e5%85%89%e8%bd%b4%e6%95%88%e6%9e%9c]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_e1617d9c526a6f4cc16c562f2f18294f</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_ACTimeScroller-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iCarousel 支持显示任意视图的旋转木马组件</title>
		<link>http://www.ios122.com/2015/08/icarousel/</link>
		<pubDate>Thu, 20 Aug 2015 05:30:03 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=62</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/nicklockwood/iCarousel">iCarousel</a></li>
<li>实例下载: <a href="https://github.com/nicklockwood/iCarousel/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<h3>目标</h3>

<p>iCarousel 是被设计用来简化iPhone,iPad 和 Mac OS 上 旋转木马效果的实现.iCarousel 已经实现了许多常用的效果,比如 圆柱,扁平 和 “封面流” 风格的旋转木马,同时提供许多钩子来让你实现自己改进后的效果.不像其他许多”封面流” 库那样, iCarousel 可以用于 任何 种类的 视图,而不仅仅是图片; 因此 iCarousel 是你在浮动页面中显示 页面数据的一种理想的不可思议的方式.通过极小的代码改动,你可以极其容易地在不同效果的旋转木马之间切换.</p>

<h3>安装</h3>

<p>为了在自己的 应用中使用iCarousel, 只需要把 iCarousel 类文件(demo 文件和资源是不需要的)拖到你的工程中,并添加 QuartzCore 框架.</p>

<h3>支持的旋转木马风格</h3>

<ul>
<li>iCarouselTypeLinear 直线</li>
<li>iCarouselTypeRotary 旋转</li>
<li>iCarouselTypeInvertedRotary 反向旋转</li>
<li>iCarouselTypeCylinder 圆柱</li>
<li>iCarouselTypeInvertedCylinder 反向圆柱</li>
<li>iCarouselTypeWheel 车轮</li>
<li>iCarouselTypeInvertedWheel 反向车轮</li>
<li>iCarouselTypeCoverFlow 封面流</li>
<li>iCarouselTypeCoverFlow2 封面流2</li>
<li>iCarouselTypeTimeMachine 时间机器</li>
<li>iCarouselTypeInvertedTimeMachine 反向时光机器</li>
</ul>

<p>你可以通过  iCarouselTypeCustom 和 carousel:itemTransformForOffset:baseTransform: 代理方法 来实现自己的改进后的 旋转木马风格.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[iCarousel 是被设计用来简化iPhone,iPad 和 Mac OS 上 旋转木马效果的实现.iCarousel 已经实现了许多常用的效果,比如 圆柱,扁平 和 “封面流” 风格的旋转木马,同时提供许多钩子来让你实现自己改进后的效果.不像其他许多”封面流” 库那样, iCarousel 可以用于 任何 种类的 视图,而不仅仅是图片; 因此 iCarousel 是你在浮动页面中显示 页面数据的一种理想的不可思议的方式.通过极小的代码改动,你可以极其容易地在不同效果的旋转木马之间切换.]]></excerpt:encoded>
		<wp:post_id>62</wp:post_id>
		<wp:post_date>2015-08-20 13:30:03</wp:post_date>
		<wp:post_date_gmt>2015-08-20 05:30:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>icarousel</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="icarousel"><![CDATA[iCarousel]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_iCarousel-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>BlockAlertsAnd-ActionSheets 支持block的弹出框</title>
		<link>http://www.ios122.com/2015/08/blockalertsand-actionsheets/</link>
		<pubDate>Thu, 20 Aug 2015 10:11:08 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=66</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/gpambrozio/BlockAlertsAnd-ActionSheets">BlockAlertsAnd-ActionSheets</a></li>
<li>实例下载: <a href="https://github.com/gpambrozio/BlockAlertsAnd-ActionSheets/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<p>为了创建一个弹出框,你可以:</p>

<pre><code class="objc">BlockAlertView *alert = [BlockAlertView alertWithTitle:@"弹窗框标题"
                                               message:@"这是一条很长的消息,只是为了展示这个类是多么的智能!"];
然后,你可以这样给弹出框添加按钮与按钮的响应方法:

[alert addButtonWithTitle:@"做一些很酷的事" block:^{
    // 这个按钮被点击时,这里的代码将会被执行
}];
</code></pre>

<p>你也可以添加一个 “退出” 按钮和一个”销毁” 按钮 (这是多处改进中的一处–UIAlertView甚至都不能这么做):</p>

<pre><code class="objc">[alert setCancelButtonWithTitle:@"请不要这样" block:^{
    // 做一些事,也可以什么都不做...这个Block设置可以是 nil!
}];

[alert setDestructiveButtonWithTitle:@"终止,终止" block:^{
    // 当按钮被按下时,回去做一些会危险的操作
}];
</code></pre>

<p>如果你想自定义按钮的背景图片,你可以这么做:</p>

<pre><code class="objc">/* 注意背景图片真实的名称格式: "alert-图片名称-button.png",如此处对应的图片真实名称应为:alert-red-button.png.*/

[alert addButtonWithTitle:@"自定义背景的按钮" imageIdentifier:@"red" block:^{ // 按钮按下时,执行这里的代码.
}];
</code></pre>

<p>当按钮添加结束后,直接显示就行了:</p>

<pre><code class="objc">[alert show];
</code></pre>

<p>就是这么简单!当显示 Action Sheet时,方法几乎和 显示 弹出框(AlertView)完全一样.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[支持block的弹出框]]></excerpt:encoded>
		<wp:post_id>66</wp:post_id>
		<wp:post_date>2015-08-20 18:11:08</wp:post_date>
		<wp:post_date_gmt>2015-08-20 10:11:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>blockalertsand-actionsheets</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="blockalertsand-actionsheets"><![CDATA[BlockAlertsAnd-ActionSheets]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_BlockAlertsAnd_ActionSheets-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>TTTAttributedLabel 更灵活地显示富文本信息</title>
		<link>http://www.ios122.com/2015/08/tttattributedlabel/</link>
		<pubDate>Fri, 21 Aug 2015 04:06:26 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=70</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel">TTTAttributedLabel</a></li>
<li>实例下载: <a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel/archive/master.zip">点击下载</a></li>
</ul>

<h2>入门</h2>

<h3>安装</h3>

<p>推荐使用 CocoaPods 安装 TTTAttributedLabel.只需要在你的  Podfile文件中添加一行即可:</p>

<pre><code class="ruby"># Podfile
pod 'TTTAttributedLabel'
</code></pre>

<h3>用法</h3>

<p>TTTAttributedLabel 可以显示 简单文本和富文本: 只需要传递 NSString 或 NSAttributedString 给 设置器setText: 即可.永远不要直接改变 attributedText 属性的值.</p>

<pre><code class="objc">// NSAttributedString

TTTAttributedLabel *attributedLabel = [[TTTAttributedLabel alloc] initWithFrame:CGRectZero];

NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@"Tom Bombadil"
                                                                attributes:@{
        (id)kCTForegroundColorAttributeName : (id)[UIColor redColor].CGColor,
        NSFontAttributeName : [UIFont boldSystemFontOfSize:16],
        NSKernAttributeName : [NSNull null],
        (id)kTTTBackgroundFillColorAttributeName : (id)[UIColor greenColor].CGColor
}];

// 不再继承其他label上的任何文本相关的属性, 直接设置 字符串.
attributedLabel.text = attString;
// NSString

TTTAttributedLabel *label = [[TTTAttributedLabel alloc] initWithFrame:CGRectZero];
label.font = [UIFont systemFontOfSize:14];
label.textColor = [UIColor darkGrayColor];
label.lineBreakMode = NSLineBreakByWordWrapping;
label.numberOfLines = 0;

// 如果你正在使用一个简单地 `NSString` 作为文本内容, 最好再把它赋值给 `text` 属性,这样可以使文本继承 标签 其他属性.
NSString *text = @"Lorem ipsum dolor sit amet";
[label setText:text afterInheritingLabelAttributesAndConfiguringWithBlock:^ NSMutableAttributedString *(NSMutableAttributedString *mutableAttributedString) {
  NSRange boldRange = [[mutableAttributedString string] rangeOfString:@"ipsum dolor" options:NSCaseInsensitiveSearch];
  NSRange strikeRange = [[mutableAttributedString string] rangeOfString:@"sit amet" options:NSCaseInsensitiveSearch];

  UIFont *boldSystemFont = [UIFont boldSystemFontOfSize:14];
  CTFontRef font = CTFontCreateWithName((__bridge CFStringRef)boldSystemFont.fontName, boldSystemFont.pointSize, NULL);
  if (font) {
    [mutableAttributedString addAttribute:(NSString *)kCTFontAttributeName value:(__bridge id)font range:boldRange];
    [mutableAttributedString addAttribute:kTTTStrikeOutAttributeName value:@YES range:strikeRange];
    CFRelease(font);
  }

  return mutableAttributedString;
}];
</code></pre>

<p>首先,我们创建并配置标签, 就像我们实例化一个UILabel 一样.当使用 -setText:afterInheritingLabelAttributesAndConfiguringWithBlock: 方法时,所有设置在标签上的属性,都被继承用于文本的基础属性.在这里例子中,子字符串”ipsum dolar”, 将会以黑体显示,因此此标签上的内容会显示为: “Lorem ipsum dolar sit amet”, 字体为 14 Helvetica,颜色为 深灰色.</p>

<h3>可视化设计</h3>

<p>TTTAttributedLabel 包含了IBInspectable 和 IB_DESIGNABLE 注解,以支持在界面构建器中配置 此标签.但是,如果你在编译时,看到如下警告:</p>

<pre><code class="ruby">IB Designables: Failed to update auto layout status: Failed to load designables from path (null)
IB Designables: Failed to render instance of TTTAttributedLabel: Failed to load designables from path (null)
</code></pre>

<p>那么很可能是因为你以 静态库的方式使用的 TTTAttributedLabel, 这种方式是不支持 可视化设计相关的注释的.此时可以尝试其他方式:</p>

<p>以动态库的方式安装 TTTAttributedLabel, 需要在是使用CocoaPods时在 Podfile 指定 use_frameworks!, 或者使用 Carthage.
直接把 TTTAttributedLabel 源文件拖拽到你的工程里来安装 TTTAttributedLabel.
链接和数据检测</p>

<p>为了更好地富文本, TTTAttributedLabel 可以自动地检测 时间,地址, 网址,电话话,出行信息(如航班) 等的链接,并且你也可以嵌入你自己的链接.</p>

<pre><code class="objc">label.enabledTextCheckingTypes = NSTextCheckingTypeLink; // 在文本内容改变时,自动检测链接
label.delegate = self; // 用户点击链接时,代理的方法会被调用.(详见:`TTTAttributedLabelDelegate` 协议.)
 label.text = @"Fork me on GitHub! (http://github.com/mattt/TTTAttributedLabel/)"; // 库链接会被自动检测到并关联起来.
NSRange range = [label.text rangeOfString:@"me"]; 
[label addLinkToURL:[NSURL URLWithString:@"http://github.com/mattt/"] withRange:range]; // 在子字符串中,嵌入一个自定义的链接.
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[TTTAttributedLabel 可以显示 简单文本和富文本: 只需要传递 NSString 或 NSAttributedString 给 设置器setText: 即可.
]]></excerpt:encoded>
		<wp:post_id>70</wp:post_id>
		<wp:post_date>2015-08-21 12:06:26</wp:post_date>
		<wp:post_date_gmt>2015-08-21 04:06:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>tttattributedlabel</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="tttattributedlabel"><![CDATA[TTTAttributedLabel]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_TTTAttributedLabel-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>AFNetworking 让你不再害怕网络请求的库</title>
		<link>http://www.ios122.com/2015/08/afnetworking/</link>
		<pubDate>Sun, 23 Aug 2015 11:17:41 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://ios122.com/?p=74</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a></li>
<li>实例下载: <a href="https://github.com/AFNetworking/AFNetworking/archive/master.zip">点击下载</a></li>
<li>注意:官方github实例,如果XCode不是最新版本,可能需要先删除示例中的 iwatch 相关的 target,才能通过编译.</li>
</ul>

<h2>使用 CocoaPods 安装:</h2>

<pre><code class="ruby">platform :ios, '7.0'
pod "AFNetworking", "~&gt; 2.0"
</code></pre>

<h2>结构</h2>

<h3>NSURLConnection</h3>

<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>

<h3>NSURLSession (iOS 7 / Mac OS X 10.9)</h3>

<ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>

<h3>序列化</h3>

<ul>
<li>&lt; AFURLRequestSerialization &gt;

<ul>
<li>AFHTTPRequestSerializer</li>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul></li>
<li>&lt; AFURLResponseSerialization &gt;

<ul>
<li>AFHTTPResponseSerializer</li>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer (Mac OS X)</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul></li>
</ul>

<h3>其他功能:</h3>

<ul>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachabilityManager </li>
</ul>

<h2>用法</h2>

<h3>网络请求管理:</h3>

<p>AFHTTPRequestOperationManager 封装了通过 HTTP 方式与web 应用服务器通信的通用操作, 包括 请求的创建, 服务器响应信息的序列化, 联网状态的监控和 安全.</p>

<h4>GET 请求:</h4>

<pre><code class="objc">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<h4>POST 请求: 以URL编码方式提交表单:</h4>

<pre><code class="objc">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
[manager POST:@"http://example.com/resources.json" parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<h4>POST 请求 含有文件上传的表单:</h4>

<pre><code class="objc">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
[manager POST:@"http://example.com/resources.json" parameters:parameters constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
    [formData appendPartWithFileURL:filePath name:@"image" error:nil];
} success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"Success: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<h3>AFURLSessionManager:</h3>

<p>AFURLSessionManager,创建并管理一个 NSURLSession 对象.这个NSURLSession对象,基于一个指定的NSURLSessionConfiguration对象.NSURLSessionConfiguration 对象,遵循<NSURLSessionTaskDelegate>, <NSURLSessionDataDelegate>, <NSURLSessionDownloadDelegate> 和 <NSURLSessionDelegate>协议.</p>

<h4>创建一个下载任务:</h4>

<pre><code class="objc">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {
    NSLog(@"File downloaded to: %@", filePath);
}];
[downloadTask resume];
</code></pre>

<h4>创建一个上传任务:</h4>

<pre><code class="objc">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"Success: %@ %@", response, responseObject);
    }
}];
[uploadTask resume];
</code></pre>

<h4>创建一个单次含有多个信息的有进度指示的上传任务:</h4>

<pre><code class="objc">NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil];
    } error:nil];

AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSProgress *progress = nil;

NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];

[uploadTask resume];
</code></pre>

<h4>创建一个数据任务:</h4>

<pre><code class="objc">NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];

NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];

NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {
    if (error) {
        NSLog(@"Error: %@", error);
    } else {
        NSLog(@"%@ %@", response, responseObject);
    }
}];
[dataTask resume];
</code></pre>

<h3>请求序列化</h3>

<p>请求序列化器,通过将请求参数编码为查询字符串或者 HTTP 请求体,来为URL字符串创建请求.</p>

<pre><code class="objc">NSString *URLString = @"http://example.com";
NSDictionary *parameters = @{@"foo": @"bar", @"baz": @[@1, @2, @3]};
</code></pre>

<h4>编码为查询字符串:</h4>

<pre><code class="objc">[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil];
GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<h4>编码为URL表单:</h4>

<pre><code class="objc">[[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];
POST http://example.com/
Content-Type: application/x-www-form-urlencoded

foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3
</code></pre>

<h4>编码为JSON字符串:</h4>

<pre><code class="objc">[[AFJSONRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters];
POST http://example.com/
Content-Type: application/json

{"foo": "bar", "baz": [1,2,3]}
</code></pre>

<h3>联网情况的管理:</h3>

<h4>AFNetworkReachabilityManager 监测WWAN和WiFi接口的网络联通行.</h4>

<p>不要依据它来决定是否发起网络请求.你应该尝试发送网络请求.
你可以依据它来选择是否自动重新发送请求.即使仍然可能失败,但接到万罗联通性变化的通知时,可能会是一个很好地重试某些操作的时机.
它会是一个很好地判断请求失败的原因的工具.当网络请求失败时,告诉用户他们已经离线,要比告诉他们一些比如”请求超时”一类的准确的错误更好.
共享的网络联通性:</p>

<pre><code class="objc">[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status));
}];

[[AFNetworkReachabilityManager sharedManager] startMonitoring];
</code></pre>

<h4>基于特定HTTP请求的网络连通性:</h4>

<pre><code class="objc">NSURL *baseURL = [NSURL URLWithString:@"http://example.com/"];
AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];

NSOperationQueue *operationQueue = manager.operationQueue;
[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusReachableViaWWAN:
        case AFNetworkReachabilityStatusReachableViaWiFi:
            [operationQueue setSuspended:NO];
            break;
        case AFNetworkReachabilityStatusNotReachable:
        default:
            [operationQueue setSuspended:YES];
            break;
    }
}];

[manager.reachabilityManager startMonitoring];
</code></pre>

<h3>安全策略</h3>

<p>AFSecurityPolicy 基于 X.509 数字证书和公钥来确定服务器是否可信.</p>

<p>往应用中添加证书来组织中间人攻击和其他的漏洞.需要处理敏感的用户数据或者金融信息的应用,强烈建议使用基于配置好并可用的SSL的HTTPS链接来和服务器通信.</p>

<h4>允许无效的 SSL 证书:</h4>

<pre><code class="objc">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
manager.securityPolicy.allowInvalidCertificates = YES; // 生产环境不建议使用
</code></pre>

<h3>AFHTTPRequestOperation</h3>

<p>AFHTTPRequestOperation 是AFURLConnectionOperation 的子类.AFURLConnectionOperation用于使用HTTP 或 HTTPS的网络请求.AFHTTPRequestOperation封装了可接受的状态码和内容类型,这些信息将用于决定请求成功或者失败.</p>

<p>尽管 AFHTTPRequestOperationManager 通常是请求数据的最佳方式, AFHTTPRequestOperation 仍然是可以单独使用的.</p>

<h4>使用 AFHTTPRequestOperation 的GET请求:</h4>

<pre><code class="objc">NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"];
NSURLRequest *request = [NSURLRequest requestWithURL:URL];
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];
op.responseSerializer = [AFJSONResponseSerializer serializer];
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
[[NSOperationQueue mainQueue] addOperation:op];
</code></pre>

<h4>批量操作:</h4>

<pre><code class="objc">NSMutableArray *mutableOperations = [NSMutableArray array];
for (NSURL *fileURL in filesToUpload) {
    NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileURL:fileURL name:@"images[]" error:nil];
    }];

    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

    [mutableOperations addObject:operation];
}

NSArray *operations = [AFURLConnectionOperation batchOfRequestOperations:@[...] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
    NSLog(@"%lu of %lu complete", numberOfFinishedOperations, totalNumberOfOperations);
} completionBlock:^(NSArray *operations) {
    NSLog(@"All operations in batch complete");
}];
[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[让你不再害怕网络请求的库]]></excerpt:encoded>
		<wp:post_id>74</wp:post_id>
		<wp:post_date>2015-08-23 19:17:41</wp:post_date>
		<wp:post_date_gmt>2015-08-23 11:17:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>afnetworking</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="afnetworking"><![CDATA[AFNetworking]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_AFNetworking-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>SDWebImage 异步缓存加载网络图片的最便捷方法</title>
		<link>http://www.ios122.com/2015/08/sdwebimage/</link>
		<pubDate>Sun, 23 Aug 2015 17:10:21 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=77</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/rs/SDWebImage">SDWebImage</a></li>
<li>实例下载: <a href="https://github.com/rs/SDWebImage/archive/master.zip">点击下载</a></li>
<li>注意: 较低版本XCODE中,官方示例可能无法运行.建议新建工程,通过pod安装SDWebImage后,把官方DEMO的代码复制到自己的空白工程中.)</li>
</ul>

<h2>通过 CocoaPods 安装</h2>

<pre><code class="ruby">pod 'SDWebImage'
</code></pre>

<p>然后在需要使用 SDWebImage的地方引入头文件:</p>

<pre><code class="objc">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
</code></pre>

<h2>在 UITableView  中 使用 UIImageView+WebCache 扩展</h2>

<p>只需要引入 头文件 UIImageView+WebCache.h,并且在UITableViewDataSource代理方法中tableView:cellForRowAtIndexPath: 调用 sd_setImageWithURL:placeholderImage:  方法即可.异步下载并缓存图片,你需要做的只要这么做.</p>

<pre><code class="objc">#import &lt;SDWebImage/UIImageView+WebCache.h&gt;

...

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *MyIdentifier = @"MyIdentifier";

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];

    if (cell == nil)
    {
        cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault
                                       reuseIdentifier:MyIdentifier] autorelease];
    }

    [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"]
                      placeholderImage:[UIImage imageNamed:@"placeholder.png"]];

    cell.textLabel.text = @"My Text";
    return cell;
}
</code></pre>

<h2>使用 blocks</h2>

<p>使用blocks, 你可以处理图片下载中,下载失败,下载成功或下载完成相关的事件:</p>

<pre><code class="objc"> [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"] placeholderImage:[UIImage imageNamed:@"placeholder.png"] completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {/* 处理相关事件的代码. */}];
</code></pre>

<p>注意: 如果在完成前取消了请求,那么 成功或者失败的回调方法(block),都不会被执行.</p>

<h2>使用 SDWebImageManager</h2>

<p>SDWebImageManager 是 UIImageView+WebCache 扩展的内部实现使用的类.它把异步下载器和图片缓存体系关联起来.你可以直接使用这个类来下载网络图片并缓存起来.</p>

<p>下面是一个关于如何使用 SDWebImageManager 的简单例子:</p>

<pre><code class="objc">SDWebImageManager *manager = [SDWebImageManager sharedManager];
[manager downloadImageWithURL:imageURL
                      options:0
                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                         // 处理下载进度的代码.
                     }
                     completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {
                         if (image) {
                             // 使用这张图片.
                         }
                     }];
</code></pre>

<h2>独立使用异步图片下载器</h2>

<pre><code class="objc">[SDWebImageDownloader.sharedDownloader downloadImageWithURL:imageURL
                                                    options:0
                                                   progress:^(NSInteger receivedSize, NSInteger expectedSize)
                                                   {
// 处理下载进度的代码.
} completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) { if (image &amp;&amp; finished) { //使用这张图片.
} }];
</code></pre>

<h2>独立使用异步图片缓存</h2>

<pre><code class="objc">SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@"myNamespace"];
[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image)
{
    // 如果找不到图片,image会为nil.
}];
</code></pre>

<p>queryDiskCacheForKey: 会优先搜索内存缓存,内存缓存不存在时,会继续搜索磁盘缓存.如果只想搜索内存缓存中的数据,可以使用 imageFromMemoryCacheForKey: 方法.</p>

<p>可以使用storeImage:forKey: 方法把图片存到缓存里:</p>

<pre><code class="objc">[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];
</code></pre>

<p>此方法默认会同时异步存到磁盘缓存一份,如果你只想使用内存缓存,可以使用storeImage:forKey:toDisk: 第三个参数传负数即可.</p>

<h2>使用缓存key过滤器</h2>

<p>通常使用 URL 作为缓存key,但如果你不想使用,可以自定义缓存key过滤器,来指定以何种方式产生缓存key.这在URL是动态地址时,比如有一些权限控制的字符串,会很有用.</p>

<pre><code class="objc">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL *url) {
        url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];
        return [url absoluteString];
    };

    // Your app init code...
    return YES;
}
</code></pre>

<h2>管理图片刷新</h2>

<pre><code class="objc">[imageView sd_setImageWithURL:[NSURL URLWithString:@"https://graph.facebook.com/olivier.poitrey/picture"]
                 placeholderImage:[UIImage imageNamed:@"avatar-placeholder.png"]
                options:SDWebImageRefreshCached];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[异步缓存加载网络图片的最便捷方法]]></excerpt:encoded>
		<wp:post_id>77</wp:post_id>
		<wp:post_date>2015-08-24 01:10:21</wp:post_date>
		<wp:post_date_gmt>2015-08-23 17:10:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>sdwebimage</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="sdwebimage"><![CDATA[SDWebImage]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SDWebImage-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>GPUImage 基于GPU加速的图形和视频处理库</title>
		<link>http://www.ios122.com/2015/08/gpuimage/</link>
		<pubDate>Mon, 24 Aug 2015 04:43:03 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=83</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>GPUImage基于OpenGL ES 2.0,比基于CPU的图形和视频处理更快速.GPUImage把OpenGL ES封装为简洁的Objective-C接口.</p>

<ul>
<li>项目主页: <a href="https://github.com/BradLarson/GPUImage">GPUImage</a></li>
<li>实例下载: <a href="https://github.com/BradLarson/GPUImage/archive/master.zip">点击下载</a></li>
</ul>

<h2>把GPUImage引入到你的工程:</h2>

<p>把 GPUImage.xcodeproj 文件拖到你的工程中,然后把GPUImage作为一个依赖目标,最后添加 libGPUImage.a静态库即可.</p>

<p>GPUImage 需要使用下面这些库:</p>

<ul>
<li>CoreMedia</li>
<li>CoreVideo</li>
<li>OpenGLES</li>
<li>AVFoundation</li>
<li>QuartzCore</li>
</ul>

<p>在需要使用 GPUImage的地方直接引入即可:</p>

<pre><code class="objc">#import "GPUImage.h"
</code></pre>

<h2>常见的应用场景:</h2>

<h3>录制视频时使用滤镜:</h3>

<p>为了在iOS设备录制视频时实时即时添加滤镜,你可以类似下面的代码:</p>

<pre><code class="objc">GPUImageVideoCamera *videoCamera = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset640x480 cameraPosition:AVCaptureDevicePositionBack];
videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;

GPUImageFilter *customFilter = [[GPUImageFilter alloc] initWithFragmentShaderFromFile:@"CustomShader"];
GPUImageView *filteredVideoView = [[GPUImageView alloc] initWithFrame:CGRectMake(0.0, 0.0, viewWidth, viewHeight)];

//要把filteredVideoView添加到某个视图上,使其可见.

[videoCamera addTarget:customFilter]; [customFilter addTarget:filteredVideoView]; [videoCamera startCameraCapture];
如果你想录制视频时,同步录制音频,可以设置相机的audioEncodingTarget属性:

videoCamera.audioEncodingTarget = movieWriter;
</code></pre>

<h3>截图并给静态的图片添加滤镜:</h3>

<p>过程和上面类似,但是这次你要使用 GPUImageStillCamera:</p>

<pre><code class="objc">stillCamera = [[GPUImageStillCamera alloc] init];
stillCamera.outputImageOrientation = UIInterfaceOrientationPortrait;

filter = [[GPUImageGammaFilter alloc] init];
[stillCamera addTarget:filter];
GPUImageView *filterView = (GPUImageView *)self.view;
[filter addTarget:filterView];

[stillCamera startCameraCapture];
</code></pre>

<p>如果你想使用一个截取图片,你可以像下面这样使用回调函数:</p>

<pre><code class="objc">[stillCamera capturePhotoProcessedUpToFilter:filter withCompletionHandler:^(UIImage *processedImage, NSError *error){
    NSData *dataForJPEGFile = UIImageJPEGRepresentation(processedImage, 0.8);

    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentsDirectory = [paths objectAtIndex:0];

    NSError *error2 = nil;
    if (![dataForJPEGFile writeToFile:[documentsDirectory stringByAppendingPathComponent:@"FilteredPhoto.jpg"] options:NSAtomicWrite error:&amp;error2])
    {
        return;
    }
}];
</code></pre>

<h3>处理单张静态图片</h3>

<p>有好多种办法来处理并保存单张图片,比如下面这样:</p>

<pre><code class="objc">UIImage *inputImage = [UIImage imageNamed:@"Lambeau.jpg"];

GPUImagePicture *stillImageSource = [[GPUImagePicture alloc] initWithImage:inputImage];

// 这是一个滤镜,你可以使用替换为其他你需要的滤镜.
GPUImageSepiaFilter *stillImageFilter = [[GPUImageSepiaFilter alloc] init];

[stillImageSource addTarget:stillImageFilter];

// 如果需要处理滤镜处理后的结果,应显示指出.
[stillImageFilter useNextFrameForImageCapture];
[stillImageSource processImage];

UIImage *currentFilteredVideoFrame = [stillImageFilter imageFromCurrentFramebuffer];
</code></pre>

<p>如果你只是想看下图片上使用不同滤镜的效果,可以像下面这样做:</p>

<pre><code class="objc">GPUImageSepiaFilter *stillImageFilter2 = [[GPUImageSepiaFilter alloc] init];
UIImage *quickFilteredImage = [stillImageFilter2 imageByFilteringImage:inputImage];
</code></pre>

<h3>写一个自定义的滤镜</h3>

<p>GPUImage 支持编写自定义滤镜,需要使用GLSL语言(OpenGL Shading Language, 一种类C语言).注意添加时,不要把GLSL语言文件添加为资源文件,而不是可编译文件.</p>

<p>自定义滤镜的初始化:</p>

<pre><code class="objc">customFilter = [[GPUImageFilter alloc] initWithFragmentShaderFromFile:@"CustomShader"];
</code></pre>

<p>下面是一个GLSL 写的 sepia-tone 滤镜的例子:</p>

<pre><code class="c">varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;

void main()
{
    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);
    lowp vec4 outputColor;
    outputColor.r = (textureColor.r * 0.393) + (textureColor.g * 0.769) + (textureColor.b * 0.189);
    outputColor.g = (textureColor.r * 0.349) + (textureColor.g * 0.686) + (textureColor.b * 0.168);    
    outputColor.b = (textureColor.r * 0.272) + (textureColor.g * 0.534) + (textureColor.b * 0.131);
    outputColor.a = 1.0;

    gl_FragColor = outputColor;
}
</code></pre>

<h3>添加滤镜并重新编码电影</h3>

<p>使用 GPUImageMovie 把电影载入,添加滤镜,并使用 GPUImageMovieWriter 输出.</p>

<p>下面的例子演示了如何引入一个实例电影,并把它传递给像素滤镜,然后记录结果并存储为 480 x 640 h.264 格式的电影:</p>

<pre><code class="objc">movieFile = [[GPUImageMovie alloc] initWithURL:sampleURL];
pixellateFilter = [[GPUImagePixellateFilter alloc] init];

[movieFile addTarget:pixellateFilter];

NSString *pathToMovie = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents/Movie.m4v"];
unlink([pathToMovie UTF8String]);
NSURL *movieURL = [NSURL fileURLWithPath:pathToMovie];

movieWriter = [[GPUImageMovieWriter alloc] initWithMovieURL:movieURL size:CGSizeMake(480.0, 640.0)];
[pixellateFilter addTarget:movieWriter];

movieWriter.shouldPassthroughAudio = YES;
movieFile.audioEncodingTarget = movieWriter;
[movieFile enableSynchronizedEncodingUsingMovieWriter:movieWriter];

[movieWriter startRecording];
[movieFile startProcessing];
</code></pre>

<p>只有操作完成时,视频才可用:</p>

<pre><code class="objc">[pixellateFilter removeTarget:movieWriter];
[movieWriter finishRecording];
</code></pre>

<h2>内置的滤镜</h2>

<p>目前有 125 中内置滤镜,被分为下面几类:</p>

<ul>
<li>颜色调整</li>
<li>图片处理</li>
<li>混合模式</li>
<li>视觉效果</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[GPUImage基于OpenGL ES 2.0,比基于CPU的图形和视频处理更快速.GPUImage把OpenGL ES封装为简洁的Objective-C接口.]]></excerpt:encoded>
		<wp:post_id>83</wp:post_id>
		<wp:post_date>2015-08-24 12:43:03</wp:post_date>
		<wp:post_date_gmt>2015-08-24 04:43:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>gpuimage</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="gpuimage"><![CDATA[GPUImage]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_GPUImage-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>JSONModel    JSON字符串与数据模型自动智能转换</title>
		<link>http://www.ios122.com/2015/08/jsonmodel/</link>
		<pubDate>Tue, 25 Aug 2015 03:48:37 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=92</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>JOSONModel 是一个用于实现 JSON字符串与 iOS 数据模型相互转换的库.你只需要少量的代码,就能实现 JSON字符串与自定义数据模型的快速转换.在转换时,能保留模型既定的内部层次结构.</p>

<ul>
<li>项目主页: <a href="https://github.com/icanzilb/JSONModel">JSONModel</a></li>
<li>实例下载: <a href="https://github.com/icanzilb/JSONModel/archive/master.zip">点击下载</a></li>
</ul>

<h2>通过 Cocoa pods 安装</h2>

<pre><code class="ruby">pod 'JSONModel'
</code></pre>

<h2>基础用法</h2>

<p>假定你的 JSON 类似这样:</p>

<pre><code class="json">{"id":"10", "country":"Germany", "dialCode": 49, "isInEurope":true}
</code></pre>

<p>为你的数据模型创建一个继承自 JSONModel 类的 Objective-C 类.
在你的自定义类的头文件中,声明以下和JSON的键同名的属性:</p>

<pre><code class="objc">#import "JSONModel.h"

@interface CountryModel : JSONModel

@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString* country;
@property (strong, nonatomic) NSString* dialCode;
@property (assign, nonatomic) BOOL isInEurope;

@end
</code></pre>

<p>自定义类的.m文件中,不需要写任何代码.</p>

<p>用数据初始化你的数据模型:</p>

<pre><code class="objc">#import "CountryModel.h"
...

NSString* json = (fetch here JSON from Internet) ... 
NSError* err = nil;
CountryModel* country = [[CountryModel alloc] initWithString:json error:&amp;err];
</code></pre>

<p>JSON传递进来之后,你的数据模型会自动拥有根据JSON数据初始化的属性值.JSONModel 也会试着尽可能地把数据类型转换为你需要的类型.在这个实例中,它会:</p>

<ul>
<li><p>把 “id” 从字符串(JSON中)转换为 整型(你的数据模型类中).</p></li>
<li><p>复制 “country” 的值.</p></li>
<li><p>把 “dialCode” 从数字(JSON中)转换为字符串(你的数据模型中).</p></li>
<li><p>最后把 “isInEurope” 转换为你的布尔属性需要的布尔类型(BOOL).</p></li>
</ul>

<p>以上,所有的工作,真正需要你去做的只是: 在自己的数据模型类中定义属性,并指明需要的数据类型.</p>

<h2>实例</h2>

<h3>基于映射的自动名字对应转换</h3>

<pre><code class="json">{
  "id": "123",
  "name": "Product name",
  "price": 12.95
}
</code></pre>

<pre><code class="objc">@interface ProductModel : JSONModel
@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString* name;
@property (assign, nonatomic) float price;
@end

@implementation ProductModel
@end
</code></pre>

<h3>数据模型嵌套(包含着其他数据模型的数据模型)</h3>

<pre><code class="objc">{
  "order_id": 104,
  "total_price": 13.45,
  "product" : {
    "id": "123",
    "name": "Product name",
    "price": 12.95
  }
}
</code></pre>

<pre><code class="objc">@interface OrderModel : JSONModel
@property (assign, nonatomic) int order_id;
@property (assign, nonatomic) float total_price;
@property (strong, nonatomic) ProductModel* product;
@end

@implementation OrderModel
@end
</code></pre>

<h3>数据模型集合</h3>

<pre><code class="objc">{
  "order_id": 104,
  "total_price": 103.45,
  "products" : [
    {
      "id": "123",
      "name": "Product #1",
      "price": 12.95
    },
    {
      "id": "137",
      "name": "Product #2",
      "price": 82.95
    }
  ]
}
</code></pre>

<pre><code class="objc">@protocol ProductModel
@end

@interface ProductModel : JSONModel
@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString* name;
@property (assign, nonatomic) float price;
@end

@implementation ProductModel
@end

@interface OrderModel : JSONModel
@property (assign, nonatomic) int order_id;
@property (assign, nonatomic) float total_price;
@property (strong, nonatomic) NSArray&lt;ProductModel&gt;* products;
@end

@implementation OrderModel
@end
</code></pre>

<h3>自定义 JSON键与模型属性的对应关系</h3>

<pre><code class="objc">{
  "order_id": 104,
  "order_details" : [
    {
      "name": "Product#1",
      "price": {
        "usd": 12.95
      }
    }
  ]
}
</code></pre>

<pre><code class="objc">@interface OrderModel : JSONModel
@property (assign, nonatomic) int id;
@property (assign, nonatomic) float price;
@property (strong, nonatomic) NSString* productName;
@end

@implementation OrderModel

+(JSONKeyMapper*)keyMapper
{
  return [[JSONKeyMapper alloc] initWithDictionary:@{
    @"order_id": @"id",
    @"order_details.name": @"productName",
    @"order_details.price.usd": @"price"
  }];
}

@end
</code></pre>

<h3>定义全局键-属性映射(将会应用于你应用中所有的数据模型)</h3>

<pre><code class="objc">[JSONModel setGlobalKeyMapper:[
    [JSONKeyMapper alloc] initWithDictionary:@{
      @"item_id":@"ID",
      @"item.name": @"itemName"
   }]
];
</code></pre>

<h3>自动将下划线映射为驼峰命名的属性</h3>

<pre><code class="json">{
  "order_id": 104,
  "order_product" : @"Product#1",
  "order_price" : 12.95
}
</code></pre>

<pre><code class="objc">@interface OrderModel : JSONModel

@property (assign, nonatomic) int orderId;
@property (assign, nonatomic) float orderPrice;
@property (strong, nonatomic) NSString* orderProduct;

@end

@implementation OrderModel

+(JSONKeyMapper*)keyMapper
{
  return [JSONKeyMapper mapperFromUnderscoreCaseToCamelCase];
}

@end
</code></pre>

<h3>可选属性.(JSON 中可以没有或者为null).</h3>

<pre><code class="json">{
  "id": "123",
  "name": null,
  "price": 12.95
}
</code></pre>

<pre><code class="objc">@interface ProductModel : JSONModel
@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString&lt;Optional&gt;* name;
@property (assign, nonatomic) float price;
@property (strong, nonatomic) NSNumber&lt;Optional&gt;* uuid;
@end

@implementation ProductModel
@end
</code></pre>

<h3>需要忽略的属性 (JSONModel 会直接忽略这些属性)</h3>

<pre><code class="json">{
  "id": "123",
  "name": null
}
</code></pre>

<pre><code class="objc">@interface ProductModel : JSONModel
@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString&lt;Ignore&gt;* customProperty;
@end

@implementation ProductModel
@end
</code></pre>

<h3>忽略所有属性(尽量不要这么做)</h3>

<pre><code class="objc">@implementation ProductModel
+(BOOL)propertyIsOptional:(NSString*)propertyName
{
  return YES;
}
@end
</code></pre>

<h3>延迟转换JSON字典中的集合元素为数据模型.</h3>

<pre><code class="json">{
  "order_id": 104,
  "total_price": 103.45,
  "products" : [
    {
      "id": "123",
      "name": "Product #1",
      "price": 12.95
    },
    {
      "id": "137",
      "name": "Product #2",
      "price": 82.95
    }
  ]
}
</code></pre>

<pre><code class="objc">@protocol ProductModel
@end

@interface ProductModel : JSONModel
@property (assign, nonatomic) int id;
@property (strong, nonatomic) NSString* name;
@property (assign, nonatomic) float price;
@end

@implementation ProductModel
@end

@interface OrderModel : JSONModel
@property (assign, nonatomic) int order_id;
@property (assign, nonatomic) float total_price;
@property (strong, nonatomic) NSArray&lt;ProductModel, ConvertOnDemand&gt;* products;
@end

@implementation OrderModel
@end
</code></pre>

<h3>使用内置的 HTTP 客户端</h3>

<pre><code class="objc">// 添加额外的头信息
[[JSONHTTPClient requestHeaders] setValue:@"MySecret" forKey:@"AuthorizationToken"];

//发送 post, get 请求.
[JSONHTTPClient postJSONFromURLWithString:@"http://mydomain.com/api"
                                   params:@{@"postParam1":@"value1"}
                               completion:^(id json, JSONModelError *err) {

                                   //检查错误, 处理 json ...

                               }];
</code></pre>

<h3>把模型转换为字典(NSDictionary) 或 JSON字符串</h3>

<pre><code class="objc">ProductModel* pm = [[ProductModel alloc] initWithString:jsonString error:nil];
pm.name = @"Changed Name";

//convert to dictionary
NSDictionary* dict = [pm toDictionary];

//convert to text
NSString* string = [pm toJSONString];
</code></pre>

<h3>自定义数据类型转换规则</h3>

<pre><code class="objc">@implementation JSONValueTransformer (CustomTransformer)

- (NSDate *)NSDateFromNSString:(NSString*)string {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:APIDateFormat];
    return [formatter dateFromString:string];
}

- (NSString *)JSONObjectFromNSDate:(NSDate *)date {
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:APIDateFormat];
    return [formatter stringFromDate:date];
}

@end
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[JOSONModel 是一个用于实现 JSON字符串与 iOS 数据模型相互转换的库.你只需要少量的代码,就能实现 JSON字符串与自定义数据模型的快速转换.在转换时,能保留模型既定的内部层次结构.]]></excerpt:encoded>
		<wp:post_id>92</wp:post_id>
		<wp:post_date>2015-08-25 11:48:37</wp:post_date>
		<wp:post_date_gmt>2015-08-25 03:48:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>jsonmodel</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="jsonmodel"><![CDATA[JSONModel]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_JSONModel-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>SIAlertView 支持多种弹出效果和Block语法的弹出框</title>
		<link>http://www.ios122.com/2015/08/sialertview/</link>
		<pubDate>Tue, 25 Aug 2015 07:10:45 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=102</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>一个支持多种BLOCK语法和多张弹出动画效果的弹出框,可以用来替代 UIAlertView.</p>

<ul>
<li>项目主页: <a href="https://github.com/Sumi-Interactive/SIAlertView">SIAlertView</a></li>
<li>实例下载: <a href="https://github.com/Sumi-Interactive/SIAlertView/archive/master.zip">点击下载</a></li>
</ul>

<h2>使用 Cocoapods 安装</h2>

<pre><code class="ruby">pod 'SIAlertView'
</code></pre>

<h2>代码示例</h2>

<pre><code class="objc">SIAlertView *alertView = [[SIAlertView alloc] initWithTitle:@"SIAlertView" andMessage:@"弹出框"];

[alertView addButtonWithTitle:@"按钮1"
                         type:SIAlertViewButtonTypeDefault
                      handler:^(SIAlertView *alert) {
                          NSLog(@"按钮1 被点击");
                      }];
[alertView addButtonWithTitle:@"按钮2"
                         type:SIAlertViewButtonTypeDestructive
                      handler:^(SIAlertView *alert) {
                          NSLog(@"按钮2被点击");
                      }];
[alertView addButtonWithTitle:@"按钮3"
                         type:SIAlertViewButtonTypeCancel
                      handler:^(SIAlertView *alert) {
                          NSLog(@"按钮3被点击");
                      }];

alertView.willShowHandler = ^(SIAlertView *alertView) {
    NSLog(@"%@,将要显示", alertView);
};
alertView.didShowHandler = ^(SIAlertView *alertView) {
    NSLog(@"%@,正在显示", alertView);
};
alertView.willDismissHandler = ^(SIAlertView *alertView) {
    NSLog(@"%@,将要消失", alertView);
};
alertView.didDismissHandler = ^(SIAlertView *alertView) {
    NSLog(@"%@,已经消失", alertView);
};

alertView.transitionStyle = SIAlertViewTransitionStyleBounce;

[alertView show];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[一个支持多种BLOCK语法和多张弹出动画效果的弹出框,可以用来替代 UIAlertView.]]></excerpt:encoded>
		<wp:post_id>102</wp:post_id>
		<wp:post_date>2015-08-25 15:10:45</wp:post_date>
		<wp:post_date_gmt>2015-08-25 07:10:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>sialertview</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="sialertview"><![CDATA[SIAlertView]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_ba76c8a2c0325a23279211bdf1fc6fa8</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_SIAlertView-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>MMDrawerController 轻量级抽屉式导航</title>
		<link>http://www.ios122.com/2015/08/mmdrawercontroller/</link>
		<pubDate>Tue, 25 Aug 2015 07:52:18 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=104</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>一个用于支持抽屉式导航的库.为了保持轻量级,适当舍弃了抽屉打开或关闭时动画效果的可定制性.</p>

<ul>
<li>项目主页: <a href="https://github.com/mutualmobile/MMDrawerController">MMDrawerController</a></li>
<li>实例下载: <a href="https://github.com/mutualmobile/MMDrawerController/archive/master.zip">点击下载</a></li>
</ul>

<h2>使用 Cocoapods 安装</h2>

<pre><code class="objc">pod 'MMDrawerController', '~&gt; 0.5.7'
</code></pre>

<h2>创建一个抽屉式布局</h2>

<pre><code class="objc">UIViewController * leftDrawer = [[UIViewController alloc] init];
UIViewController * center = [[UIViewController alloc] init];
UIViewController * rightDrawer = [[UIViewController alloc] init];

MMDrawerController * drawerController = [[MMDrawerController alloc]
                                       initWithCenterViewController:center                            leftDrawerViewController:leftDrawer                                       rightDrawerViewController:rightDrawer];
</code></pre>

<h2>特点</h2>

<ul>
<li>支持顶部导航 UINavigationController</li>
<li>支持手势 UIGestureRecognizer</li>
<li>支持自定义手势行为</li>
<li>支持自定义抽屉开关动画</li>
<li>支持自定义抽屉打开是,中心控制器的交互方式.</li>
<li>支持从子视图直接访问抽屉布局.(使用 UIViewController+MMDrawerController 扩展.)</li>
<li>支持状态存储.</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[一个用于支持抽屉式导航的库.为了保持轻量级,适当舍弃了抽屉打开或关闭时动画效果的可定制性.]]></excerpt:encoded>
		<wp:post_id>104</wp:post_id>
		<wp:post_date>2015-08-25 15:52:18</wp:post_date>
		<wp:post_date_gmt>2015-08-25 07:52:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mmdrawercontroller</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mmdrawercontroller"><![CDATA[MMDrawerController]]></category>
		<category domain="category" nicename="ui-component"><![CDATA[酷炫UI]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_MMDrawerController-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>CWStatusBarNotification 在状态栏显示自定义通知</title>
		<link>http://www.ios122.com/2015/08/cwstatusbarnotification/</link>
		<pubDate>Wed, 26 Aug 2015 03:19:57 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=112</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>CWStatusBarNotification 是一个能够让你更容易地在状态栏显示文本通知的库.从 2.2.0 开始, 支持选择自定义通知视图,而不再只是显示文字.</p>

<ul>
<li>项目主页: <a href="https://github.com/cezarywojcik/CWStatusBarNotification">CWStatusBarNotification</a></li>
<li>示例下载: <a href="https://github.com/cezarywojcik/CWStatusBarNotification/archive/master.zip">点击下载</a></li>
<li>注意: 可能需要先删除示例中target的 test,才能让示例正确运行.</li>
</ul>

<h2>系统兼容性</h2>

<ul>
<li>ARC + </li>
<li>iOS 7.0 + </li>
<li>iPhone/ipad</li>
</ul>

<h2>安装</h2>

<h3>通过 CocoaPods 安装</h3>

<pre><code class="ruby">pod 'CWStatusBarNotification', '~&gt; 2.3.2'
</code></pre>

<h3>手动安装</h3>

<p>把项目主页工程中的 CWStatusBarNotification 文件夹拷贝到你的工程中即可.</p>

<h2>用法</h2>

<p>首先,你需要引入头文件:</p>

<pre><code class="objc">#import "CWStatusBarNotification.h"
</code></pre>

<p>现在,你需要创建一个 CWStatusBarNotification 对象.建议把它作为 UIViewController 的一个属性:</p>

<pre><code class="objc">CWStatusBarNotification *notification = [CWStatusBarNotification new];
</code></pre>

<p>创建一个 CWStatusBarNotification 对象之后, 你只需要调用 displayNotificationMessage:forDuration: 方法即可:</p>

<pre><code class="objc">[self.notification displayNotificationWithMessage:@"Hello, World!"
                   forDuration:1.0f];
</code></pre>

<p>如果你想自己控制状态栏通知的出现和消失,你可以这样做:</p>

<pre><code class="objc">[self.notification displayNotificationWithMessage:@"Hello" completion:nil];

// 等到你需要它消失时再消失.
[self.notification dismissNotification];
</code></pre>

<h3>处理轻击事件</h3>

<p>通知被轻击时的默认行为是使通知消失.你可以通过重写 onTapNotification 函数体来改变这一默认行为.</p>

<p>例如:</p>

<pre><code>__weak typeof(self) weakSelf = self;
self.notification.notificationTappedBlock = ^(void) {
    if (!weakSelf.notificationIsDismissing) {
        // 通常需要先隐藏状态栏通知.
        [weakSelf dismissNotification];
        // 在这里写更多的代码.
    }
};
</code></pre>

<h3>自定义外观</h3>

<p>你可以通过 notificationLabelBackgroundColor 属性设置背景色,默认值是 [[UIApplication sharedApplication] delegate].window.tintColor;</p>

<p>你可以通过 notificationLabelTextColor 属性设置文本颜色,默认值是 [UIColor whiteColor];</p>

<p>你可以通过 notificationStyle 属性设置通知是覆盖在状态栏(CWNotificationStyleStatusBarNotification),还是覆盖整个顶部导航栏(CWNotificationStyleNavigationBarNotification),默认值是CWNotificationStyleStatusBarNotification.</p>

<h3>自定义显示/隐藏的动画效果</h3>

<p>可以使用 notificationAnimationInStyle 和 notificationAnimationOutStyle 来指定状态栏显示/隐藏时的动画效果,默认值都是 CWNotificationAnimationStyleTop,可选值是:</p>

<ul>
<li>CWNotificationAnimationStyleTop</li>
<li>CWNotificationAnimationStyleBottom</li>
<li>CWNotificationAnimationStyleLeft</li>
<li>CWNotificationAnimationStyleRight</li>
</ul>

<h3>显示自定义通知视图</h3>

<p>从 2.2.0 开始, 支持选择自定义通知视图,而不再只是显示文字:</p>

<pre><code class="objc">UIView *view = [[NSBundle mainBundle] loadNibNamed:@"CustomView" owner:nil options:nil][0];
[self.notification displayNotificationWithView:view forDuration:self.sliderDuration.value];
</code></pre>

<p>你也可以手动控制何时显示与隐藏:</p>

<pre><code class="objc">[self.notification displayNotificationWithView:view completion:nil];
// 等到你想让它隐藏时,再消失.
[self.notification dismissNotification];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[CWStatusBarNotification 是一个能够让你更容易地在状态栏显示文本通知的库.从 2.2.0 开始, 支持选择自定义通知视图,而不再只是显示文字.]]></excerpt:encoded>
		<wp:post_id>112</wp:post_id>
		<wp:post_date>2015-08-26 11:19:57</wp:post_date>
		<wp:post_date_gmt>2015-08-26 03:19:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>cwstatusbarnotification</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cwstatusbarnotification"><![CDATA[CWStatusBarNotification]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_CWStatusBarNotification-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RESideMenu 有视差效果的侧边菜单</title>
		<link>http://www.ios122.com/2015/08/residemenu/</link>
		<pubDate>Wed, 26 Aug 2015 04:23:04 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=123</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>RESideMenu 是一个有视差效果的侧边菜单.</p>

<ul>
<li>项目主页: <a href="https://github.com/romaonthego/RESideMenu">RESideMenu</a></li>
<li>最新示例: <a href="https://github.com/romaonthego/RESideMenu/archive/master.zip">点击下载</a></li>
</ul>

<h2>系统要求</h2>

<ul>
<li>Xcode 6 +</li>
<li>Apple LLVM 编译器</li>
<li>iOS 6.0 +</li>
<li>ARC</li>
</ul>

<h2>安装</h2>

<h3>使用 CocoaPods 安装</h3>

<pre><code class="ruby">platform :ios, '6.0'
pod 'RESideMenu', '~&gt; 4.0.7'
</code></pre>

<h3>手动安装</h3>

<p>把 RESideMenu 相关类文件拖到你工程中,并在需要使用的地方引入头文件</p>

<pre><code class="objc">#include “RESideMenu.h”
</code></pre>

<h2>纯代码方式</h2>

<p>在你的 AppDelegate 的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  创建视图控制器,并给它设置用于显示内容和侧边菜单的视图控制器.</p>

<pre><code class="objc">// 创建内容和菜单视图控制器.
//
DEMONavigationController *navigationController = [[DEMONavigationController alloc] initWithRootViewController:[[DEMOHomeViewController alloc] init]];
DEMOLeftMenuViewController *leftMenuViewController = [[DEMOLeftMenuViewController alloc] init];
DEMORightMenuViewController *rightMenuViewController = [[DEMORightMenuViewController alloc] init];

// 创建 RESideMenu 控制器.
//
RESideMenu *sideMenuViewController = [[RESideMenu alloc] initWithContentViewController:navigationController
                                                                leftMenuViewController:leftMenuViewController
                                                               rightMenuViewController:rightMenuViewController];
sideMenuViewController.backgroundImage = [UIImage imageNamed:@"Stars"];

// 将 RESideMenu 控制器设置为根控制器.
//
self.window.rootViewController = sideMenuViewController;
</code></pre>

<h3>显示侧边菜单的视图控制器:</h3>

<pre><code class="objc">[self.sideMenuViewController presentLeftMenuViewController];
</code></pre>

<p>或</p>

<pre><code class="objc">[self.sideMenuViewController presentRightMenuViewController];
</code></pre>

<h3>更改用于显示内容的视图控制器:</h3>

<pre><code class="objc">#import &lt;RESideMenu/RESideMenu.h&gt;

....

[self.sideMenuViewController setContentViewController:viewController animated:YES];
[self.sideMenuViewController hideMenuViewController];
</code></pre>

<h2>在 Storyboard 中使用</h2>

<p>创建一个 RESideMenu 的子类,如 DEMORootViewController.
在Storyboard中,将DEMORootViewController制定为 根视图的 所有者.
在Storyboard中添加更多的视图控制器,并将他们的标识符设为 “leftMenuViewController”, “rightMenuViewController” 和”contentViewController”.
在你的 DEMORootViewController.m 中添加方法 awakeFromNib, 代码类似下面这样:</p>

<pre><code class="objc">- (void)awakeFromNib
{
    self.contentViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"contentViewController"];
    self.leftMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"leftMenuViewController"];
    self.rightMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@"rightMenuViewController"];
}
</code></pre>

<h2>自定义</h2>

<h3>你可以自定义RESideMenu的以下属性:</h3>

<pre><code class="objc">@property (assign, readwrite, nonatomic) NSTimeInterval animationDuration;
@property (strong, readwrite, nonatomic) UIImage *backgroundImage;
@property (assign, readwrite, nonatomic) BOOL panGestureEnabled;
@property (assign, readwrite, nonatomic) BOOL panFromEdge;
@property (assign, readwrite, nonatomic) NSUInteger panMinimumOpenThreshold;
@property (assign, readwrite, nonatomic) BOOL interactivePopGestureRecognizerEnabled;
@property (assign, readwrite, nonatomic) BOOL scaleContentView;
@property (assign, readwrite, nonatomic) BOOL scaleBackgroundImageView;
@property (assign, readwrite, nonatomic) BOOL scaleMenuView;
@property (assign, readwrite, nonatomic) BOOL contentViewShadowEnabled;
@property (assign, readwrite, nonatomic) UIColor *contentViewShadowColor;
@property (assign, readwrite, nonatomic) CGSize contentViewShadowOffset;
@property (assign, readwrite, nonatomic) CGFloat contentViewShadowOpacity;
@property (assign, readwrite, nonatomic) CGFloat contentViewShadowRadius;
@property (assign, readwrite, nonatomic) CGFloat contentViewScaleValue;
@property (assign, readwrite, nonatomic) CGFloat contentViewInLandscapeOffsetCenterX;
@property (assign, readwrite, nonatomic) CGFloat contentViewInPortraitOffsetCenterX;
@property (assign, readwrite, nonatomic) CGFloat parallaxMenuMinimumRelativeValue;
@property (assign, readwrite, nonatomic) CGFloat parallaxMenuMaximumRelativeValue;
@property (assign, readwrite, nonatomic) CGFloat parallaxContentMinimumRelativeValue;
@property (assign, readwrite, nonatomic) CGFloat parallaxContentMaximumRelativeValue;
@property (assign, readwrite, nonatomic) CGAffineTransform menuViewControllerTransformation;
@property (assign, readwrite, nonatomic) BOOL parallaxEnabled;
@property (assign, readwrite, nonatomic) BOOL bouncesHorizontally;
@property (assign, readwrite, nonatomic) UIStatusBarStyle menuPreferredStatusBarStyle;
@property (assign, readwrite, nonatomic) BOOL menuPrefersStatusBarHidden;
</code></pre>

<p>如果你设置了 backgroundImage,需要同时设置背景色为 clear color,才会有效.</p>

<h3>你可以实现 RESideMenuDelegate 协议,来接收和处理以下消息:</h3>

<pre><code class="objc">- (void)sideMenu:(RESideMenu *)sideMenu didRecognizePanGesture:(UIPanGestureRecognizer *)recognizer;
- (void)sideMenu:(RESideMenu *)sideMenu willShowMenuViewController:(UIViewController *)menuViewController;
- (void)sideMenu:(RESideMenu *)sideMenu didShowMenuViewController:(UIViewController *)menuViewController;
- (void)sideMenu:(RESideMenu *)sideMenu willHideMenuViewController:(UIViewController *)menuViewController;
- (void)sideMenu:(RESideMenu *)sideMenu didHideMenuViewController:(UIViewController *)menuViewController;
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[RESideMenu 是一个有视差效果的侧边菜单.]]></excerpt:encoded>
		<wp:post_id>123</wp:post_id>
		<wp:post_date>2015-08-26 12:23:04</wp:post_date>
		<wp:post_date_gmt>2015-08-26 04:23:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>residemenu</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="residemenu"><![CDATA[RESideMenu]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_RESideMenu-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>PBJVision 快速在应用中集成相机/拍摄功能</title>
		<link>http://www.ios122.com/2015/08/pbjvision/</link>
		<pubDate>Wed, 26 Aug 2015 08:36:31 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=128</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>PBJVision, 是一个iOS相机操作的封装库,可以让你的应用快速简单地继承相机相关功能.</p>

<ul>
<li>项目主页: <a href="https://github.com/piemonte/PBJVision">PBJVision</a></li>
<li>最新示例: <a href="https://github.com/piemonte/PBJVision/archive/master.zip">点击下载</a></li>
<li>注意: 示例需要在真机上运行,保存的视频在 tmp文件夹,可通过 ifunbox等第三方工具查看.</li>
</ul>

<h2>通过 CocoaPods 安装</h2>

<pre><code class="objc">pod 'PBJVision'
</code></pre>

<h2>使用</h2>

<h3>导入头文件.</h3>

<pre><code class="objc">#import "PBJVision.h"
</code></pre>

<h3>使用 [[PBJVision sharedInstance] previewLayer] 初始化相机预览视图.</h3>

<pre><code class="objc">// 预览视图和视频图层.
_previewView = [[UIView alloc] initWithFrame:CGRectZero];
_previewView.backgroundColor = [UIColor blackColor];
CGRect previewFrame = CGRectMake(0, 60.0f, CGRectGetWidth(self.view.frame), CGRectGetWidth(self.view.frame));
_previewView.frame = previewFrame;
_previewLayer = [[PBJVision sharedInstance] previewLayer];
_previewLayer.frame = _previewView.bounds;
_previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill;
[_previewView.layer addSublayer:_previewLayer];
</code></pre>

<h3>初始化并配置PBJVision控制器,然后开始使用相机预览功能.</h3>

<pre><code class="objc">- (void)_setup
{
    _longPressGestureRecognizer.enabled = YES;

    PBJVision *vision = [PBJVision sharedInstance];
    vision.delegate = self;
    vision.cameraMode = PBJCameraModeVideo;
    vision.cameraOrientation = PBJCameraOrientationPortrait;
    vision.focusMode = PBJFocusModeContinuousAutoFocus;
    vision.outputFormat = PBJOutputFormatSquare;

    [vision startPreview];
}
</code></pre>

<h3>开始/中止/重新开始 录制.</h3>

<pre><code class="objc">- (void)_handleLongPressGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer
{
    switch (gestureRecognizer.state) {
      case UIGestureRecognizerStateBegan:
        {
            if (!_recording)
                [[PBJVision sharedInstance] startVideoCapture];
            else
                [[PBJVision sharedInstance] resumeVideoCapture];
            break;
        }
      case UIGestureRecognizerStateEnded:
      case UIGestureRecognizerStateCancelled:
      case UIGestureRecognizerStateFailed:
        {
            [[PBJVision sharedInstance] pauseVideoCapture];
            break;
        }
      default:
        break;
    }
}
</code></pre>

<h3>结束录制.</h3>

<pre><code class="objc">[[PBJVision sharedInstance] endVideoCapture];
</code></pre>

<h3>处理最终的视频输出或相应地错误.</h3>

<pre><code class="objc">- (void)vision:(PBJVision *)vision capturedVideo:(NSDictionary *)videoDict error:(NSError *)error
{   
    if (error &amp;&amp; [error.domain isEqual:PBJVisionErrorDomain] &amp;&amp; error.code == PBJVisionErrorCancelled) {
        NSLog(@"退出录制");
        return;
    } else if (error) {
        NSLog(@"视频录制时发生错误 (%@)", error);
        return;
    }

    _currentVideo = videoDict;

    NSString *videoPath = [_currentVideo  objectForKey:PBJVisionVideoPathKey];
    [_assetLibrary writeVideoAtPathToSavedPhotosAlbum:[NSURL URLWithString:videoPath] completionBlock:^(NSURL *assetURL, NSError *error1) {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle: @"视频已保存!" message: @"保存到缓存目录tmp中."
                                                       delegate:self
                                              cancelButtonTitle:nil
                                              otherButtonTitles:@"好", nil];
        [alert show];
    }];
}
</code></pre>

<h3>设置 <code>PBJVision</code> 控制器的属性可以设置最大视频录制时间:</h3>

<pre><code class="objc">[[PBJVision sharedInstance] setMaximumCaptureDuration:CMTimeMakeWithSeconds(5, 600)]; // 最多5秒.
可以通过  PBJVision 控制器的属性来设置视频的质量和压缩比特率.

@property (nonatomic, copy) NSString *captureSessionPreset;

@property (nonatomic) CGFloat videoBitRate;
@property (nonatomic) NSInteger audioBitRate;
@property (nonatomic) NSDictionary *additionalCompressionProperties;
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[PBJVision, 是一个iOS相机操作的封装库,可以让你的应用快速简单地继承相机相关功能.]]></excerpt:encoded>
		<wp:post_id>128</wp:post_id>
		<wp:post_date>2015-08-26 16:36:31</wp:post_date>
		<wp:post_date_gmt>2015-08-26 08:36:31</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>pbjvision</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="pbjvision"><![CDATA[PBJvision]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_05fd8265fc0028be0d7713be667959f4</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Aspects-- iOS的AOP面向切面编程的库</title>
		<link>http://www.ios122.com/2015/08/aspects/</link>
		<pubDate>Thu, 27 Aug 2015 04:13:56 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=141</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>一个简洁高效的用于使iOS支持AOP面向切面编程的库.它可以帮助你在不改变一个类或类实例的代码的前提下,有效更改类的行为.比iOS传统的 AOP方法,更加简单高效.支持在方法执行的前/后或替代原方法执行.曾经是 <a href="http://pspdfkit.com/">PSPDFKit</a> 的一部分,PSPDFKit,在Dropbox和Evernote中都有应用,现在单独单独开源出来给大家使用.</p>

<ul>
<li>项目主页: <a href="https://github.com/steipete/Aspects">Aspects</a></li>
<li>最新实例: <a href="https://github.com/steipete/Aspects/archive/master.zip">点击下载</a></li>
<li>注: AOP是一种完全不同于OOP的设计模式.更多信息,可以参考这里: <a href="http://baike.baidu.com/link?url=PIeqeQcKvvIRAJBcWnLj2OCtx0T6HSr8ylVKMOl9RNYUsMawbZMnFou27wmIEHUO_uKckKtKaE05vz1jbBmBuTAdo99FySgLPbwSYQgqquq">AOP 百度百科</a></li>
</ul>

<h2>系统要求</h2>

<ul>
<li>ARC</li>
<li>iOS 7 + 或 OS X 10.7 +</li>
</ul>

<h2>安装</h2>

<h3>使用 CocoaPods 安装</h3>

<pre><code class="ruby">pod "Aspects"
</code></pre>

<h3>手动安装</h3>

<p>把文件 Aspects.h/m 拖到工程中即可.</p>

<h2>用法</h2>

<h3>应用场景</h3>

<p>Aspects 用于支持AOP(面向切面编程)模式,用于部分解决OOP(面向对象)模式无法解决的特定问题.具体指的是那些在多个方法有交叉,无法或很难被有效归类的操作,比如:</p>

<ul>
<li>不论何时用户通过客户端获取服务器端数据,权限检查总是必须的.</li>
<li>不论何时用户和市场交互,总应该更具用户的操作提供相应地购买参考或相关商品.</li>
<li>所有需要日志记录的操作.</li>
</ul>

<h3>接口概述</h3>

<p>Aspects 给 NSObject 扩展了下面的方法:</p>

<pre><code class="objc">/// 为一个指定的类的某个方法执行前/替换/后,添加一段代码块.对这个类的所有对象都会起作用.
///
/// @param block  方法被添加钩子时,Aspectes会拷贝方法的签名信息.
/// 第一个参数将会是 `id&lt;AspectInfo&gt;`,余下的参数是此被调用的方法的参数.
/// 这些参数是可选的,并将被用于传递给block代码块对应位置的参数.
/// 你甚至使用一个没有任何参数或只有一个`id&lt;AspectInfo&gt;`参数的block代码块.
///
/// @注意 不支持给静态方法添加钩子.
/// @return 返回一个唯一值,用于取消此钩子.
+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector
                      withOptions:(AspectOptions)options
                       usingBlock:(id)block
                            error:(NSError **)error;

/// 为一个指定的对象的某个方法执行前/替换/后,添加一段代码块.只作用于当前对象.
 - (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 
/// 撤销一个Aspect 钩子.
/// @return YES 撤销成功, 否则返回 NO. 
id&lt;AspectToken&gt; aspect = ...; 
[aspect remove];
</code></pre>

<p>所有的调用,都会是线程安全的.Aspects 使用了Objective-C 的消息转发机会,会有一定的性能消耗.所有对于过于频繁的调用,不建议使用 Aspects.Aspects更适用于视图/控制器相关的等每秒调用不超过1000次的代码.</p>

<h2>代码示例</h2>

<h3>可以在调试应用时,使用Aspects动态添加日志记录功能.</h3>

<pre><code class="objc">[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) {
    NSLog(@"控制器 %@ 将要显示: %tu", aspectInfo.instance, animated);
} error:NULL];
</code></pre>

<h3>使用它,分析功能的设置会很简单:</h3>

<p><a href="https://github.com/orta/ARAnalytics">https://github.com/orta/ARAnalytics</a></p>

<h3>你可以在你的测试用例中用它来检查某个方法是否被真正调用(当涉及到继承或类目扩展时,很容易发生某个父类/子类方法未按预期调用的情况):</h3>

<pre><code class="objc">- (void)testExample {
    TestClass *testClass = [TestClass new];
    TestClass *testClass2 = [TestClass new];

    __block BOOL testCallCalled = NO;
    [testClass aspect_hookSelector:@selector(testCall) withOptions:AspectPositionAfter usingBlock:^{
        testCallCalled = YES;
    } error:NULL];

    [testClass2 testCallAndExecuteBlock:^{
        [testClass testCall];
    } error:NULL];
    XCTAssertTrue(testCallCalled, @"调用testCallAndExecuteBlock 必须调用 testCall");
}
</code></pre>

<h3>它对调试应用真的会提供很大的作用.这里我想要知道究竟何时轻击手势的状态发生变化(如果是某个你自定义的手势的子类,你可以重写setState:方法来达到类似的效果;但这里的真正目的是,捕捉所有的各类控件的轻击手势,以准确分析原因):</h3>

<pre><code class="objc">[_singleTapGesture aspect_hookSelector:@selector(setState:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) {
    NSLog(@"%@: %@", aspectInfo.instance, aspectInfo.arguments);
} error:NULL];
</code></pre>

<h3>下面是一个你监测一个模态显示的控制器何时消失的示例.通常,你也可以写一个子类,来实现相似的效果,但使用 Aspects 可以有效减小你的代码量:</h3>

<pre><code class="objc">@implementation UIViewController (DismissActionHook)

// Will add a dismiss action once the controller gets dismissed.
- (void)pspdf_addWillDismissAction:(void (^)(void))action {
    PSPDFAssert(action != NULL);

    [self aspect_hookSelector:@selector(viewWillDisappear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) {
        if ([aspectInfo.instance isBeingDismissed]) {
            action();
        }
    } error:NULL];
}

@end
</code></pre>

<h2>对调试的好处</h2>

<p>Aspectes 会自动标记自己,所有很容易在调用栈中查看某个方法是否已经调用:</p>

<p><img src="https://raw.githubusercontent.com/steipete/Aspects/master/stacktrace@2x.png?token=58493__eyJzY29wZSI6IlJhd0Jsb2I6c3RlaXBldGUvQXNwZWN0cy9tYXN0ZXIvc3RhY2t0cmFjZUAyeC5wbmciLCJleHBpcmVzIjoxMzk5NzQ3OTI3fQ%3D%3D--97cf7e7bac491149eb8db3d1b9a562ab88154a3c" alt="调试效果图" /></p>

<p>在返回值不为void的方法上使用 Aspects</p>

<p>你可以使用 NSInvocation 对象类自定义返回值:</p>

<pre><code class="objc">[PSPDFDrawView aspect_hookSelector:@selector(shouldProcessTouches:withEvent:) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; info, NSSet *touches, UIEvent *event) {
    // 调用方法原来的实现.
    BOOL processTouches;
    NSInvocation *invocation = info.originalInvocation;
    [invocation invoke];
    [invocation getReturnValue:&amp;processTouches];

    if (processTouches) {
        processTouches = pspdf_stylusShouldProcessTouches(touches, event);
        [invocation setReturnValue:&amp;processTouches];
    }
} error:NULL];
</code></pre>

<h2>兼容性与限制</h2>

<ul>
<li>当应用于某个类时(使用类方法添加钩子),不能同时hook父类和子类的同一个方法;否则会引起循环调用问题.但是,当应用于某个类的示例时(使用实例方法添加钩子),不受此限制.</li>
<li>使用KVO时,最好在 aspect_hookSelector: 调用之后添加观察者;否则可能会引起崩溃.</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[一个简洁高效的用于使iOS支持AOP面向切面编程的库.它可以帮助你在不改变一个类或类实例的代码的前提下,有效更改类的行为.比iOS传统的 AOP方法,更加简单高效.支持在方法执行的前/后或替代原方法执行.曾经是 [PSPDFKit](http://pspdfkit.com/) 的一部分,PSPDFKit,在Dropbox和Evernote中都有应用,现在单独单独开源出来给大家使用.]]></excerpt:encoded>
		<wp:post_id>141</wp:post_id>
		<wp:post_date>2015-08-27 12:13:56</wp:post_date>
		<wp:post_date_gmt>2015-08-27 04:13:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>aspects</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="aspects"><![CDATA[Aspects]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_Aspects-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>VCTransitionsLibrary --自定义iOS交互式转场动画的库</title>
		<link>http://www.ios122.com/2015/08/vctransitionslibrary/</link>
		<pubDate>Thu, 27 Aug 2015 09:46:06 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=149</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<p>VCTransitionsLibrary 提供了许多适用于入栈,出栈,模态等场景下控制器切换时的转场动画.它本身提供了一个定义好的转场动画库,你可以拖到自己工程中直接使用;也提供了许多拥有不同转场动画效果”互动控制器”,你可以直接使用这些控制器来和自定义动画效果配合使用;而不是自己控制去控制交互.</p>

<ul>
<li>项目主页: <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary">VCTransitionsLibrary</a></li>
<li>最新示例: <a href="https://github.com/ColinEberhardt/VCTransitionsLibrary/archive/master.zip">点击下载</a></li>
<li>注意: 自定义视图控制器的转场动画为iOS7 + 通过 UIViewControllerTransitioningDelegate协议, UINavigationControllerDelegate协议和 UITabBarControllerDelegate 协议提供的系统级别的支持.这个库的意义在于定义了常用的动画效果,并封装了常用的交互操作,简化了iOS交互式转场动画的编码量!</li>
</ul>

<h2>系统要求</h2>

<ul>
<li>iOS 7+</li>
<li>ARC</li>
</ul>

<h2>安装</h2>

<h3>使用 CocoaPods 安装</h3>

<pre><code class="objc">pod "VCTransitionsLibrary"
</code></pre>

<h3>手动安装</h3>

<p>把文件 AnimationControllers 和 InteractionControllers 文件夹下所有代码复制到工程中即可.</p>

<h2>使用</h2>

<p>在自定义转场动画时,有两类关键的类:</p>

<ul>
<li><strong>动画控制器</strong> –  这个类是用来实现自定义动画的.但你声明想要使用自定义动画时,你应该提供一个动画控制器.这个类会实现需要的动画,完成时会通知框架.</li>
<li><strong>交互控制器</strong> – 这个类是用来管理交互的-那些通常由某个手势空控制的交互,允许用户通过滑动,轻扫或执行其他操作来实现两个视图控制器的导航.必须指出的是,交互控制器允许导航取消,例如,一个用户可以在正在导航至某一页面时,突然改变主意,然后取消了操作.</li>
</ul>

<p>注意: 动画和交互是完全独立的,这意味着你可以在其他任何自定义控制器上独立使用交互控制器-很酷!</p>

<h3>使用动画控制器</h3>

<p>AnimationControllers 文件夹中提供了许多可以整合进你的工程中的动画控制器:</p>

<h4>自定义模态控制器显示/隐藏的动画</h4>

<p>UIViewControllerTransitioningDelegate 协议被用来在模态控制器显示/隐藏时提供一个动画控制器.当一个视图控制器被模态显示或隐藏时,它的transitioningDelegate属性用来提供UIViewControllerTransitioningDelegate协议的支持.担当代理角色的类,通过 animationControllerForPresentedController: presentingController: sourceController: 方法返回模态显示时的动画, 通过 animationControllerForDismissedController: 返回模态消失时的动画即可.</p>

<h4>自定义顶部导航的转场动画</h4>

<p>UINavigationController 有一个</p>

<p>id<UINavigationControllerDelegate> delegate 属性.只需要让它的代理通过 navigationController: animationControllerForOperation: fromViewController: toViewController: 返回某个动画效果即可.</p>

<p>为了同时设置出栈/入栈都合适的动画效果(或者说,出栈/入栈时能使用相反方向的动画),你可以参考下面代码:</p>

<pre><code class="objc">-(id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:
                                (UINavigationController *)navigationController
   animationControllerForOperation:(UINavigationControllerOperation)operation
                fromViewController:(UIViewController *)fromVC
                  toViewController:(UIViewController *)toVC {

    // 出栈时,要反转动画方向.
    _animationController.reverse = operation == UINavigationControllerOperationPop;

    return _animationController;
}
</code></pre>

<h4>自定义底部标签栏导航的转场动画</h4>

<p>UITabBarController 有一个 id<UITabBarControllerDelegate> delegate属性,只需要让它的代理通过tabBarController: animationControllerForTransitionFromViewController: toViewController:返回某个动画效果即可.</p>

<p>为了给动画一个合适的方向,你可以比较两个视图控制器的索引:</p>

<pre><code class="objc">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController
            animationControllerForTransitionFromViewController:(UIViewController *)fromVC
                                              toViewController:(UIViewController *)toVC {

    NSUInteger fromVCIndex = [tabBarController.viewControllers indexOfObject:fromVC];
    NSUInteger toVCIndex = [tabBarController.viewControllers indexOfObject:toVC];

    _animationController.reverse = fromVCIndex &lt; toVCIndex;
    return _animationController;
}
</code></pre>

<h3>使用交互控制器</h3>

<p>交互控制器和动画控制器配合使用,可以实现交互式的动画转场效果,比如可以让用户通过手势来控制页面间的导航.交互控制器允许用户在一个转场动画中前进,后退,甚至退出.</p>

<p>交互控制器负责给视图添加手势,并负责在用户使用某个手势时进行相应地导航操作.</p>

<h4>模态控制器消失时的交互</h4>

<p>UIViewControllerTransitioningDelegate 协议,也用来提供对交互式转场的支持.下面是一个结合清扫手势和翻页动画的例子:</p>

<pre><code class="objc">//实例变量,通常在你的初始化方法初始化它们
CEFlipAnimationController *_animationController;
CESwipeInteractionController *_interactionController;

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
      animationControllerForPresentedController:(UIViewController *)presented
                           presentingController:(UIViewController *)presenting
                               sourceController:(UIViewController *)source {

    // 允许交互控制器绑定它的手势识别器.
    [_interactionController wireToViewController:presented 
                                    forOperation:CEInteractionOperationDismiss];
       _animationController.reverse = NO;
    return _animationController;
}

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
     animationControllerForDismissedController:(UIViewController *)dismissed {
    _animationController.reverse = YES;
    return _animationController;
}

- (id&lt;UIViewControllerInteractiveTransitioning&gt;)
           interactionControllerForDismissal:
                (id&lt;UIViewControllerAnimatedTransitioning&gt;)animator {

    // 如果有交互控制器被触发了,就直接使用它.返回nil,是为了支持用户通过点击某个按钮直接返回;此时不会触发交互控制器.
    return _interactionController.interactionInProgress
                ? _interactionController : nil;
}
</code></pre>

<h4>出栈时的交互</h4>

<p>UINavigationControllerDelegate 也有方法为交互式转场提供支持.一个典型的类似于上上面代码的模式:</p>

<pre><code class="objc">// 实例变量,通常在你的初始化方法中初始化它们.
CEFlipAnimationController *_animationController;
CESwipeInteractionController *_interactionController;

- (id&lt;UIViewControllerAnimatedTransitioning&gt;)
                 navigationController:(UINavigationController *)navigationController
      animationControllerForOperation:(UINavigationControllerOperation)operation
                   fromViewController:(UIViewController *)fromVC
                     toViewController:(UIViewController *)toVC {

    // 把交互控制器绑定到你的视图控制器上.
    [_interactionController wireToViewController:toVC
                                    forOperation:CEInteractionOperationPop];

    _animationController.reverse = operation == UINavigationControllerOperationPop;

    return _animationController;
}

- (id &lt;UIViewControllerInteractiveTransitioning&gt;)
                         navigationController:(UINavigationController *)navigationController 
  interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController {

    //如果有交互控制器被触发了,就直接使用它.返回nil,是为了支持用户通过点击某个按钮直接返回;此时不会触发交互控制器. 
    return _interactionController.interactionInProgress
                ? _interactionController : nil;
}
</code></pre>

<h4>用于标签栏控制器切换时的交互</h4>

<p>UITabBarControllerDelegate 协议也为交互式转场提供了支持.但是由于代理方法在首次初始化时不被执行,所有需要其他方式来绑定交互控制器,如KVO:</p>

<pre><code class="objc">@implementation TabBarViewController {
    CEFoldAnimationController *_animationController;
    CESwipeInteractionController *_swipeInteractionController;
}

- (id)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super initWithCoder:aDecoder]) {
        self.delegate = self;

        // 创建交互/动画控制器.
        _swipeInteractionController = [CESwipeInteractionController new];
        _animationController = [CEFoldAnimationController new];
        _animationController.folds = 3;

        // 使用观察者模式监测被选中的选择器的变化情况.
        [self addObserver:self
               forKeyPath:@"selectedViewController"
                  options:NSKeyValueObservingOptionNew
                  context:nil];
    }
    return self;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context
{
    if ([keyPath isEqualToString:@"selectedViewController"] )
    {
        // 把交互控制器绑定到视图控制器上.
        [_swipeInteractionController wireToViewController:self.selectedViewController
                                             forOperation:CEInteractionOperationTab];
    }
}



- (id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController
            animationControllerForTransitionFromViewController:(UIViewController *)fromVC
            toViewController:(UIViewController *)toVC {

    NSUInteger fromVCIndex = [tabBarController.viewControllers indexOfObject:fromVC];
    NSUInteger toVCIndex = [tabBarController.viewControllers indexOfObject:toVC];

    _animationController.reverse = fromVCIndex &lt; toVCIndex;
    return _animationController;
}

-(id&lt;UIViewControllerInteractiveTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController
{
    return _swipeInteractionController.interactionInProgress ? _swipeInteractionController : nil;
}

@end
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[VCTransitionsLibrary 提供了许多适用于入栈,出栈,模态等场景下控制器切换时的转场动画.它本身提供了一个定义好的转场动画库,你可以拖到自己工程中直接使用;也提供了许多拥有不同转场动画效果”互动控制器”,你可以直接使用这些控制器来和自定义动画效果配合使用;而不是自己控制去控制交互.]]></excerpt:encoded>
		<wp:post_id>149</wp:post_id>
		<wp:post_date>2015-08-27 17:46:06</wp:post_date>
		<wp:post_date_gmt>2015-08-27 09:46:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>vctransitionslibrary</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="vctransitionslibrary"><![CDATA[VCTransitionsLibrary]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-fullres</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-1080</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-720</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-mobile</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-vp9</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-custom_h264</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-custom_webm</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_kgflashmediaplayer-singleurl_VCTransitionsLibrary-custom_ogg</wp:meta_key>
			<wp:meta_value><![CDATA[not found]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>MJRefresh--用法最简单的下拉刷新框架</title>
		<link>http://www.ios122.com/2015/08/mjrefresh/</link>
		<pubDate>Sun, 30 Aug 2015 19:02:57 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=203</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="http://images.cnitblog.com/blog2015/497279/201505/051004492043385.png" alt="(logo)" /></p>

<h2>MJRefresh</h2>

<ul>
<li>An easy way to use pull-to-refresh</li>
<li>用法最简单的下拉刷新框架：一行代码搞定</li>
</ul>

<h2>Contents</h2>

<ul>
<li>Getting Started

<ul>
<li><a href="#支持哪些控件的刷新">Features【支持哪些控件的刷新】</a></li>
<li><a href="#如何使用MJRefresh">Installation【如何使用MJRefresh】</a></li>
<li><a href="#已经超过上百个App正在使用MJRefresh">Who's using【已经超过上百个App正在使用MJRefresh】</a></li>
<li><a href="#MJRefresh类结构图">Classes【MJRefresh类结构图】</a></li>
</ul></li>
<li>常见API

<ul>
<li><a href="#MJRefreshComponent.h">MJRefreshComponent.h</a></li>
<li><a href="#MJRefreshHeader.h">MJRefreshHeader.h</a></li>
<li><a href="#MJRefreshFooter.h">MJRefreshFooter.h</a></li>
<li><a href="#MJRefreshAutoFooter.h">MJRefreshAutoFooter.h</a></li>
</ul></li>
<li>Examples

<ul>
<li><a href="#参考">Reference【参考】</a></li>
<li><a href="#下拉刷新01-默认">下拉刷新01-默认</a></li>
<li><a href="#下拉刷新02-动画图片">下拉刷新02-动画图片</a></li>
<li><a href="#下拉刷新03-隐藏时间">下拉刷新03-隐藏时间</a></li>
<li><a href="#下拉刷新04-隐藏状态和时间">下拉刷新04-隐藏状态和时间</a></li>
<li><a href="#下拉刷新05-自定义文字">下拉刷新05-自定义文字</a></li>
<li><a href="#下拉刷新06-自定义刷新控件">下拉刷新06-自定义刷新控件</a></li>
<li><a href="#上拉刷新01-默认">上拉刷新01-默认</a></li>
<li><a href="#上拉刷新02-动画图片">上拉刷新02-动画图片</a></li>
<li><a href="#上拉刷新03-隐藏刷新状态的文字">上拉刷新03-隐藏刷新状态的文字</a></li>
<li><a href="#上拉刷新04-全部加载完毕">上拉刷新04-全部加载完毕</a></li>
<li><a href="#上拉刷新05-自定义文字">上拉刷新05-自定义文字</a></li>
<li><a href="#上拉刷新06-加载后隐藏">上拉刷新06-加载后隐藏</a></li>
<li><a href="#上拉刷新07-自动回弹的上拉01">上拉刷新07-自动回弹的上拉01</a></li>
<li><a href="#上拉刷新08-自动回弹的上拉02">上拉刷新08-自动回弹的上拉02</a></li>
<li><a href="#上拉刷新09-自定义刷新控件(自动刷新)">上拉刷新09-自定义刷新控件(自动刷新)</a></li>
<li><a href="#上拉刷新10-自定义刷新控件(自动回弹)">上拉刷新10-自定义刷新控件(自动回弹)</a></li>
<li><a href="#UICollectionView01-上下拉刷新">UICollectionView01-上下拉刷新</a></li>
<li><a href="#UIWebView01-下拉刷新">UIWebView01-下拉刷新</a></li>
</ul></li>
<li><a href="#期待">期待</a></li>
</ul>

<h2><a id="支持哪些控件的刷新"></a>支持哪些控件的刷新</h2>

<ul>
<li><code>UIScrollView</code>、<code>UITableView</code>、<code>UICollectionView</code>、<code>UIWebView</code></li>
</ul>

<h2><a id="如何使用MJRefresh"></a>如何使用MJRefresh</h2>

<ul>
<li>cocoapods导入：<code>pod 'MJRefresh'</code></li>
<li>手动导入：

<ul>
<li>将<code>MJRefresh</code>文件夹中的所有文件拽入项目中</li>
<li>导入主头文件：<code>#import "MJRefresh.h"</code></li>
</ul></li>
</ul>

<pre><code class="objc">Base                        Custom
MJRefresh.bundle            MJRefresh.h
MJRefreshConst.h            MJRefreshConst.m
UIScrollView+MJExtension.h  UIScrollView+MJExtension.m
UIScrollView+MJRefresh.h    UIScrollView+MJRefresh.m
UIView+MJExtension.h        UIView+MJExtension.m
</code></pre>

<h2><a id="已经超过上百个App正在使用MJRefresh"></a>已经超过上百个App正在使用MJRefresh</h2>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141212365041650.png" width="200" height="300">
* 更多App信息可以关注：<a href="http://www.cnblogs.com/mjios/p/4409853.html">M了个J-博客园</a></p>

<h2><a id="MJRefresh类结构图"></a>MJRefresh类结构图</h2>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/132232456139177.png" alt="" />
- 图中<code>红色文字的类</code>：可以直接拿来用
    - 下拉刷新控件的种类
        - 默认（Normal）：<code>MJRefreshNormalHeader</code>
        - 动图（Gif）：<code>MJRefreshGifHeader</code>
    - 上拉刷新控件的种类
        - 自动刷新（Auto）
            - 默认（Normal）：<code>MJRefreshAutoNormalFooter</code>
            - 动图（Gif）：<code>MJRefreshAutoGifFooter</code>
        - 自动回弹（Back）
            - 默认（Normal）：<code>MJRefreshBackNormalFooter</code>
            - 动图（Gif）：<code>MJRefreshBackGifFooter</code>
- 图中<code>非红色文字的类</code>：拿来继承，用于自定义刷新控件
- 关于如何自定义刷新控件，可以参考下图的类<br>
<img src="http://images0.cnblogs.com/blog2015/497279/201506/141358159107893.png" width="30%" height="30%"></p>

<h2><a id="MJRefreshComponent.h"></a>MJRefreshComponent.h</h2>

<pre><code class="objc">/** 刷新控件的基类 */
@interface MJRefreshComponent : UIView
#pragma mark - 刷新状态控制
/** 进入刷新状态 */
- (void)beginRefreshing;
/** 结束刷新状态 */
- (void)endRefreshing;
/** 是否正在刷新 */
- (BOOL)isRefreshing;

#pragma mark - 其他
/** 根据拖拽比例自动切换透明度 */
@property (assign, nonatomic, getter=isAutomaticallyChangeAlpha) BOOL automaticallyChangeAlpha;
@end
</code></pre>

<h2><a id="MJRefreshHeader.h"></a>MJRefreshHeader.h</h2>

<pre><code class="objc">@interface MJRefreshHeader : MJRefreshComponent
/** 创建header */
+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;
/** 创建header */
+ (instancetype)headerWithRefreshingTarget:(id)target refreshingAction:(SEL)action;

/** 这个key用来存储上一次下拉刷新成功的时间 */
@property (copy, nonatomic) NSString *lastUpdatedTimeKey;
/** 上一次下拉刷新成功的时间 */
@property (strong, nonatomic, readonly) NSDate *lastUpdatedTime;

/** 忽略多少scrollView的contentInset的top */
@property (assign, nonatomic) CGFloat ignoredScrollViewContentInsetTop;
@end
</code></pre>

<h2><a id="MJRefreshFooter.h"></a>MJRefreshFooter.h</h2>

<pre><code class="objc">@interface MJRefreshFooter : MJRefreshComponent
/** 创建footer */
+ (instancetype)footerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;
/** 创建footer */
+ (instancetype)footerWithRefreshingTarget:(id)target refreshingAction:(SEL)action;

/** 提示没有更多的数据 */
- (void)noticeNoMoreData;
/** 重置没有更多的数据（消除没有更多数据的状态） */
- (void)resetNoMoreData;

/** 忽略多少scrollView的contentInset的bottom */
@property (assign, nonatomic) CGFloat ignoredScrollViewContentInsetBottom;

/** 自动根据有无数据来显示和隐藏（有数据就显示，没有数据隐藏） */
@property (assign, nonatomic) BOOL automaticallyHidden;
@end
</code></pre>

<h2><a id="MJRefreshAutoFooter.h"></a>MJRefreshAutoFooter.h</h2>

<pre><code class="objc">@interface MJRefreshAutoFooter : MJRefreshFooter
/** 是否自动刷新(默认为YES) */
@property (assign, nonatomic, getter=isAutomaticallyRefresh) BOOL automaticallyRefresh;

/** 当底部控件出现多少时就自动刷新(默认为1.0，也就是底部控件完全出现时，才会自动刷新) */
@property (assign, nonatomic) CGFloat triggerAutomaticallyRefreshPercent;
@end
</code></pre>

<h2><a id="参考"></a>参考</h2>

<pre><code class="objc">* 由于这个框架的功能较多，就不写具体文字描述其用法
* 大家可以直接参考示例中的MJTableViewController、MJCollectionViewController、MJWebViewController，更为直观快速
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141345470048120.png" width="30%" height="30%"></p>

<h2><a id="下拉刷新01-默认"></a>下拉刷新01-默认</h2>

<pre><code class="objc">self.tableView.header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
   // 进入刷新状态后会自动调用这个block
}];
或
// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadNewData方法）
self.tableView.header = [MJRefreshNormalHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];

// 马上进入刷新状态
[self.tableView.header beginRefreshing];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141204343486151.gif" alt="(下拉刷新01-普通)" /></p>

<h2><a id="下拉刷新02-动画图片"></a>下拉刷新02-动画图片</h2>

<pre><code class="objc">// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadNewData方法）
MJRefreshGifHeader *header = [MJRefreshGifHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];
// 设置普通状态的动画图片
[header setImages:idleImages forState:MJRefreshStateIdle];
// 设置即将刷新状态的动画图片（一松开就会刷新的状态）
[header setImages:pullingImages forState:MJRefreshStatePulling];
// 设置正在刷新状态的动画图片
[header setImages:refreshingImages forState:MJRefreshStateRefreshing];
// 设置header
self.tableView.header = header;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141204402238389.gif" alt="(下拉刷新02-动画图片)" /></p>

<h2><a id="下拉刷新03-隐藏时间"></a>下拉刷新03-隐藏时间</h2>

<pre><code class="objc">// 隐藏时间
header.lastUpdatedTimeLabel.hidden = YES;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141204456132944.gif" alt="(下拉刷新03-隐藏时间)" /></p>

<h2><a id="下拉刷新04-隐藏状态和时间"></a>下拉刷新04-隐藏状态和时间</h2>

<pre><code class="objc">// 隐藏时间
header.lastUpdatedTimeLabel.hidden = YES;

// 隐藏状态
header.stateLabel.hidden = YES;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141204508639539.gif" alt="(下拉刷新04-隐藏状态和时间0)" /></p>

<h2><a id="下拉刷新05-自定义文字"></a>下拉刷新05-自定义文字</h2>

<pre><code class="objc">// 设置文字
[header setTitle:@"Pull down to refresh" forState:MJRefreshStateIdle];
[header setTitle:@"Release to refresh" forState:MJRefreshStatePulling];
[header setTitle:@"Loading ..." forState:MJRefreshStateRefreshing];

// 设置字体
header.stateLabel.font = [UIFont systemFontOfSize:15];
header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:14];

// 设置颜色
header.stateLabel.textColor = [UIColor redColor];
header.lastUpdatedTimeLabel.textColor = [UIColor blueColor];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141204563633593.gif" alt="(下拉刷新05-自定义文字)" /></p>

<h2><a id="下拉刷新06-自定义刷新控件"></a>下拉刷新06-自定义刷新控件</h2>

<pre><code class="objc">self.tableView.header = [MJDIYHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];
// 具体实现参考MJDIYHeader.h和MJDIYHeader.m
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205019261159.gif" alt="(下拉刷新06-自定义刷新控件)" /></p>

<h2><a id="上拉刷新01-默认"></a>上拉刷新01-默认</h2>

<pre><code class="objc">self.tableView.footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
   // 进入刷新状态后会自动调用这个block
}];
或
// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadMoreData方法）
self.tableView.footer = [MJRefreshAutoNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205090047696.gif" alt="(上拉刷新01-默认)" /></p>

<h2><a id="上拉刷新02-动画图片"></a>上拉刷新02-动画图片</h2>

<pre><code class="objc">// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用self的loadMoreData方法）
MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];

// 设置刷新图片
[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];

// 设置尾部
self.tableView.footer = footer;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205141445793.gif" alt="(上拉刷新02-动画图片)" /></p>

<h2><a id="上拉刷新03-隐藏刷新状态的文字"></a>上拉刷新03-隐藏刷新状态的文字</h2>

<pre><code class="objc">// 隐藏刷新状态的文字
footer.refreshingTitleHidden = YES;
// 如果没有上面的方法，就用footer.stateLabel.hidden = YES;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205200985774.gif" alt="(上拉刷新03-隐藏刷新状态的文字)" /></p>

<h2><a id="上拉刷新04-全部加载完毕"></a>上拉刷新04-全部加载完毕</h2>

<pre><code class="objc">// 变为没有更多数据的状态
[footer noticeNoMoreData];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205248634686.gif" alt="(上拉刷新04-全部加载完毕)" /></p>

<h2><a id="上拉刷新05-自定义文字"></a>上拉刷新05-自定义文字</h2>

<pre><code class="objc">// 设置文字
[footer setTitle:@"Click or drag up to refresh" forState:MJRefreshStateIdle];
[footer setTitle:@"Loading more ..." forState:MJRefreshStateRefreshing];
[footer setTitle:@"No more data" forState:MJRefreshStateNoMoreData];

// 设置字体
footer.stateLabel.font = [UIFont systemFontOfSize:17];

// 设置颜色
footer.stateLabel.textColor = [UIColor blueColor];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205295511153.gif" alt="(上拉刷新05-自定义文字)" /></p>

<h2><a id="上拉刷新06-加载后隐藏"></a>上拉刷新06-加载后隐藏</h2>

<pre><code class="objc">// 隐藏当前的上拉刷新控件
self.tableView.footer.hidden = YES;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205343481821.gif" alt="(上拉刷新06-加载后隐藏)" /></p>

<h2><a id="上拉刷新07-自动回弹的上拉01"></a>上拉刷新07-自动回弹的上拉01</h2>

<pre><code class="objc">self.tableView.footer = [MJRefreshBackNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205392239231.gif" alt="(上拉刷新07-自动回弹的上拉01)" /></p>

<h2><a id="上拉刷新08-自动回弹的上拉02"></a>上拉刷新08-自动回弹的上拉02</h2>

<pre><code class="objc">MJRefreshBackGifFooter *footer = [MJRefreshBackGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];

// 设置普通状态的动画图片
[footer setImages:idleImages forState:MJRefreshStateIdle];
// 设置即将刷新状态的动画图片（一松开就会刷新的状态）
[footer setImages:pullingImages forState:MJRefreshStatePulling];
// 设置正在刷新状态的动画图片
[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];

// 设置尾部
self.tableView.footer = footer;
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205441443628.gif" alt="(上拉刷新07-自动回弹的上拉02)" /></p>

<h2><a id="上拉刷新09-自定义刷新控件(自动刷新)"></a>上拉刷新09-自定义刷新控件(自动刷新)</h2>

<pre><code class="objc">self.tableView.footer = [MJDIYAutoFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];
// 具体实现参考MJDIYAutoFooter.h和MJDIYAutoFooter.m
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205500195866.gif" alt="(上拉刷新09-自定义刷新控件(自动刷新))" /></p>

<h2><a id="上拉刷新10-自定义刷新控件(自动回弹)"></a>上拉刷新10-自定义刷新控件(自动回弹)</h2>

<pre><code class="objc">self.tableView.footer = [MJDIYBackFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];
// 具体实现参考MJDIYBackFooter.h和MJDIYBackFooter.m
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141205560666819.gif" alt="(上拉刷新10-自定义刷新控件(自动回弹))" /></p>

<h2><a id="UICollectionView01-上下拉刷新"></a>UICollectionView01-上下拉刷新</h2>

<pre><code class="objc">// 下拉刷新
self.collectionView.header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
   // 进入刷新状态后会自动调用这个block
}];

// 上拉刷新
self.collectionView.footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^{
   // 进入刷新状态后会自动调用这个block
}];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141206021603758.gif" alt="(UICollectionView01-上下拉刷新)" /></p>

<h2><a id="UIWebView01-下拉刷新"></a>UIWebView01-下拉刷新</h2>

<pre><code class="objc">// 添加下拉刷新控件
self.webView.scrollView.header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
   // 进入刷新状态后会自动调用这个block
}];
</code></pre>

<p><img src="http://images0.cnblogs.com/blog2015/497279/201506/141206080514524.gif" alt="(UICollectionView01-上下拉刷新)" /></p>

<h2>提醒</h2>

<ul>
<li>本框架纯ARC，兼容的系统>=iOS6.0、iPhone\iPad横竖屏</li>
</ul>

<h2><a id="期待"></a>期待</h2>

<ul>
<li>如果在使用过程中遇到BUG，希望你能Issues我，谢谢（或者尝试下载最新的框架代码看看BUG修复没有）</li>
<li>如果在使用过程中发现功能不够用，希望你能Issues我，我非常想为这个框架增加更多好用的功能，谢谢</li>
<li>如果你想为MJRefresh输出代码，请拼命Pull Requests我</li>
<li>一起携手打造天朝乃至世界最好用的刷新框架，做天朝程序员的骄傲</li>
<li>如果你开发的应用中用到了MJRefresh，希望你能到<a href="https://www.cocoacontrols.com/controls/mjrefresh">CocoaControls</a>添加你应用的iTunes路径，我将会安装使用你的应用，并且根据众多应用的使用情况，对MJRefresh进行一个更好的设计和完善，提供更多好用的功能，谢谢

<ul>
<li>步骤01（微信是举个例子，百度“你的应用名称 itunes”）
<img src="http://ww4.sinaimg.cn/mw1024/800cdf9ctw1eq0viiv5rsj20sm0ea41t.jpg" alt="(step01)" /></li>
<li>步骤02
<img src="http://ww2.sinaimg.cn/mw1024/800cdf9ctw1eq0vilejxlj20tu0me7a0.jpg" alt="(step02)" /></li>
<li>步骤03
<img src="http://ww1.sinaimg.cn/mw1024/800cdf9ctw1eq0viocpo5j20wc0dc0un.jpg" alt="(step03)" /></li>
<li>步骤04
<img src="http://ww3.sinaimg.cn/mw1024/800cdf9ctw1eq0vir137xj20si0gewgu.jpg" alt="(step04)" /></li>
</ul></li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[用法最简单的下拉刷新框架：一行代码搞定]]></excerpt:encoded>
		<wp:post_id>203</wp:post_id>
		<wp:post_date>2015-08-31 03:02:57</wp:post_date>
		<wp:post_date_gmt>2015-08-30 19:02:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mjrefresh</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mjrefresh"><![CDATA[MJRefresh]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>MJExtension--转换速度最快、使用最简单方便的字典转模型框架</title>
		<link>http://www.ios122.com/2015/08/mjextension/</link>
		<pubDate>Sun, 30 Aug 2015 21:00:13 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=206</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="http://images.cnitblog.com/blog2015/497279/201505/051004316736641.png" alt="Logo" /></p>

<h1>MJExtension</h1>

<ul>
<li>A fast, convenient and nonintrusive conversion between JSON and model.</li>
<li>转换速度快、使用简单方便的字典转模型框架</li>
</ul>

<p>GitHub：<a href="https://github.com/CoderMJLee">CoderMJLee</a> ｜ Blog：<a href="http://www.cnblogs.com/mjios">mjios(Chinese)</a> ｜ PR is welcome，or <a href="mailto:richermj123go@vip.qq.com">feedback</a></p>

<h2>Contents</h2>

<ul>
<li><a href="#Getting_Started">Getting Started 【开始使用】</a>

<ul>
<li><a href="#Features">Features 【能做什么】</a></li>
<li><a href="#Why_MJExtension">Why MJExtension 【为什么使用MJExtension】</a></li>
<li><a href="#Installation">Installation 【安装】</a></li>
</ul></li>
<li><a href="#Examples">Examples 【示例】</a>

<ul>
<li><a href="#JSON_Model">JSON -> Model</a></li>
<li><a href="#JSONString_Model">JSONString -> Model</a></li>
<li><a href="#Model_contains_model">Model contains model</a></li>
<li><a href="#Model_contains_model_array">Model contains model-array</a></li>
<li><a href="#Model_name_JSON_key_mapping">Model name - JSON key mapping</a></li>
<li><a href="#JSON_array_model_array">JSON array -> model array</a></li>
<li><a href="#Model_JSON">Model -> JSON</a></li>
<li><a href="#Model_array_JSON_array">Model array -> JSON array</a></li>
<li><a href="#Core_Data">Core Data</a></li>
<li><a href="#Coding">Coding</a></li>
<li><a href="#Camel_underline">Camel -> underline</a></li>
<li><a href="#NSString_NSDate">NSString -> NSDate, nil -> @""</a></li>
<li><a href="#More_use_cases">More use cases</a></li>
</ul></li>
</ul>

<hr />

<h1><a id="Getting_Started"></a> Getting Started【开始使用】</h1>

<h2><a id="Features"></a> Features【能做什么】</h2>

<ul>
<li>MJExtension是一套字典和模型之间互相转换的超轻量级框架</li>
<li><code>JSON</code> --> <code>Model</code>、<code>Core Data Model</code></li>
<li><code>JSONString</code> --> <code>Model</code>、<code>Core Data Model</code></li>
<li><code>Model</code>、<code>Core Data Model</code> --> <code>JSON</code></li>
<li><code>JSON Array</code> --> <code>Model Array</code>、<code>Core Data Model Array</code></li>
<li><code>JSONString</code> --> <code>Model Array</code>、<code>Core Data Model Array</code></li>
<li><code>Model Array</code>、<code>Core Data Model Array</code> --> <code>JSON Array</code></li>
<li>Coding all properties of model in one line code.

<ul>
<li>只需要一行代码，就能实现模型的所有属性进行Coding（归档和解档）</li>
</ul></li>
</ul>

<h2><a id="Why_MJExtension"></a> Why use MJExtension, why not use JSONModel or Mantle</h2>

<h4>MJExtension is faster than JSONModel and Mantle【转换速率】</h4>

<ul>
<li><code>MJExtension</code> > <code>JSONModel</code> > <code>Mantle</code> <em>(Feel free to test it yourself)</em></li>
<li>各位开发者也可以自行测试</li>
</ul>

<h4>MJExtension is more easy to go【MJExtension更加容易使用】</h4>

<ul>
<li><p><code>JSONModel</code></p>

<ul>
<li>You <code>must</code> let <code>all</code> model class extend <code>JSONModel</code> class</li>
<li>要求所有模型类<code>必须</code>继承自JSONModel基类</li>
</ul></li>
<li><p><code>Mantle</code></p>

<ul>
<li>You <code>must</code> let <code>all</code> model class extend <code>MTModel</code> class.</li>
<li>要求所有模型类<code>必须</code>继承自MTModel基类</li>
</ul></li>
<li><p><code>MJExtension</code></p>

<ul>
<li>Your model class <code>doesn't need to</code> extend another base class. You don't need to modify any model file.  <code>Nonintrusive</code>, <code>convenient</code>.</li>
<li><code>不需要</code>你的模型类继承任何特殊基类，也不需要修改任何模型代码，毫无污染，毫无侵入性</li>
</ul></li>
</ul>

<h2><a id="Installation"></a> Installation【安装】</h2>

<h3>From CocoaPods【使用CocoaPods】</h3>

<pre><code class="ruby">pod 'MJExtension'
</code></pre>

<h3>Manually【手动导入】</h3>

<ul>
<li>Drag all source files under floder <code>MJExtension</code> to your project.【将<code>MJExtension</code>文件夹中的所有源代码拽入项目中】</li>
<li>Import the main header file：<code>#import "MJExtension.h"</code>【导入主头文件：<code>#import "MJExtension.h"</code>】</li>
</ul>

<pre><code class="objc">MJExtension.h
MJConst.h               MJConst.m
MJFoundation.h          MJFoundation.m
MJProperty.h            MJProperty.m
MJType.h                MJType.m
NSObject+MJCoding.h     NSObject+MJCoding.m
NSObject+MJProperty.h   NSObject+MJProperty.m
NSObject+MJKeyValue.h   NSObject+MJKeyValue.m
</code></pre>

<h1><a id="Examples"></a> Examples【示例】</h1>

<h3><a id="JSON_Model"></a> The most simple JSON -> Model【最简单的字典转模型】</h3>

<pre><code class="objc">typedef enum {
    SexMale,
    SexFemale
} Sex;

@interface User : NSObject
@property (copy, nonatomic) NSString *name;
@property (copy, nonatomic) NSString *icon;
@property (assign, nonatomic) unsigned int age;
@property (copy, nonatomic) NSString *height;
@property (strong, nonatomic) NSNumber *money;
@property (assign, nonatomic) Sex sex;
@property (assign, nonatomic, getter=isGay) BOOL gay;
@end

/***********************************************/

NSDictionary *dict = @{
    @"name" : @"Jack",
    @"icon" : @"lufy.png",
    @"age" : @20,
    @"height" : @"1.55",
    @"money" : @100.9,
    @"sex" : @(SexFemale),
    @"gay" : @"true"
//   @"gay" : @"1"
//   @"gay" : @"NO"
};

// JSON -&gt; User
User *user = [User objectWithKeyValues:dict];

NSLog(@"name=%@, icon=%@, age=%zd, height=%@, money=%@, sex=%d, gay=%d", user.name, user.icon, user.age, user.height, user.money, user.sex, user.gay);
// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1
</code></pre>

<h3><a id="JSONString_Model"></a> JSONString -> Model【JSON字符串转模型】</h3>

<pre><code class="objc">// 1.Define a JSONString
NSString *jsonString = @"{\"name\":\"Jack\", \"icon\":\"lufy.png\", \"age\":20}";

// 2.JSONString -&gt; User
User *user = [User objectWithKeyValues:jsonString];

// 3.Print user's properties
NSLog(@"name=%@, icon=%@, age=%d", user.name, user.icon, user.age);
// name=Jack, icon=lufy.png, age=20
</code></pre>

<h3><a id="Model_contains_model"></a> Model contains model【模型中嵌套模型】</h3>

<pre><code class="objc">@interface Status : NSObject
@property (copy, nonatomic) NSString *text;
@property (strong, nonatomic) User *user;
@property (strong, nonatomic) Status *retweetedStatus;
@end

/***********************************************/

NSDictionary *dict = @{
    @"text" : @"Agree!Nice weather!",
    @"user" : @{
        @"name" : @"Jack",
        @"icon" : @"lufy.png"
    },
    @"retweetedStatus" : @{
        @"text" : @"Nice weather!",
        @"user" : @{
            @"name" : @"Rose",
            @"icon" : @"nami.png"
        }
    }
};

// JSON -&gt; Status
Status *status = [Status objectWithKeyValues:dict];

NSString *text = status.text;
NSString *name = status.user.name;
NSString *icon = status.user.icon;
NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
// text=Agree!Nice weather!, name=Jack, icon=lufy.png

NSString *text2 = status.retweetedStatus.text;
NSString *name2 = status.retweetedStatus.user.name;
NSString *icon2 = status.retweetedStatus.user.icon;
NSLog(@"text2=%@, name2=%@, icon2=%@", text2, name2, icon2);
// text2=Nice weather!, name2=Rose, icon2=nami.png
</code></pre>

<h3><a id="Model_contains_model_array"></a> Model contains model-array【模型中有个数组属性，数组里面又要装着其他模型】</h3>

<pre><code class="objc">@interface Ad : NSObject
@property (copy, nonatomic) NSString *image;
@property (copy, nonatomic) NSString *url;
@end

@interface StatusResult : NSObject
/** Contatins status model */
@property (strong, nonatomic) NSMutableArray *statuses;
/** Contatins ad model */
@property (strong, nonatomic) NSArray *ads;
@property (strong, nonatomic) NSNumber *totalNumber;
@end

/***********************************************/

// Tell MJExtension what type model will be contained in statuses and ads.
[StatusResult setupObjectClassInArray:^NSDictionary *{
    return @{
               @"statuses" : @"Status",
               // @"statuses" : [Status class],
               @"ads" : @"Ad"
               // @"ads" : [Ad class]
           };
}];
// Equals: StatusResult.m implements +objectClassInArray method.

NSDictionary *dict = @{
    @"statuses" : @[
                      @{
                          @"text" : @"Nice weather!",
                          @"user" : @{
                              @"name" : @"Rose",
                              @"icon" : @"nami.png"
                          }
                      },
                      @{
                          @"text" : @"Go camping tomorrow!",
                          @"user" : @{
                              @"name" : @"Jack",
                              @"icon" : @"lufy.png"
                          }
                      }
                  ],
    @"ads" : @[
                 @{
                     @"image" : @"ad01.png",
                     @"url" : @"http://www.ad01.com"
                 },
                 @{
                     @"image" : @"ad02.png",
                     @"url" : @"http://www.ad02.com"
                 }
             ],
    @"totalNumber" : @"2014"
};

// JSON -&gt; StatusResult
StatusResult *result = [StatusResult objectWithKeyValues:dict];

NSLog(@"totalNumber=%@", result.totalNumber);
// totalNumber=2014

// Printing
for (Status *status in result.statuses) {
    NSString *text = status.text;
    NSString *name = status.user.name;
    NSString *icon = status.user.icon;
    NSLog(@"text=%@, name=%@, icon=%@", text, name, icon);
}
// text=Nice weather!, name=Rose, icon=nami.png
// text=Go camping tomorrow!, name=Jack, icon=lufy.png

// Printing
for (Ad *ad in result.ads) {
    NSLog(@"image=%@, url=%@", ad.image, ad.url);
}
// image=ad01.png, url=http://www.ad01.com
// image=ad02.png, url=http://www.ad02.com
</code></pre>

<h3><a id="Model_name_JSON_key_mapping"></a> Model name - JSON key mapping【模型中的属性名和字典中的key不相同(或者需要多级映射)】</h3>

<pre><code class="objc">@interface Bag : NSObject
@property (copy, nonatomic) NSString *name;
@property (assign, nonatomic) double price;
@end

@interface Student : NSObject
@property (copy, nonatomic) NSString *ID;
@property (copy, nonatomic) NSString *desc;
@property (copy, nonatomic) NSString *nowName;
@property (copy, nonatomic) NSString *oldName;
@property (copy, nonatomic) NSString *nameChangedTime;
@property (strong, nonatomic) Bag *bag;
@end

/***********************************************/

// How to map
[Student setupReplacedKeyFromPropertyName:^NSDictionary *{
    return @{
               @"ID" : @"id",
               @"desc" : @"desciption",
               @"oldName" : @"name.oldName",
               @"nowName" : @"name.newName",
               @"nameChangedTime" : @"name.info[1].nameChangedTime",
               @"bag" : @"other.bag"
           };
}];
// Equals: Student.m implements +replacedKeyFromPropertyName method.

NSDictionary *dict = @{
    @"id" : @"20",
    @"desciption" : @"kids",
    @"name" : @{
        @"newName" : @"lufy",
        @"oldName" : @"kitty",
        @"info" : @[
                 @"test-data",
                 @{
                             @"nameChangedTime" : @"2013-08"
                         }
                  ]
    },
    @"other" : @{
        @"bag" : @{
            @"name" : @"a red bag",
            @"price" : @100.7
        }
    }
};

// JSON -&gt; Student
Student *stu = [Student objectWithKeyValues:dict];

// Printing
NSLog(@"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@",
      stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);
// ID=20, desc=kids, oldName=kitty, nowName=lufy, nameChangedTime=2013-08
NSLog(@"bagName=%@, bagPrice=%f", stu.bag.name, stu.bag.price);
// bagName=a red bag, bagPrice=100.700000
</code></pre>

<h3><a id="JSON_array_model_array"></a> JSON array -> model array【将一个字典数组转成模型数组】</h3>

<pre><code class="objc">NSArray *dictArray = @[
                         @{
                             @"name" : @"Jack",
                             @"icon" : @"lufy.png"
                         },
                         @{
                             @"name" : @"Rose",
                             @"icon" : @"nami.png"
                         }
                     ];

// JSON array -&gt; User array
NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];

// Printing
for (User *user in userArray) {
    NSLog(@"name=%@, icon=%@", user.name, user.icon);
}
// name=Jack, icon=lufy.png
// name=Rose, icon=nami.png
</code></pre>

<h3><a id="Model_JSON"></a> Model -> JSON【将一个模型转成字典】</h3>

<pre><code class="objc">// New model
User *user = [[User alloc] init];
user.name = @"Jack";
user.icon = @"lufy.png";

Status *status = [[Status alloc] init];
status.user = user;
status.text = @"Nice mood!";

// Status -&gt; JSON
NSDictionary *statusDict = status.keyValues;
NSLog(@"%@", statusDict);
/*
 {
 text = "Nice mood!";
 user =     {
 icon = "lufy.png";
 name = Jack;
 };
 }
 */

// More complex situation
Student *stu = [[Student alloc] init];
stu.ID = @"123";
stu.oldName = @"rose";
stu.nowName = @"jack";
stu.desc = @"handsome";
stu.nameChangedTime = @"2018-09-08";

Bag *bag = [[Bag alloc] init];
bag.name = @"a red bag";
bag.price = 205;
stu.bag = bag;

NSDictionary *stuDict = stu.keyValues;
NSLog(@"%@", stuDict);
/*
{
    ID = 123;
    bag =     {
        name = "\U5c0f\U4e66\U5305";
        price = 205;
    };
    desc = handsome;
    nameChangedTime = "2018-09-08";
    nowName = jack;
    oldName = rose;
}
 */
</code></pre>

<h3><a id="Model_array_JSON_array"></a> Model array -> JSON array【将一个模型数组转成字典数组】</h3>

<pre><code class="objc">// New model array
User *user1 = [[User alloc] init];
user1.name = @"Jack";
user1.icon = @"lufy.png";

User *user2 = [[User alloc] init];
user2.name = @"Rose";
user2.icon = @"nami.png";

NSArray *userArray = @[user1, user2];

// Model array -&gt; JSON array
NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];
NSLog(@"%@", dictArray);
/*
 (
 {
 icon = "lufy.png";
 name = Jack;
 },
 {
 icon = "nami.png";
 name = Rose;
 }
 )
 */
</code></pre>

<h3><a id="Core_Data"></a> Core Data</h3>

<pre><code class="objc">NSDictionary *dict = @{
                         @"name" : @"Jack",
                         @"icon" : @"lufy.png",
                         @"age" : @20,
                         @"height" : @1.55,
                         @"money" : @"100.9",
                         @"sex" : @(SexFemale),
                         @"gay" : @"true"
                     };

// This demo just provide simple steps
NSManagedObjectContext *context = nil;
User *user = [User objectWithKeyValues:dict context:context];

[context save:nil];
</code></pre>

<h3><a id="Coding"></a> Coding</h3>

<pre><code class="objc">#import "MJExtension.h"

@implementation Bag
// NSCoding Implementation
MJCodingImplementation
@end

/***********************************************/

// what properties not to be coded
[Bag setupIgnoredCodingPropertyNames:^NSArray *{
    return @[@"name"];
}];
// Equals: Bag.m implements +ignoredCodingPropertyNames method.

// Create model
Bag *bag = [[Bag alloc] init];
bag.name = @"Red bag";
bag.price = 200.8;

NSString *file = [NSHomeDirectory() stringByAppendingPathComponent:@"Desktop/bag.data"];
// Encoding
[NSKeyedArchiver archiveRootObject:bag toFile:file];

// Decoding
Bag *decodedBag = [NSKeyedUnarchiver unarchiveObjectWithFile:file];
NSLog(@"name=%@, price=%f", decodedBag.name, decodedBag.price);
// name=(null), price=200.800000
</code></pre>

<h3><a id="Camel_underline"></a> Camel -> underline【统一转换属性名（比如驼峰转下划线）】</h3>

<pre><code class="objc">// Dog
#import "MJExtension.h"

@implementation Dog
+ (NSString *)replacedKeyFromPropertyName121:(NSString *)propertyName
{
    // nickName -&gt; nick_name
    return [propertyName underlineFromCamel];
}
@end

// NSDictionary
NSDictionary *dict = @{
                       @"nick_name" : @"旺财",
                       @"sale_price" : @"10.5",
                       @"run_speed" : @"100.9"
                       };
// NSDictionary -&gt; Dog
Dog *dog = [Dog objectWithKeyValues:dict];

// printing
NSLog(@"nickName=%@, scalePrice=%f runSpeed=%f", dog.nickName, dog.salePrice, dog.runSpeed);
</code></pre>

<h3><a id="NSString_NSDate"></a> NSString -> NSDate, nil -> @""【过滤字典的值（比如字符串日期处理为NSDate、字符串nil处理为@""）】</h3>

<pre><code class="objc">// Book
#import "MJExtension.h"

@implementation Book
- (id)newValueFromOldValue:(id)oldValue property:(MJProperty *)property
{
    if ([property.name isEqualToString:@"publisher"]) {
        if (oldValue == nil) return @"";
    } else if (property.type.typeClass == [NSDate class]) {
        NSDateFormatter *fmt = [[NSDateFormatter alloc] init];
        fmt.dateFormat = @"yyyy-MM-dd";
        return [fmt dateFromString:oldValue];
    }

    return oldValue;
}
@end

// NSDictionary
NSDictionary *dict = @{
                       @"name" : @"5分钟突破iOS开发",
                       @"publishedTime" : @"2011-09-10"
                       };
// NSDictionary -&gt; Book
Book *book = [Book objectWithKeyValues:dict];

// printing
NSLog(@"name=%@, publisher=%@, publishedTime=%@", book.name, book.publisher, book.publishedTime);
</code></pre>

<h3><a id="More_use_cases"></a> More use cases【更多用法】</h3>

<ul>
<li>Please reference to <code>NSObject+MJKeyValue.h</code> and <code>NSObject+MJCoding.h</code></li>
</ul>

<h2>期待</h2>

<ul>
<li>如果在使用过程中遇到BUG，希望你能Issues我，谢谢（或者尝试下载最新的框架代码看看BUG修复没有）</li>
<li>如果在使用过程中发现功能不够用，希望你能Issues我，我非常想为这个框架增加更多好用的功能，谢谢</li>
<li>如果你想为MJExtension输出代码，请拼命Pull Requests我</li>
<li>一起携手打造天朝乃至世界最好用的字典模型框架，做天朝程序员的骄傲</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[转换速度最快、使用最简单方便的字典转模型框架]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date>2015-08-31 05:00:13</wp:post_date>
		<wp:post_date_gmt>2015-08-30 21:00:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mjextension</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mjextension"><![CDATA[MJExtension]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_post_restored_from</wp:meta_key>
			<wp:meta_value><![CDATA[a:3:{s:20:"restored_revision_id";i:374;s:16:"restored_by_user";i:1;s:13:"restored_time";i:1445582417;}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[mjextension-%e8%bd%ac%e6%8d%a2%e9%80%9f%e5%ba%a6%e6%9c%80%e5%bf%ab%e3%80%81%e4%bd%bf%e7%94%a8%e6%9c%80%e7%ae%80%e5%8d%95%e6%96%b9%e4%be%bf%e7%9a%84%e5%ad%97%e5%85%b8%e8%bd%ac%e6%a8%a1%e5%9e%8b]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Shimmer--为应用任意视图添加闪烁效果</title>
		<link>http://www.ios122.com/2015/08/shimmer/</link>
		<pubDate>Mon, 31 Aug 2015 04:23:55 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=221</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://github.com/facebook/Shimmer/raw/master/shimmer.gif?raw=true" alt="图例" /></p>

<h2>简介</h2>

<p>Shimmer,可以给你的应用任意视图添加闪烁效果.它可以用于指示一种加载中的状态.</p>

<ul>
<li>项目主页: <a href="https://github.com/facebook/Shimmer">Shimmer</a></li>
<li>最新示例: <a href="https://github.com/facebook/Shimmer/archive/master.zip">点击下载</a></li>
</ul>

<h2>系统环境</h2>

<ul>
<li>iOS 6 +</li>
</ul>

<h2>安装</h2>

<h3>通过CocoaPods安装</h3>

<pre><code class="ruby">pod 'Shimmer'
</code></pre>

<h3>手动安装</h3>

<p>将Shimmer文件夹中的所有源代码拽入项目中即可.</p>

<h2>使用</h2>

<p>创建一个 FBShimmeringView 或 FBShimmeringLayer 对象,并添加内容,即可使用Shimmer.为了开始使用闪烁效果,将属性shimmering设为YES即可.</p>

<p>下面是一个让标签闪烁的例子:</p>

<pre><code class="objc">FBShimmeringView *shimmeringView = [[FBShimmeringView alloc] initWithFrame:self.view.bounds];
[self.view addSubview:shimmeringView];

UILabel *loadingLabel = [[UILabel alloc] initWithFrame:shimmeringView.bounds];
loadingLabel.textAlignment = NSTextAlignmentCenter;
loadingLabel.text = NSLocalizedString(@"Shimmer", nil);
shimmeringView.contentView = loadingLabel;

// 开始闪烁.
shimmeringView.shimmering = YES;
</code></pre>

<p>你可以下载最新的示例工程.点击FBShimmering.xcworkpace运行示例工程后,你可以水平或竖直清扫来查看不同参数下闪烁的效果;也可以轻击来开始或停止闪烁效果.</p>

<h2>FBShimmering 协议</h2>

<p>FBShimmeringView 或 FBShimmeringLayer均遵循 <FBShimmering>协议,可以很灵活地定制他们的行为:</p>

<pre><code class="objc">@protocol FBShimmering &lt;NSObject&gt;

//! @abstract 设置为YES,开始闪烁;设置为NO,停止闪烁.默认NO.
@property (assign, nonatomic, readwrite, getter = isShimmering) BOOL shimmering;

//! @abstract 两次闪烁的时间间隔,单位为秒.默认0.4.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringPauseDuration;

//! @abstract 内容闪烁时的透明度.默认 0.5.
@property (assign, nonatomic, readwrite) CGFloat shimmeringAnimationOpacity;

//! @abstract 内容闪烁前的透明度,默认1.0.
@property (assign, nonatomic, readwrite) CGFloat shimmeringOpacity;

//! @abstract 内容闪烁的速度,单位 点/秒.默认230.

@property (assign, nonatomic, readwrite) CGFloat shimmeringSpeed;

//! @abstract 闪烁区中高亮显示的范围.取值[0,1],默认1.0.
@property (assign, nonatomic, readwrite) CGFloat shimmeringHighlightLength;


//! @abstract 闪烁动画的方向.默认FBShimmerDirectionRight.
@property (assign, nonatomic, readwrite) FBShimmerDirection shimmeringDirection;

//! @abstract 闪烁开始时的淡出时间.默认0.1.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringBeginFadeDuration;

//! @abstract 闪烁结束时的淡出时间.默认0.3.
@property (assign, nonatomic, readwrite) CFTimeInterval shimmeringEndFadeDuration;

/**
@abstract 闪烁渐出时,CoreAnimation的绝对媒体时间.
@discussion 只在设置 {@ref shimmering} 为NO时有效.
 */
@property (assign, nonatomic, readonly) CFTimeInterval shimmeringFadeTime;

/**
@abstract 闪烁简要开始时,CoreAnimation的绝对媒体时间.
@discussion 只在设置 {@ref shimmering} 为YES时有效.
 */
@property (assign, nonatomic) CFTimeInterval shimmeringBeginTime;
@end
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[Shimmer,可以给你的应用任意视图添加闪烁效果.它可以用于指示一种加载中的状态.]]></excerpt:encoded>
		<wp:post_id>221</wp:post_id>
		<wp:post_date>2015-08-31 12:23:55</wp:post_date>
		<wp:post_date_gmt>2015-08-31 04:23:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>shimmer</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="shimmer"><![CDATA[Shimmer]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Colours--颜色库,包含100种预定义的颜色和方法</title>
		<link>http://www.ios122.com/2015/08/colours/</link>
		<pubDate>Mon, 31 Aug 2015 13:33:09 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=243</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://github.com/bennyguitar/Colours/raw/master/Screenshots/banner.png" alt="Colours" /></p>

<h2>简介</h2>

<p>Colours–颜色库,包含100种预定义的颜色和方法,可以简化颜色搭配相关的开发工作.</p>

<ul>
<li>项目主页: <a href="https://github.com/bennyguitar/Colours">Colours</a></li>
<li>最新示例: <a href="https://github.com/bennyguitar/Colours/archive/master.zip">点击下载</a></li>
</ul>

<h2>安装</h2>

<h3>通过Cocoapods安装</h3>

<pre><code class="ruby">pod 'Colours'
</code></pre>

<h3>手动安装</h3>

<p>把 Colours.h 和 Colours.m拖进你的工程里,在需要的地方引入头文件即可:</p>

<pre><code class="objc">#import "Colours.h"
</code></pre>

<h2>调色板,一组预定义的颜色</h2>

<p>具体可点击这里查看: <a href="https://github.com/bennyguitar/Colours#color-palette">100个预定义的颜色</a></p>

<h2>使用预定义的颜色</h2>

<p>Colours 预定义了100 多种颜色,用法和使用iOS系统预定义的方式一样:</p>

<pre><code class="objc">[UIColor indigoColor]; // indigoColor是Colours预定义的一种颜色.
</code></pre>

<h2>颜色相关的工具方法</h2>

<h3>十六进制字符串与颜色的相互转换</h3>

<pre><code class="objc">UIColor *newColor = [UIColor colorFromHexString:@"#f587e4"];
NSString *hexString = [newColor hexString];
</code></pre>

<h3>RGBA与颜色的相互转换.</h3>

<h4>RGBA数组与颜色的相互转换</h4>

<pre><code class="objc">NSArray *colorArray = [[UIColor seafoamColor] rgbaArray];// 数组中存储四个NSNumber对象分别代表RGBA的四个值,取值范围 0-1.
UIColor *newColor = [UIColor colorFromRGBAArray:colorArray];
</code></pre>

<h4>RGBA字典与颜色的相互转换</h4>

<p>预定义的四个键是:</p>

<ul>
<li>kColoursRGBA_R</li>
<li>kColoursRGBA_G</li>
<li>kColoursRGBA_B</li>
<li>kColoursRGBA_A</li>
</ul>

<pre><code class="objc">NSDictionary *colorDict = [[UIColor seafoamColor] rgbaDictionary];
UIColor *newColor = [UIColor colorFromRGBADictionary:colorDict];

// 你可以获取某个单独的值:
NSNumber *r = colorDict[kColoursRGBA_R];
</code></pre>

<h3>HSBA数组与颜色的相互转换</h3>

<pre><code class="objc">NSArray *colorArray = [[UIColor seafoamColor] hsbaArray];// 数组中存储四个NSNumber,分别代表H(色调),S(色饱和度),B(亮度),A(透明度)的值.
NSDictionary *colorDict = [[UIColor seafoamColor] hsbaDictionary];
</code></pre>

<h3>HSBA与颜色的相互转换</h3>

<p>与RGBA与颜色的相互转换类似,预定义的键是:</p>

<ul>
<li>kColoursHSBA_H  色调</li>
<li>kColoursHSBA_S  色饱和度</li>
<li>kColoursHSBA_B  色亮度</li>
<li>kColoursHSBA_A  透明度</li>
</ul>

<pre><code class="objc">NSArray *colorArray = [[UIColor seafoamColor] hsbaArray];
NSDictionary *colorDict = [[UIColor seafoamColor] hsbaDictionary];

UIColor *newColor1 = [UIColor colorFromHSBAArray:colorArray];
UIColor *newColor2 = [UIColor colorFromHSBADictionary:colorDictionary];
</code></pre>

<h3>CIELAB 与颜色的相互转换</h3>

<p>与RGBA与颜色的相互转换类似,预定义的键是:</p>

<ul>
<li>kColoursCIE_L</li>
<li>kColoursCIE_A</li>
<li>kColoursCIE_B</li>
<li>kColoursCIE_alpha</li>
</ul>

<pre><code class="objc">NSArray *colorArray = [[UIColor seafoamColor] CIE_LabArray];
NSDictionary *colorDict = [[UIColor seafoamColor] CIE_LabDictionary];

UIColor *newColor1 = [UIColor colorFromCIE_LabArray:colorArray];
UIColor *newColor2 = [UIColor colorFromCIE_LabDictionary:colorDictionary];
</code></pre>

<h3>CMYK 与颜色的相互转换</h3>

<p>与RGBA与颜色的相互转换用法相似,预定义的键是:</p>

<ul>
<li>kColoursCMYK_C 青</li>
<li>kColoursCMYK_M 品红</li>
<li>kColoursCMYK_Y 黄</li>
<li>kColoursCMYK_K 黑</li>
</ul>

<pre><code class="objc">NSArray *colorArray = [[UIColor seafoamColor] cmykArray];
NSDictionary *colorDict = [[UIColor seafoamColor] cmykDictionary];

UIColor *newColor1 = [UIColor colorFromCMYKArray:colorArray];
UIColor *newColor2 = [UIColor colorFromCMYKDictionary:colorDictionary];
</code></pre>

<h3>获取所有颜色信息</h3>

<p>colorComponents 方法会返回一个字典,包含RGBA, HSBA, CIE_LAB和CMYK预定义的所有键:</p>

<pre><code class="objc">NSDictionary *components = [someColor colorComponents];
CGFloat H = components[kColoursHSBA_H];
CGFloat L = components[kColoursCIE_L];
</code></pre>

<p>如果你一次只想某个某一条颜色相关的信息,可以使用下面的方法:</p>

<pre><code class="objc">CGFloat R = [[UIColor tomatoColor] red];
CGFloat G = [[UIColor tomatoColor] green];
CGFloat B = [[UIColor tomatoColor] blue];
CGFloat H = [[UIColor tomatoColor] hue];
CGFloat S = [[UIColor tomatoColor] saturation];
CGFloat B = [[UIColor tomatoColor] brightness];
CGFloat CIE_L = [[UIColor tomatoColor] CIE_Lightness];
CGFloat CIE_A = [[UIColor tomatoColor] CIE_a];
CGFloat CIE_B = [[UIColor tomatoColor] CIE_b];
CGFloat alpha = [[UIColor tomatoColor] alpha];
</code></pre>

<h3>颜色变亮/变暗</h3>

<pre><code class="objc">// 取值范围 0-&gt;1
UIColor *lighterColor = [[UIColor seafoamColor] lighten:0.25f];
UIColor *darkerColor = [[UIColor seafoamColor] darken:0.25f];
</code></pre>

<h3>获取对比色</h3>

<pre><code class="objc">// 根据给定的颜色,自动与之能形成对比色的黑色或白色.
UIColor *contrastingColor = [[UIColor seafoamColor] blackOrWhiteContrastingColor];
</code></pre>

<h3>获取互补色</h3>

<pre><code class="objc">// 返回一个给定颜色的互补色:色调改变,色调和饱和度不变.
UIColor *complementary = [[UIColor seafoamColor] complementaryColor];
获取两个颜色间的差别

// 此处的差别,综合考虑了人的感官,数学统计算法等,不是一般的RGB差值.
CGFloat distance = [someColor distanceFromColor:someOtherColor type:ColorDistanceCIE94];
BOOL isNoticablySimilar = distance &lt; threshold;
</code></pre>

<h3>基于一种颜色,产生多种对应的颜色方案</h3>

<p>使用 colorSchemeOfType 方法可以基于某一个颜色,产生四个新的漂亮合适的颜色,并把全部五个颜色以数组形式返回.同一种颜色,不同的方案也会产生不同的颜色组合.</p>

<pre><code class="objc">NSArray *colorScheme = [color colorSchemeOfType:ColorSchemeType];
</code></pre>

<p>可选颜色方案:</p>

<ul>
<li>ColorSchemeAnalagous  近似色</li>
<li>ColorSchemeMonochromatic 单色</li>
<li>ColorSchemeTriad 混合色</li>
<li>ColorSchemeComplementary 互补色
下面是基于[UIColor seafoamColor]颜色的不同颜色方案返回值的示例:</li>
</ul>

<p>ColorSchemeAnalagous
<img src="https://camo.githubusercontent.com/c8ff36ae8ab7028d2bbfaa29c8e5a5f47e8becee/68747470733a2f2f7261772e6769746875622e636f6d2f62656e6e796775697461722f436f6c6f7572732d666f722d694f532f6d61737465722f53637265656e73686f74732f616e616c61676f75732e706e67" alt="ColorSchemeAnalagous" /></p>

<p>ColorSchemeMonochromatic
<img src="https://camo.githubusercontent.com/5e3a6ff4d7b61a40729486959b994b89d7fdd9aa/68747470733a2f2f7261772e6769746875622e636f6d2f62656e6e796775697461722f436f6c6f7572732d666f722d694f532f6d61737465722f53637265656e73686f74732f6d6f6e6f6368726f6d617469632e706e67" alt="Monochromatic" /></p>

<p>ColorSchemeTriad
<img src="https://camo.githubusercontent.com/1f29e3bda25073c2e2f0e2f09254f9840acada23/68747470733a2f2f7261772e6769746875622e636f6d2f62656e6e796775697461722f436f6c6f7572732d666f722d694f532f6d61737465722f53637265656e73686f74732f74726961642e706e67" alt="Triad" /></p>

<p>ColorSchemeComplementary
<img src="https://camo.githubusercontent.com/9408f56e769b0ac1200d77930f9d8c8ffdc684b0/68747470733a2f2f7261772e6769746875622e636f6d2f62656e6e796775697461722f436f6c6f7572732d666f722d694f532f6d61737465722f53637265656e73686f74732f636f6d706c656d656e746172792e706e67" alt="Complementary" /></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[Colours–颜色库,包含100种预定义的颜色和方法,可以简化颜色搭配相关的开发工作.]]></excerpt:encoded>
		<wp:post_id>243</wp:post_id>
		<wp:post_date>2015-08-31 21:33:09</wp:post_date>
		<wp:post_date_gmt>2015-08-31 13:33:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>colours</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="colours"><![CDATA[Colours]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>iOS-blur,为任意视图添加模糊效果</title>
		<link>http://www.ios122.com/2015/09/ios-blur/</link>
		<pubDate>Tue, 01 Sep 2015 03:15:04 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=261</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://camo.githubusercontent.com/1a3847644269c1e9706c31c6ea9525bd5fc385b4/68747470733a2f2f7261772e6769746875622e636f6d2f4a616743657361722f694f532d626c75722f6d61737465722f73637265656e73686f742e706e67" alt="" /></p>

<h1>简介</h1>

<p>iOS-blur使用一种巧妙的方式,为任意视图添加一种非常奇妙的模糊效果.</p>

<ul>
<li>项目主页: <a href="https://github.com/JagCesar/iOS-blur">iOS-blur</a></li>
<li>最新示例: <a href="https://github.com/JagCesar/iOS-blur/archive/master.zip">点击下载</a></li>
<li>注意: iOS至今未提供此处所有模糊效果的接口,但创作者使用的也不是私有API,可放心在自己的项目中应用此第三方. </li>
</ul>

<h1>快速入门</h1>

<h2>运行环境</h2>

<ul>
<li>iOS 7 +</li>
</ul>

<h2>安装</h2>

<h3>通过CocoaPods安装</h3>

<pre><code>pod 'iOS-blur'
</code></pre>

<h3>手动安装</h3>

<p>把JCRBlurView.h 和 JCRBlurView.m拖拽到自己的工程中即可.</p>

<h2>使用</h2>

<p>支持自适应布局,纯代码使用的话,示例如下:</p>

<pre><code>JCRBlurView *blurView = [JCRBlurView new];
[blurView setFrame:CGRectMake(0.0f,0.0f,100.0f,100.0f)];
[self.view addSubview:blurView];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[iOS-blur使用一种巧妙的方式,为任意视图添加一种非常奇妙的模糊效果,iOS至今未提供此处所有模糊效果的接口,但创作者使用的也不是私有API,可放心在自己的项目中应用此第三方. ]]></excerpt:encoded>
		<wp:post_id>261</wp:post_id>
		<wp:post_date>2015-09-01 11:15:04</wp:post_date>
		<wp:post_date_gmt>2015-09-01 03:15:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ios-blur</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ios-blur"><![CDATA[iOS-blur]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>JVFloatLabeledTextField--用户体验优先的浮动式表单输入框</title>
		<link>http://www.ios122.com/2015/09/jvfloatlabeledtextfield/</link>
		<pubDate>Tue, 01 Sep 2015 05:44:53 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=268</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://camo.githubusercontent.com/be57d040ec0ce5d6467fb73564c6bcb6c76d5a7b/687474703a2f2f6472696262626c652e73332e616d617a6f6e6177732e636f6d2f75736572732f363431302f73637265656e73686f74732f313235343433392f666f726d2d616e696d6174696f6e2d5f6769665f2e676966" alt="" /></p>

<h1>简介</h1>

<p>JVFloatLabeledTextField 是注重用户体验的"浮动标签模式"(Float Label Patter)的第一个实现,可以有效解决移动设备上进行表单输入时,无法边看表单提示边进行输入的困境,用户体验非常好.</p>

<ul>
<li><p>项目主页: <a href="https://github.com/jverdi/JVFloatLabeledTextField">JVFloatLabeledTextField</a></p></li>
<li><p>最新示例: <a href="https://github.com/jverdi/JVFloatLabeledTextField/archive/master.zip">点击下载</a></p></li>
</ul>

<h1>入门</h1>

<h2>使用环境</h2>

<ul>
<li>iOS 7 +</li>
</ul>

<h2>安装</h2>

<h3>使用cocoapods安装</h3>

<pre><code>pod 'JVFloatLabeledTextField'
</code></pre>

<h3>手动安装</h3>

<p>把 JVFloatLabeledTextField.h 和 JVFloatLabeledTextView.h文件拖到你的项中即可.</p>

<h2>使用</h2>

<p>JVFloatLabeledTextField 同时支持以纯代码形式和IB可视化形式使用.内部含有两个类JVFloatLabeledTextField 和 JVFloatLabeledTextView,分别是UITextField和UITextView的子类,可以根据自己的需要选择.自定义接口相近,下面以 JVFloatLabeledTextField 为例,做一说明:</p>

<pre><code>IB_DESIGNABLE
@interface JVFloatLabeledTextField : UITextField

/**
 * 只读的浮动式标签.
 */
@property (nonatomic, strong, readonly) UILabel * floatingLabel;

/**
 * 浮动标签距离内容的垂直距离.
 * 默认是 0.
 */
@property (nonatomic) IBInspectable CGFloat floatingLabelYPadding;

/**
 * 浮动标签距离内容的水平距离.
 * 默认是 0.
 */
@property (nonatomic) IBInspectable CGFloat floatingLabelXPadding;

/**
 * 占位内容的垂直距离.
 * 默认0.
 */
@property (nonatomic) IBInspectable CGFloat placeholderYPadding;

/**
 * 浮动式标签的字体.
 * 默认值有两个,按优先顺序排列:
 * - 自定义的占位内容的字体,字体大小取70%.
 * - 自定义的输入框的字体,字体大小变为70%.
 */
@property (nonatomic, strong) UIFont * floatingLabelFont;

/**
 * 浮动式标签的字体颜色.
 * 默认是 `[UIColor grayColor]`.
 */
@property (nonatomic, strong) IBInspectable UIColor * floatingLabelTextColor;

/**
 * 输入框成为第一响应者时,浮动标签的文字颜色.
 * 默认是 Tint color.
 */
@property (nonatomic, strong) IBInspectable UIColor * floatingLabelActiveTextColor;

/**
 * 指明浮动式标签的外观是否只在输入框成为第一响应者时才使用动态变化效果.
 * 默认,仅在输入框成为第一响应者时,浮动式标签的外观才会有动态变化的效果
 */
@property (nonatomic, assign) IBInspectable BOOL animateEvenIfNotFirstResponder;

/**
 * 显示浮动式标签的动画时长.
 * 默认0.3秒.
 */
@property (nonatomic, assign) NSTimeInterval floatingLabelShowAnimationDuration;

/**
 * 隐藏浮动式标签时的动画时长.
 * 默认0.3秒.
 */
@property (nonatomic, assign) NSTimeInterval floatingLabelHideAnimationDuration;

/**
 * 指明清除按钮是否自动和文本对齐.
 * 默认值:YES.
 */
@property (nonatomic, assign) IBInspectable BOOL adjustsClearButtonRect;

/**
 * 指明当输入文字时,是否下调基准线(baseline).YES(非默认值),意味着占位内容会和输入内容对齐.
 * 默认值: NO.(占位内容位于输入内容的上面.)
 */
@property (nonatomic, assign) IBInspectable BOOL keepBaseline;

/**
 *  设置占位文字和浮动式标签的文字.
 *
 *  @param placeholder 没有文字输入时,默认显示的内容.
 *  @param floatingTitle 一旦用户开始输入文字,显示在输入框上部的文字
 */
- (void)setPlaceholder:(NSString *)placeholder floatingTitle:(NSString *)floatingTitle;

@end
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[JVFloatLabeledTextField 是注重用户体验的"浮动标签模式"(Float Label Patter)的第一个实现,可以有效解决移动设备上进行表单输入时,无法边看表单提示边进行输入的困境,用户体验非常好.]]></excerpt:encoded>
		<wp:post_id>268</wp:post_id>
		<wp:post_date>2015-09-01 13:44:53</wp:post_date>
		<wp:post_date_gmt>2015-09-01 05:44:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>jvfloatlabeledtextfield</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="jvfloatlabeledtextfield"><![CDATA[JVFloatLabeledTextField]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[jvfloatlabeledtextfield-%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c%e4%bc%98%e5%85%88%e7%9a%84%e6%b5%ae%e5%8a%a8%e5%bc%8f%e8%a1%a8%e5%8d%95%e8%be%93%e5%85%a5%e6%a1%86]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>WebViewJavascriptBridge--原生iOS 与 网页元素互相通信</title>
		<link>http://www.ios122.com/2015/09/webviewjavascriptbridge/</link>
		<pubDate>Tue, 01 Sep 2015 07:09:17 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=276</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

<p>提供在webView中, 原生iOS 与 网页元素互相通信的能力.</p>

<ul>
<li>项目主页: <a href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a></li>
<li>最新示例: <a href="https://github.com/marcuswestin/WebViewJavascriptBridge/archive/master.zip">点击下载</a></li>
</ul>

<h1>入门</h1>

<h2>使用环境</h2>

<ul>
<li>iOS4 +</li>
</ul>

<h2>安装</h2>

<p>直接将WebViewJavascriptBridge 文件夹拖进你的工程在弹出的复选框中,不要选”Copy items into destination group's folder””,要使用”Create groups for any folders.</p>

<h2>使用</h2>

<h3>导入头文件,并声明变量属性.</h3>

<pre><code>#import “WebViewJavascriptBridge.h"
 
@property (nonatomic, retain) WebViewJavascriptBridge* bridge;
//可也以设置某个WVJBResponseCallback 属性
例如:@property (copy, nonatomic) WVJBResponseCallback shanchuCallback
 
//加载你的URL [self.webView loadRequest:urlReq];
//urlReq内容 可以是从网上的链接,也可以是嵌套在应用包里的html 页面,根据需求
</code></pre>

<h3>使用UIWebview 或 WebView初始化这个WebViewJavascriptBridge</h3>

<pre><code>// 这是WebViewJavascriptBridge  最基础的初始化操作,只需执行一次,不建议调用多次,只需初始化一次即可.
self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView handler:^(id data, WVJBResponseCallback responseCallback) {
    NSLog(@"Received message from javascript: %@", data);
    responseCallback(@"Right back atcha");

}];
</code></pre>

<p>应用响应web页事件(javascript调用app内方法),通过registerHandler 来实现,一个响应事件只需初始化一次即可.例如:</p>

<pre><code>  [_bridge registerHandler:@“相应web页上某个点击事件的方法名称,该名称需和web端人员制定" handler:^(id data, WVJBResponseCallbackresponseCallback) {
      NSLog(@"这个方法 called: %@", data);
    //data 是web页给你传递的数据,可以为空,根据需求制定
    //responseCallback是你响应该事件后返回给web页的数据,可以不返回
        例如: responseCallback
(@{@"result":[NSNumber numberWithInt:1]});   
}];
</code></pre>

<h3>通过ObjC 向 javascript发送消息</h3>

<pre><code>[self.bridge send:@"Well hello there”]; //这是不需要web回调的事件
[self.bridge send:@"Give me a response, will you?" responseCallback:^(id responseData) {
    NSLog(@"ObjC got its response! %@", responseData);

}]; //这个是在发送给web页后,具有回调事件的方法.根据需求
</code></pre>

<h3>最后设置javascript端</h3>

<pre><code>  //一般不需要iOS 开发人员来设置,因为是与web页交互,这个是exmple中的例子,web开发导入或设置响应的js就可以了
//js方法
function connectWebViewJavascriptBridge(callback) {
    if (window.WebViewJavascriptBridge) {
        callback(WebViewJavascriptBridge)
    } else {
        document.addEventListener('WebViewJavascriptBridgeReady', function() {
            callback(WebViewJavascriptBridge)
        }, false)
    }

}
 
//
connectWebViewJavascriptBridge(function(bridge) {

    /* 初始化brige */
 
    bridge.init(function(message, responseCallback) {
        alert('Received message: ' + message)   
        if (responseCallback) {
            responseCallback("Right back atcha")
        }
    })
    bridge.send('Hello from the javascript')
    bridge.send('Please respond to this', function responseCallback(responseData) {
        console.log("Javascript got its response", responseData)
    })

})
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[提供在webView中, 原生iOS 与 网页元素互相通信的能力.]]></excerpt:encoded>
		<wp:post_id>276</wp:post_id>
		<wp:post_date>2015-09-01 15:09:17</wp:post_date>
		<wp:post_date_gmt>2015-09-01 07:09:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>webviewjavascriptbridge</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="webviewjavascriptbridge"><![CDATA[WebViewJavascriptBridge]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>EAIntroView--高度可定制的应用欢迎页通用解决方案</title>
		<link>http://www.ios122.com/2015/09/eaintroview/</link>
		<pubDate>Tue, 01 Sep 2015 09:44:11 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=284</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/ealeksandrov/EAIntroView/master/Screenshot01.png" alt="" /><img src="https://raw.githubusercontent.com/ealeksandrov/EAIntroView/master/Screenshot02.png" alt="" /></p>

<h1>简介</h1>

<p>高度可定制的应用欢迎页通用解决方案,可高度定制,不要仅限于现有的demo.</p>

<ul>
<li>项目主页: <a href="https://github.com/ealeksandrov/EAIntroView">EAIntroView</a></li>
<li>最新示例: <a href="https://github.com/ealeksandrov/EAIntroView/archive/master.zip">点击下载</a></li>
</ul>

<h1>入门</h1>

<h2>安装</h2>

<p>安装后,引入” EAIntroView.h”并设置EAIntroDelegate代理即可.</p>

<h3>使用CocoaPods安装</h3>

<pre><code>pod 'EAIntroView', '~&gt; 2.7.0'
</code></pre>

<h3>手动安装</h3>

<p>添加EAIntroPage ,EAIntroView和EARestrictedScrollView 的.h和.m文件到你的工程即可.</p>

<h2>可定制性</h2>

<p>EAIntroView 可高度定制,不要仅限于现有的demo.
EAIntroView 是有一个展示用的IntroView和一组展示页面来组成一系列引导展示页.
基本使用方式是: 创建一组EAIntropage(可自定义,具体使用见下文),使用这组EAIntropage 创建一个EAIntroView的视图IntroView,将这个IntroView showInView到想要展示的视图上(见下文)</p>

<h3>每一个用来展示的基本页面都具有</h3>

<p>  
* background（有交叉的页之间的过渡）
* 在background上定制iOS7运动的效果（视差)
* title视图(y 坐标)
* title 文本(字体,颜色,y坐标)
* description 文本(字体,颜色 ,宽度,y坐标)
*  子视图数组(在建立默认的布局后添加到界面上)</p>

<h3>设置页面自定义视图:</h3>

<ul>
<li>pageWithCustomView://自定义视图</li>
<li>pageWithCustomViewFromNibNamed://自定义nib</li>
</ul>

<h3>每个页面上的事件</h3>

<ul>
<li>pageDidLoad 页面加载</li>
<li>pageDidAppear 页面显示</li>
<li>pageDidDisappear 页面消失</li>
</ul>

<h3>许多选项来自定义父视图:</h3>

<ul>
<li>swipe from last page to close //滑到最后一个关闭</li>
<li>switching pages with one simple tap//轻拍切换</li>
<li>custom background image or color//设置背景图片,颜色</li>
<li>custom page control//定义page control</li>
<li>custom skip button //自定义跳过按钮</li>
<li>pinned titleView //自定义 标题视图</li>
</ul>

<h3>代理协议:</h3>

<ul>
<li>introDidFinish: //完成引导</li>
<li>intro:pageAppeared:withIndex: //引导页切换</li>
</ul>

<h3>IntroView支持的方法:</h3>

<p>     
* setPages://设置界面
* showInView:animateDuration://设置展示动画
* hideWithFadeOutDuration://显示和消失时间
* setCurrentPageIndex:animated://设置当前显示的界面以及动画
  </p>

<h2>使用:</h2>

<h3>第一步: 创建界面</h3>

<p>每一个界面需要通过[EAIntroPage page]来创建,你可以自定义属性,所有的属性都是可选的.或者你可以通过你自定义的view(可以是nib),使用这种方式大多数选项就被忽略了.例如:</p>

<pre><code>// 基本的创建方式
EAIntroPage *page1 = [EAIntroPage page];
page1.title = @"Hello world";
page1.desc = sampleDescription1;
// 自定义的,这些属性都是可选的
EAIntroPage *page2 = [EAIntroPage page];
page2.title = @"This is page 2";
page2.titleFont = [UIFont fontWithName:@"Georgia-BoldItalic" size:20];
page2.titlePositionY = 220;
page2.desc = sampleDescription2;
page2.descFont = [UIFont fontWithName:@"Georgia-Italic" size:18];
page2.descPositionY = 200;
page2.titleIconView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"title2"]];
page2.titleIconPositionY = 100;
//nib的自定义视图
EAIntroPage *page3 = [EAIntroPage pageWithCustomViewFromNibNamed:@"IntroPage"];
page3.bgImage = [UIImage imageNamed:@"bg2"];
</code></pre>

<h3>第二步:创建介绍视图</h3>

<p>所有的页面创建完成后,创建介绍视图,只是在介绍视图中按顺序展示.也可以通过传递给IntroView一组视图初始化, IntroView将重建视图的内容.</p>

<pre><code> EAIntroView *intro = [[EAIntroView alloc] initWithFrame:self.view.bounds andPages:@[page1,page2,page3,page4]];

//设置代理
[intro setDelegate:self];
</code></pre>

<h3>第三步: 展示引导图</h3>

<pre><code>[intro showInView:self.view animateDuration:0.0];
</code></pre>

<p> </p>

<h2>Storyboard/IB可视化编程支持</h2>

<p>从EAIntroView 1.3.0 开始支持Storyboard/IB</p>

<ul>
<li>拖拽UIView 到IB文档</li>
<li>设置它的class为EAIntroView</li>
<li>创建viewcontroller 的IBOutlet 属性, 
<code>@property(nonatomic,weak) IBOutlet EAIntroView *introView;</code></li>
<li>在IB中链接<code>IBOutlet</code> 和 <code>EAIntroView</code> </li>
<li>创建界面数组(可以使用”pageWithCustomViewFromNibNamed”),一个的nib对应每个界面.
在setPages方法中将数组传递给EAIntroView 属性.</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[高度可定制的应用欢迎页通用解决方案,可高度定制,不要仅限于现有的demo.]]></excerpt:encoded>
		<wp:post_id>284</wp:post_id>
		<wp:post_date>2015-09-01 17:44:11</wp:post_date>
		<wp:post_date_gmt>2015-09-01 09:44:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>eaintroview</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="eaintroview"><![CDATA[EAIntroView]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Pop--实现任意iOS对象的任意属性的动态变化</title>
		<link>http://www.ios122.com/2015/09/pop/</link>
		<pubDate>Fri, 04 Sep 2015 11:02:14 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=295</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://github.com/facebook/pop/blob/master/Images/pop.gif?raw=true" alt="pop" /></p>

<h1>简介</h1>

<p>Pop 是一个可扩展的动画引擎,可用于实现任意iOS对象的任意属性的动态变化,支持一般动画,弹性动画和渐变动画三种类型.</p>

<ul>
<li>项目主页: <a href="https://github.com/facebook/pop">pop</a></li>
<li>最新示例: <a href="https://github.com/facebook/pop/archive/master.zip">点击下载</a></li>
<li>注意: 官方代码中,并不包含实例,而是用于编译的所有源代码,建议自行新建工程,并结合下文的代码片段查看效果.</li>
</ul>

<h1>入门</h1>

<h2>安装</h2>

<h3>通过CocoaPods安装</h3>

<pre><code class="ruby">pod 'pop', '~&gt; 1.0'
</code></pre>

<h2>使用</h2>

<p>在需要使用POP的地方,引入头文件:</p>

<pre><code class="objective-c">#import &lt;pop/POP.h&gt;
</code></pre>

<h3>动画的开始,停止 与 更新</h3>

<p>把动画添加到你想要拥有动态变化的对象上面,即可开始动画:</p>

<pre><code class="objective-c">POPSpringAnimation *anim = [POPSpringAnimation animation];
...
[layer pop_addAnimation:anim forKey:@"myKey"];
</code></pre>

<p>可以根据开始动画时传入的键,来移除对应的动画:</p>

<pre><code class="objective-c">[layer pop_removeAnimationForKey:@"myKey"];
</code></pre>

<p>开始动画时传入的键,也可以用来查询是否存在某个动画.更新一个正在执行的动画的 toValue,可以无缝实现动画效果间的过渡:</p>

<pre><code class="objective-c">anim = [layer pop_animationForKey:@"myKey"];
if (anim) {
  /* 更新toValue为一个新值. */
  anim.toValue = @(42.0);
} else {
  /* 创建并开始一个新的动画. */
  ....
}
</code></pre>

<p>上面的例子是以图层为例.Pop是以NSObject的扩展方式实现的.也就是说: 任何NSObject及其子类都可以通过Pop添加动画效果.</p>

<h3>动画类型</h3>

<p>有四种动画类型: 弹性动画,渐弱动画,基础动画和自定义动画.</p>

<h4>弹性动画</h4>

<p>弹性动画,可以给对象一个有活力的弹跳效果.下面的例子中,我们使用弹性动画来使图层的边框值从它的当前值变化为(0, 0 ,400, 400):</p>

<pre><code class="objective-c">POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerBounds];
anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 400, 400)];
[layer pop_addAnimation:anim forKey:@"size"];
</code></pre>

<h4>渐变动画</h4>

<p>渐变动画,可以让对象缓慢地停止变化.下面的例子,我们使图层的横坐标从当前值以1000像素每秒的速度渐变:</p>

<pre><code class="objective-c">POPDecayAnimation *anim = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX];
anim.velocity = @(1000.);
[layer pop_addAnimation:anim forKey:@"slide"];
</code></pre>

<h4>基础动画</h4>

<p>基础动画可以用来在指定的时间段动态改变属性的值.在默认的时间周期内动态让视图的透明度从0.0变化到1.0来实现淡入的效果:</p>

<pre><code class="objective-c">POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewAlpha];
anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
anim.fromValue = @(0.0);
anim.toValue = @(1.0);
[view pop_addAnimation:anim forKey:@"fade"];
</code></pre>

<h4>自定义动画</h4>

<p><code>POPCustomAnimation</code> 用来创建自定义动画和过渡效果.它通过管理 CADisplayLink 来管理时间与动画的关联性.更多细节,详见头文件.</p>

<h3>动画属性</h3>

<p>动画属性由<code>POPAnimatableProperty</code>类管理,用来指定在哪个属性上应用动画效果.在下面的例子中,我们创建了一个弹性动画,并且显示设置动画属性为与<code>-[CALayer bounds]</code>对应的属性:</p>

<pre><code class="objective-c">POPSpringAnimation *anim = [POPSpringAnimation animation];
anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds];
</code></pre>

<p>这个框架爱预先实现了了许多图层和视图共用的动画属性,你可以在自己的项目中直接使用.你也可以通过创建<code>POPAnimatableProperty</code>类的实例,来创建一个自定义的动画属性.下面的例子中,我们定义了一个自定义的volume动画属性:</p>

<pre><code class="objective-c">prop = [POPAnimatableProperty propertyWithName:@"com.foo.radio.volume" initializer:^(POPMutableAnimatableProperty *prop) {
  // 读取动画属性的值
  prop.readBlock = ^(id obj, CGFloat values[]) {
    values[0] = [obj volume];
  };
  // 设置动画属性的值.
  prop.writeBlock = ^(id obj, const CGFloat values[]) {
    [obj setVolume:values[0]];
  };
  // 力学上的临界值
  prop.threshold = 0.01;
}];

anim.property = prop;
</code></pre>

<p>系统预定义的动画属性也是由上面例子的机制定义的,自定义动画属性时,很有借鉴价值.完整的预定义的动画属性列表和他们实现的具体细节参见<code>POPAnimatableProperty.h</code>:</p>

<pre><code>/**
 图层(CALayer)通用动画属性.
 */
extern NSString * const kPOPLayerBackgroundColor;
extern NSString * const kPOPLayerBounds;
extern NSString * const kPOPLayerCornerRadius;
extern NSString * const kPOPLayerBorderWidth;
extern NSString * const kPOPLayerBorderColor;
extern NSString * const kPOPLayerOpacity;
extern NSString * const kPOPLayerPosition;
extern NSString * const kPOPLayerPositionX;
extern NSString * const kPOPLayerPositionY;
extern NSString * const kPOPLayerRotation;
extern NSString * const kPOPLayerRotationX;
extern NSString * const kPOPLayerRotationY;
extern NSString * const kPOPLayerScaleX;
extern NSString * const kPOPLayerScaleXY;
extern NSString * const kPOPLayerScaleY;
extern NSString * const kPOPLayerSize;
extern NSString * const kPOPLayerSubscaleXY;
extern NSString * const kPOPLayerSubtranslationX;
extern NSString * const kPOPLayerSubtranslationXY;
extern NSString * const kPOPLayerSubtranslationY;
extern NSString * const kPOPLayerSubtranslationZ;
extern NSString * const kPOPLayerTranslationX;
extern NSString * const kPOPLayerTranslationXY;
extern NSString * const kPOPLayerTranslationY;
extern NSString * const kPOPLayerTranslationZ;
extern NSString * const kPOPLayerZPosition;
extern NSString * const kPOPLayerShadowColor;
extern NSString * const kPOPLayerShadowOffset;
extern NSString * const kPOPLayerShadowOpacity;
extern NSString * const kPOPLayerShadowRadius;

/**
 图形层(CAShapeLayer)通用动画属性.
  */
extern NSString * const kPOPShapeLayerStrokeStart;
extern NSString * const kPOPShapeLayerStrokeEnd;
extern NSString * const kPOPShapeLayerStrokeColor;
extern NSString * const kPOPShapeLayerFillColor;

/**
 视图约束(NSLayoutConstraint)通用动画属性.
  */
extern NSString * const kPOPLayoutConstraintConstant;

/**
 视图(UIView)通用动画属性.
 */
extern NSString * const kPOPViewAlpha;
extern NSString * const kPOPViewBackgroundColor;
extern NSString * const kPOPViewBounds;
extern NSString * const kPOPViewCenter;
extern NSString * const kPOPViewFrame;
extern NSString * const kPOPViewScaleX;
extern NSString * const kPOPViewScaleXY;
extern NSString * const kPOPViewScaleY;
extern NSString * const kPOPViewSize;
extern NSString * const kPOPViewTintColor;

/**
 滚动视图(UIScrollView)通用动画属性.
 */
extern NSString * const kPOPScrollViewContentOffset;
extern NSString * const kPOPScrollViewContentSize;
extern NSString * const kPOPScrollViewZoomScale;
extern NSString * const kPOPScrollViewContentInset;

/**
 列表(UITableView)通用动画属性.
 */
extern NSString * const kPOPTableViewContentOffset;
extern NSString * const kPOPTableViewContentSize;

/**
 集合视图(UICollectionView)通用动画属性.
 */
extern NSString * const kPOPCollectionViewContentOffset;
extern NSString * const kPOPCollectionViewContentSize;

/**
 导航栏(UINavigationBar)通用动画属性.
 */
extern NSString * const kPOPNavigationBarBarTintColor;

/**
 工具栏(UIToolBar)通用动画属性.
 */
extern NSString * const kPOPToolbarBarTintColor;

/**
 标签栏(UITabBar)通用动画属性.
 */
extern NSString * const kPOPTabBarBarTintColor;

/**
 标签(UILabel)通用动画属性.
 */
extern NSString * const kPOPLabelTextColor;
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[Pop 是一个可扩展的动画引擎,可用于实现任意iOS对象的任意属性的动态变化,支持一般动画,弹性动画和渐变动画三种类型.]]></excerpt:encoded>
		<wp:post_id>295</wp:post_id>
		<wp:post_date>2015-09-04 19:02:14</wp:post_date>
		<wp:post_date_gmt>2015-09-04 11:02:14</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>pop</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="pop"><![CDATA[Pop]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FMDB--更友好地操作SQLite数据库</title>
		<link>http://www.ios122.com/2015/09/fmdb/</link>
		<pubDate>Sun, 06 Sep 2015 05:11:08 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=299</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

<p>FMDB 是SQLite的Objective-C封装库.</p>

<ul>
<li>项目主页: <a href="https://github.com/ccgus/fmdb">FMDB</a></li>
<li>最新示例: <a href="https://github.com/ccgus/fmdb/archive/master.zip">点击下载</a></li>
</ul>

<h1>快速入门</h1>

<h2>安装</h2>

<h3>通过 CocoaPods 安装</h3>

<pre><code>pod 'FMDB'
</code></pre>

<h2>使用</h2>

<p>FMDB 中,有三个主要的类:</p>

<ol>
<li><code>FMDatabase</code> - 代表一个SQLite数据库,用来执行SQL语句.</li>
<li><code>FMResultSet</code> - 代表<code>FMDatabase</code> 的一个SQL查询的结果.</li>
<li><code>FMDatabaseQueue</code> - 如果你想在多个线程上执行数据库查询和更新的操作, 这个类会很有用.下面的"线程安全"部分,会重点介绍它.</li>
</ol>

<h3>创建数据库</h3>

<p>可以通过指定SQLite数据库文件的路径,来创建 一个 <code>FMDatabase</code> .路径可以是以下三种方式中的任一种:</p>

<ol>
<li>一个完整文件路径.如果文件不存在,会自动创建.</li>
<li>一个空字符串(<code>@""</code>).会自动在缓存区域创建一个空的数据库.<code>FMDatabase</code>连接关闭时,此数据库会被删除.</li>
<li><code>NULL</code>.  创建一个内存数据库.<code>FMDatabase</code>连接关闭时,此数据库会被删除.</li>
</ol>

<pre><code class="objc">FMDatabase *db = [FMDatabase databaseWithPath:@"/tmp/tmp.db"]; // 此处指的是mac编程的示例,iOS上应使用沙盒路径.
</code></pre>

<h3>打开数据库</h3>

<p>只有"打开"的数据库,才能执行各种操作.如果数据库不存在或者权限不够等原因,可能会引起打开失败.</p>

<pre><code class="objc">if (![db open]) {
    [db release];
    return;
}
</code></pre>

<h3>更新数据库</h3>

<p>除<code>SELECT</code>以外的SQL操作,都被视为更新操作.包括: <code>CREATE</code>, <code>UPDATE</code>, <code>INSERT</code>, <code>ALTER</code>, <code>COMMIT</code>, <code>BEGIN</code>, <code>DETACH</code>, <code>DELETE</code>, <code>DROP</code>, <code>END</code>, <code>EXPLAIN</code>, <code>VACUUM</code> 和 <code>REPLACE</code>语句等. 只要你的语句没有以<code>SELECT</code>开头,那它就是一个更新语句.</p>

<p>执行更新操作,会返回一个布尔值.YES,表示数据库更新操作成功;NO,表示更新数据库时发生了错误.你可以通过调用<code>-lastErrorMessage</code>和 <code>-lastErrorCode</code>方法来获取关于数据库错误的具体细节.</p>

<h3>查询数据库</h3>

<p>可以通过一个<code>-executeQuery...</code>方法执行<code>SELECT</code>语句,来执行数据库查询操作.</p>

<p>查询数据库,成功返回 <code>FMResultSet</code> 对象,失败返回 <code>nil</code>. 你可以通过调用<code>-lastErrorMessage</code>和 <code>-lastErrorCode</code>方法来获取关于查询失败的具体原因.</p>

<p>为了遍历查询结果,你需要一个 <code>while()</code>语句:</p>

<pre><code class="objc">FMResultSet *s = [db executeQuery:@"SELECT * FROM myTable"];
while ([s next]) {
   // 从每条记录中,获取值.
}
</code></pre>

<p>即使只想获取单条记录,你也需要调用 <code>-[FMResultSet next]</code> 方法:</p>

<pre><code class="objc">FMResultSet *s = [db executeQuery:@"SELECT COUNT(*) FROM myTable"];
if ([s next]) {
    int totalCount = [s intForColumnIndex:0];
}
</code></pre>

<p><code>FMResultSet</code> 有许多格式化获取值的方法:</p>

<ul>
<li><code>intForColumn:</code></li>
<li><code>longForColumn:</code></li>
<li><code>longLongIntForColumn:</code></li>
<li><code>boolForColumn:</code></li>
<li><code>doubleForColumn:</code></li>
<li><code>stringForColumn:</code></li>
<li><code>dateForColumn:</code></li>
<li><code>dataForColumn:</code></li>
<li><code>dataNoCopyForColumn:</code></li>
<li><code>UTF8StringForColumnName:</code></li>
<li><code>objectForColumnName:</code></li>
</ul>

<p>你可以根据列的下标来获取某条记录中某列的值:</p>

<ul>
<li><code>intForColumnIndex:</code></li>
<li><code>longForColumnIndex:</code></li>
<li><code>longLongIntForColumnIndex:</code></li>
<li><code>boolForColumnIndex:</code></li>
<li><code>doubleForColumnIndex:</code></li>
<li><code>stringForColumnIndex:</code></li>
<li><code>dateForColumnIndex:</code></li>
<li><code>dataForColumnIndex:</code></li>
<li><code>dataNoCopyForColumnIndex:</code></li>
<li><code>UTF8StringForColumnNameIndex:</code></li>
<li><code>objectForColumnNameIndex:</code></li>
</ul>

<h3>关闭数据库</h3>

<p>当你完成了数据库的查询和更新,你应该<code>-close</code> 关闭 <code>FMDatabase</code>连接,以释放资源.</p>

<pre><code class="objc">[db close];
</code></pre>

<h3>事务操作</h3>

<p><code>FMDatabase</code> 通过 begin/end 事务语句,来完成事务相关的操作</p>

<h3>批量操作</h3>

<p>你可以施工用 <code>FMDatabase</code>的 <code>executeStatements:withResultBlock:</code> 来执行批量操作:</p>

<pre><code class="objc">NSString *sql = @"create table bulktest1 (id integer primary key autoincrement, x text);"
                 "create table bulktest2 (id integer primary key autoincrement, y text);"
                 "create table bulktest3 (id integer primary key autoincrement, z text);"
                 "insert into bulktest1 (x) values ('XXX');"
                 "insert into bulktest2 (y) values ('YYY');"
                 "insert into bulktest3 (z) values ('ZZZ');";

success = [db executeStatements:sql];

sql = @"select count(*) as count from bulktest1;"
       "select count(*) as count from bulktest2;"
       "select count(*) as count from bulktest3;";

success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
    NSInteger count = [dictionary[@"count"] integerValue];
    XCTAssertEqual(count, 1, @"expected one record for dictionary %@", dictionary);
    return 0;
}];
</code></pre>

<h3>数据净化</h3>

<p>对于一个准备用于FMDB的SQL语句,你不需要自己在插入前执行任何数据净化的操作.而是应该使用标准SQLite的绑定语法:</p>

<pre><code class="sql">INSERT INTO myTable VALUES (?, ?, ?)
</code></pre>

<p>SQLite会将 <code>?</code> 符合识别为一个将要插入的值的占位符.FMDB相关的操作,都支持可变参数,并且会适当转义.</p>

<p>另外,你可以使用命名参数语法:</p>

<pre><code class="sql">INSERT INTO myTable VALUES (:id, :name, :value)
</code></pre>

<p>参数 <em>必须</em> 以 冒号(:) 开头.注意: 你的数据字典里的键, <em>不</em>能包含冒号(:).</p>

<pre><code class="objc">NSDictionary *argsDict = [NSDictionary dictionaryWithObjectsAndKeys:@"My Name", @"name", nil];
[db executeUpdate:@"INSERT INTO myTable (name) VALUES (:name)" withParameterDictionary:argsDict];
</code></pre>

<p>因此,你 <em>不应该</em> 像下面这样去操作:</p>

<pre><code class="objc">[db executeUpdate:[NSString stringWithFormat:@"INSERT INTO myTable VALUES (%@)", @"this has \" lots of ' bizarre \" quotes '"]];
</code></pre>

<p>而是应该这样:</p>

<pre><code class="objc">[db executeUpdate:@"INSERT INTO myTable VALUES (?)", @"this has \" lots of ' bizarre \" quotes '"];
</code></pre>

<p>所有提供给<code>-executeUpdate:</code>方法的参数,都应该是 object-c 对象.下面的代码是无效的,并且会引起崩溃:</p>

<pre><code class="objc">[db executeUpdate:@"INSERT INTO myTable VALUES (?)", 42];
</code></pre>

<p>插入数字,应该使用 <code>NSNumber</code> 对象:</p>

<pre><code class="objc">[db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:42]];
</code></pre>

<p>另外,你也可以使用 <code>-execute*WithFormat:</code>来使用<code>NSString</code> 风格的替换语法:</p>

<pre><code class="objc">[db executeUpdateWithFormat:@"INSERT INTO myTable VALUES (%d)", 42];
</code></pre>

<p><code>-execute*WithFormat:</code> 方法内部将参数转换为合适的类型.仅支持一下占位符: <code>%@</code>, <code>%c</code>, <code>%s</code>, <code>%d</code>, <code>%D</code>, <code>%i</code>, <code>%u</code>, <code>%U</code>, <code>%hi</code>, <code>%hu</code>, <code>%qi</code>, <code>%qu</code>, <code>%f</code>, <code>%g</code>, <code>%ld</code>, <code>%lu</code>, <code>%lld</code>和 <code>%llu</code>. 使用不支持的占位符,将有可能引起崩溃或未定义的行为.如果你需要在SQL语句中使用 <code>%</code>,请使用 <code>%%</code>替代.</p>

<h2>FMDatabaseQueue与线程安全</h2>

<p><strong>不要在多个线程间共用同一个FMDatabase对象</strong></p>

<p>而是,应该使用FMDatabaseQueue.用法如下:</p>

<h3>创建FMDatabaseQueue</h3>

<pre><code class="objc">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];
</code></pre>

<h3>使用FMDatabaseQueue</h3>

<pre><code class="objc">[queue inDatabase:^(FMDatabase *db) {
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];

    FMResultSet *rs = [db executeQuery:@"select * from foo"];
    while ([rs next]) {
        …
    }
}];
</code></pre>

<h3>处理事务型操作</h3>

<pre><code class="objc">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];

    if (whoopsSomethingWrongHappened) {
        *rollback = YES;
        return;
    }
    // 等等...
    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:4]];
}];
</code></pre>

<h2>创建基于block的自定义 SQlite函数.</h2>

<p>你可以使用"makeFunctionNamed:"来实现,下面是 main.m中的一个示例:</p>

<pre><code class="objc">[adb makeFunctionNamed:@"StringStartsWithH" maximumArguments:1 withBlock:^(sqlite3_context *context, int aargc, sqlite3_value **aargv) {
    if (sqlite3_value_type(aargv[0]) == SQLITE_TEXT) {

        @autoreleasepool {

            const char *c = (const char *)sqlite3_value_text(aargv[0]);

            NSString *s = [NSString stringWithUTF8String:c];

            sqlite3_result_int(context, [s hasPrefix:@"h"]);
        }
    }
    else {
        NSLog(@"Unknown formart for StringStartsWithH (%d) %s:%d", sqlite3_value_type(aargv[0]), __FUNCTION__, __LINE__);
        sqlite3_result_null(context);
    }
}];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[FMDB 是SQLite的Objective-C封装库.]]></excerpt:encoded>
		<wp:post_id>299</wp:post_id>
		<wp:post_date>2015-09-06 13:11:08</wp:post_date>
		<wp:post_date_gmt>2015-09-06 05:11:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>fmdb</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="fmdb"><![CDATA[FMDB]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[fmdb-%e6%9b%b4%e5%8f%8b%e5%a5%bd%e5%9c%b0%e6%93%8d%e4%bd%9csqlite%e6%95%b0%e6%8d%ae%e5%ba%93]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>RestKit--更好支持RESTful风格服务器接口的iOS库</title>
		<link>http://www.ios122.com/2015/09/restkit/</link>
		<pubDate>Mon, 14 Sep 2015 07:18:06 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=308</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

<p>RestKit 是一个用于更好支持RESTful风格服务器接口的iOS库,可直接将联网获取的json/xml数据转换为iOS对象.</p>

<ul>
<li>项目主页: <a href="https://github.com/RestKit/RestKit">RestKit</a></li>
<li>最新示例: <a href="https://github.com/RestKit/RestKit/archive/development.zip">点击下载</a></li>
<li>注意: 如果无法直接运行示例根目录的工程,可尝试分别运行 Examples 文件夹下的各个子工程,此时你需要给每个子工程都通过 CocoaPods 安装一次 RestKit.</li>
</ul>

<h1>快速入门</h1>

<h2>使用环境</h2>

<ul>
<li>ARC</li>
<li>iOS 5.1.1 +</li>
</ul>

<h2>安装</h2>

<h3>通过 CocoaPods 安装</h3>

<pre><code class="bash">pod 'RestKit'

# 测试和搜索是可选的组件
pod 'RestKit/Testing'
pod 'RestKit/Search'
</code></pre>

<h2>使用</h2>

<p>在需要的地方,引入头文件:</p>

<pre><code class="objective-c">/* 如果使用CoreData,一定要在引入RestKit前引入CoreData.RestKit中有一些预编译宏是基于CoreData是否已经引入;不提前引入CoreData,RestKit中CoreData相关的功能就无法正常使用. */
#import &lt;CoreData/CoreData.h&gt;
#import &lt;RestKit/RestKit.h&gt;

/* Testing 和 Search 是可选的. */
#import &lt;RestKit/Testing.h&gt;
#import &lt;RestKit/Search.h&gt;
</code></pre>

<p>以下示例展示了RestKit的基本用法,涉及到网络请求的部分已转由iOS122的测试服务器提供模拟数据.示例代码复制到Xcode中,可直接执行.建议自己新建工程,通过CocoaPods安装RestKit测试.</p>

<h3>对象请求</h3>

<pre><code class="objective-c">/**
 *  定义数据模型: Article
 */
@interface Article : NSObject
@property (nonatomic, copy) NSString * title;
@property (nonatomic, copy) NSString * author;
@property (nonatomic, copy) NSString * body;
@end
</code></pre>

<pre><code class="objective-c">// 从/vitural/articles/1234.json获取一篇文章的信息,并把它映射到一个数据模型对象中.
// JSON 内容: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}

RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx 状态.
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/1234.json"]];
RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]];
[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    Article *article = [result firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];
[operation start];
</code></pre>

<h3>管理对象请求</h3>

<pre><code class="objective-c">/* 需要额外引入头文件:#import "RKManagedObjectRequestOperation.h". */

// 从 /vitural/articles/888.json 获取文章和文章标签,并存放到Core Data实体中.
// JSON  数据类似: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!", "categories": [{"id": 1, "name": "Core Data"]}
NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
NSError *error = nil;
BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}

// 如果改了实体结构,注意删除手机或模拟器对应路径的数据库
// 文章和标签,要设置 1 对 多的关联!

NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];

/* 要在Core Data中预定义相关实体. */
RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:managedObjectStore];
[categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore];
[articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
[articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];

NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/888.json"]];

RKManagedObjectRequestOperation *operation = [[RKManagedObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[responseDescriptor]];
operation.managedObjectContext = managedObjectStore.mainQueueManagedObjectContext;
operation.managedObjectCache = managedObjectStore.managedObjectCache;
[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    NSLog(@"Mapped the article: %@", [result firstObject]);

} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];
NSOperationQueue *operationQueue = [NSOperationQueue new];
[operationQueue addOperation:operation];
</code></pre>

<h3>把网络请求的错误信息映射一个到 NSError</h3>

<pre><code class="objective-c">// 获取 /vitural/articles/error.json,返回报头 422 (Unprocessable Entity)
// JSON 内容: {"errors": "Some Error Has Occurred"}

// 你可以将错误映射到任何类,但是通常使用`RKErrorMessage`就够了.
RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
//  包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.
[errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];

NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
// 任意报头状态码为 4xx 的返回值.
RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:statusCodes];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/error.json"]];
RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@ [errorDescriptor]];
[operation setCompletionBlockWithSuccess:nil failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 映射到的iOS错误类的`description`方法用来作为localizedDescription的值
    NSLog(@"Loaded this error: %@", [error localizedDescription]);

    // 你可以通过`NSError`的`userInfo`获取映射后的iOS类的对象.
    RKErrorMessage *errorMessage =  [[error.userInfo objectForKey:RKObjectMapperErrorObjectsKey] firstObject];

    NSLog(@"%@", errorMessage);
}];

[operation start];
</code></pre>

<h3>在对象管理器上集中配置.</h3>

<pre><code class="objective-c">// 设置文章或请求出错时的响应描述.
// 成功时的JSON类似于: {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}
RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];

// 出错时返回的JSON类似: {"errors": "Some Error Has Occurred"}
RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
// 包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.

[errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];
NSIndexSet *errorStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
// 任意报头状态码为 4xx 的返回值.
RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:errorStatusCodes];

// 把响应描述添加到管理器上.
RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[manager addResponseDescriptorsFromArray:@[articleDescriptor, errorDescriptor ]];

// 注意,此处所用的接口已在服务器端设置为随机返回正确或错误的信息,以便于测试.
[manager getObject: nil path:@"/vitural/articles/555.json" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    // 处理请求成功获取的文章.
    Article *article = [mappingResult firstObject];
    NSLog(@"Mapped the article: %@", article);

} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 处理错误信息.
    NSLog(@"%@", error.localizedDescription);
}];
</code></pre>

<h3>在对象管理器中整合CoreData</h3>

<pre><code class="objective-c">/* 配置管理器. */
RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[RKObjectManager setSharedManager: manager];

/* 将管理器与CoreData整合到一起. */
NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];

NSError * error = nil;

BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}
NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];

manager.managedObjectStore = managedObjectStore;

/* 将网络请求的数据存储到CoreData, 要在Core Data中预定义相关实体. */
RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:manager.managedObjectStore];
[categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:manager.managedObjectStore];
[articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
[articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];

NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes];

[manager addResponseDescriptor: responseDescriptor];
[manager getObject: nil path:@"/vitural/articles/888.json" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    // 处理请求成功获取的文章.
    NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    // 处理错误信息.
    NSLog(@"%@", error.localizedDescription);
}];
</code></pre>

<h3>从一个地址获取一组数据</h3>

<pre><code class="objective-c">    // 设置文章或请求出错时的响应描述.
    // 成功时的JSON类似于: [{"article":{"title":"My Article 1","author":"Blake 1","body":"Very cool!! 1"}},{"article":{"title":"My Article 2","author":"Blake 2","body":"Very cool!! 2"}},{"article":{"title":"My Article 3","author":"Blake 3","body":"Very cool!! 3"}},{"article":{"title":"My Article 4","author":"Blake 4","body":"Very cool!! 4"}}]
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles" keyPath:@"article" statusCodes:statusCodes];

    // 出错时返回的JSON类似: {"errors": "Some Error Has Occurred"}
    RKObjectMapping *errorMapping = [RKObjectMapping mappingForClass:[RKErrorMessage class]];
    // 包含错误信息的键对应的值,映射到iOS类的错误信息相关的属性中.

    [errorMapping addPropertyMapping:[RKAttributeMapping attributeMappingFromKeyPath:nil toKeyPath:@"errorMessage"]];
    NSIndexSet *errorStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassClientError);
    // 任意报头状态码为 4xx 的返回值.
    RKResponseDescriptor *errorDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:errorMapping method:RKRequestMethodAny pathPattern:nil keyPath:@"errors" statusCodes:errorStatusCodes];

    // 把响应描述添加到管理器上.
    RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [manager addResponseDescriptorsFromArray:@[articleDescriptor, errorDescriptor ]];

    [manager getObjectsAtPath:@"/vitural/articles" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSArray * articles = [mappingResult array];

        [articles enumerateObjectsUsingBlock:^(Article * article, NSUInteger idx, BOOL *stop) {
            NSLog(@"Mapped the article: %@", article);
        }];

    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];
</code></pre>

<h3>使用队列管理对象请求</h3>

<pre><code class="objective-c">RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];

NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"http://dev-test.ios122.com/vitural/articles/1234.json"]];

    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/1234.json" keyPath:@"article" statusCodes:statusCodes];

RKObjectRequestOperation *operation = [[RKObjectRequestOperation alloc] initWithRequest:request responseDescriptors:@[articleDescriptor]];

[operation setCompletionBlockWithSuccess:^(RKObjectRequestOperation *operation, RKMappingResult *result) {
    Article *article = [result firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];

[manager enqueueObjectRequestOperation:operation]; // 有了这句,就不需要再调用[operation start] 来发起请求了.
[manager cancelAllObjectRequestOperationsWithMethod:RKRequestMethodAny matchingPathPattern:@"/vitural/articles/:articleID\\.json"];
</code></pre>

<h3>新建,更新 与 删除对象.</h3>

<pre><code class="objective-c">RKObjectMapping *responseMapping = [RKObjectMapping mappingForClass:[Article class]];
[responseMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx 状态码
RKResponseDescriptor *articlesDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:responseMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles" keyPath:@"article" statusCodes:statusCodes];

RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:responseMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:id" keyPath:@"article" statusCodes:statusCodes];

RKObjectMapping *requestMapping = [RKObjectMapping requestMapping];

[requestMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

// 将 Article 序列化为NSMutableDictionary ,并以 `article`为键.
RKRequestDescriptor *requestDescriptor = [RKRequestDescriptor requestDescriptorWithMapping:requestMapping objectClass:[Article class] rootKeyPath:@"article" method:RKRequestMethodAny];

RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
[manager addRequestDescriptor:requestDescriptor];
[manager addResponseDescriptor:articlesDescriptor];
[manager addResponseDescriptor:articleDescriptor];

Article *article = [Article new];
article.title = @"Introduction to RestKit";
article.body = @"This is some text.";
article.author = @"Blake";

// POST 创建对象.
[manager postObject: article path:@"/vitural/articles" parameters: nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    /* 这个接口服务器的暂时的逻辑是:把POST过去的数据,原样返回,以确认POST请求成功.*/
        Article *article = [mappingResult firstObject];
        NSLog(@"Mapped the article: %@", article);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        NSLog(@"Failed with error: %@", [error localizedDescription]);
    }];

// PACTH 更新对象.
article.body = @"New Body";
[manager patchObject:article path:@"/vitural/articles/1234" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
    /* 这个接口服务器的暂时的逻辑是:把PACTH过去的数据,原样返回,以确认PATCH请求成功.*/

    Article *article = [mappingResult firstObject];
    NSLog(@"Mapped the article: %@", article);
} failure:^(RKObjectRequestOperation *operation, NSError *error) {
    NSLog(@"Failed with error: %@", [error localizedDescription]);
}];

// DELETE 删除对象.
/* DELETE 操作会影响上面两个接口,最好单独操作. */
//    [manager deleteObject:article path:@"/vitural/articles/1234" parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
//        /* 这个接口服务器的暂时的逻辑是:把DELTE过去的数据,article字段设为空,以确认DELETE请求成功.*/
//
//        Article *article = [mappingResult firstObject];
//        NSLog(@"Mapped the article: %@", article);
//    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
//        NSLog(@"Failed with error: %@", [error localizedDescription]);
//    }];
</code></pre>

<h3>日志设置</h3>

<pre><code class="objective-c">//  记录所有HTTP请求的请求和相应.
RKLogConfigureByName("RestKit/Network", RKLogLevelTrace);

// 记录Core Data 的调试信息.
RKLogConfigureByName("RestKit/CoreData", RKLogLevelDebug);

// 记录block的调用.
RKLogWithLevelWhileExecutingBlock(RKLogLevelTrace, ^{
    // 自定义日志信息.

});
</code></pre>

<h3>配置路由</h3>

<p>路由,提供了URL无关的网络请求调用方式.它是为了在类/某个名字/某个实体联系 与 某个URL建立某种关联,以便再操作某个对象时,只需要告诉RestKit这个对象本身的某些属性就可以直接发送网络请求,而不必每次都去手动拼接 URL.</p>

<pre><code class="objective-c">  /* 设置共享的对象管理器. */
    RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [RKObjectManager setSharedManager: manager];

    /* 将管理器与CoreData整合到一起. */
    NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
    RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];

    NSError * error = nil;

    BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
    if (! success) {
        RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
    }
    NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.
    NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
    if (! persistentStore) {
        RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
    }
    [managedObjectStore createManagedObjectContexts];
    manager.managedObjectStore = managedObjectStore;


    // 响应描述,总是必须的.
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];

    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; // articleID 应为 Article 类的一个属性.
    [manager addResponseDescriptor: articleDescriptor];

    /* 类的路由.配置后,操作某个类时,会自动向这个类对应的地址发送请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];

    /*  发起请求. */
    Article * article = [[Article alloc] init];
    article.articleID = @"888"; // articleId 属性必须给,以拼接地址路由中缺少的部分.

    // 因为配置了路由,所以此处不必再传 path 参数.
    [manager getObject: article path:nil parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];


    /* 关系路由: 使用CoreData实体间关系命名的路由.*/
    /* 仅在测试CoreData关系路由时,才需要把下面一段的代码注释打开. */
//    RKEntityMapping *categoryMapping = [RKEntityMapping mappingForEntityForName:@"Category" inManagedObjectStore:manager.managedObjectStore];
//    
//    [categoryMapping addAttributeMappingsFromDictionary:@{ @"id": @"categoryID", @"name": @"name" }];
//    RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:manager.managedObjectStore];
//    [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];
//    [articleMapping addPropertyMapping:[RKRelationshipMapping relationshipMappingFromKeyPath:@"categories" toKeyPath:@"categories" withMapping:categoryMapping]];
//    
//    NSIndexSet *coreDataStatusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任何 2xx的状态码
//    RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:articleMapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:coreDataStatusCodes];
//    
//    [manager addResponseDescriptor: responseDescriptor];

    [manager.router.routeSet addRoute:[RKRoute routeWithRelationshipName:@"categories" objectClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];

    [manager getObjectsAtPathForRelationship:@"categories" ofObject:article parameters:nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {

        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);

    } failure:^(RKObjectRequestOperation *operation, NSError *error) {

        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];

    /* 被命名的路由,可以根据路由名字发起相关请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithName:@"article_review" pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];

    [manager getObjectsAtPathForRouteNamed: @"article_review" object:article parameters: nil success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        // 处理请求成功获取的文章.
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        // 处理错误信息.
        NSLog(@"%@", error.localizedDescription);
    }];
</code></pre>

<h3>POST 新建一个含有文件附件的对象.</h3>

<pre><code class="objective-c">  RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];
    [RKObjectManager setSharedManager: manager];

    /* 响应描述,总是必须的. */
    RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];

    [mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

    NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful); // 任意 2xx 状态码.

    RKResponseDescriptor *articleDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping method:RKRequestMethodAny pathPattern:@"/vitural/articles/:articleID" keyPath:@"article" statusCodes:statusCodes]; // articleID 应为 Article 类的一个属性.
    [manager addResponseDescriptor: articleDescriptor];

    /* 类的路由.配置后,操作某个类时,会自动向这个类对应的地址发送请求. */
    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodPOST]];

    Article *article = [[Article alloc]init];
    article.articleID = @"666";

    UIImage *image = [UIImage imageNamed:@"test.jpg"]; // 工程中要确实存在一张名为 test.jpg 的照片.

    // 序列化对象属性,以添加附件.
    NSMutableURLRequest *request = [[RKObjectManager sharedManager] multipartFormRequestWithObject:article method:RKRequestMethodPOST path:nil parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) {
        [formData appendPartWithFileData:UIImagePNGRepresentation(image)
                                    name:@"myImg" // 这个字段要和服务器取文件的字段一致.
                                fileName:@"photo.jpg"
                                mimeType:@"image/jpeg"];
    }];

    RKObjectRequestOperation *operation = [[RKObjectManager sharedManager] objectRequestOperationWithRequest:request success:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {
        /* 服务器端接口目前自定义的逻辑是: 成功后,会返回图片上传后的服务器地址. */
        NSLog(@"Mapped the article: %@", [mappingResult firstObject]);
    } failure:^(RKObjectRequestOperation *operation, NSError *error) {
        NSLog(@"%@", error.localizedDescription);
    }];

    [[RKObjectManager sharedManager] enqueueObjectRequestOperation:operation]; // 注意:要用enqueued,不要使用 started方法.
</code></pre>

<h3>以队列方式批量处理对像请求.</h3>

<pre><code class="objective-c"><br />    RKObjectManager *manager = [RKObjectManager managerWithBaseURL:[NSURL URLWithString:@"http://dev-test.ios122.com"]];

    Article * articleA = [[Article alloc] init];
    articleA.articleID = @"888";

    Article * articleB = [[Article alloc] init];
    articleB.articleID = @"1234";

    Article * articleC = [[Article alloc] init];
    articleC.articleID = @"555";

    /* 以队列方式,发送多个请求. */

    [manager.router.routeSet addRoute:[RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodGET]];

    RKRoute * route = [RKRoute routeWithClass:[Article class] pathPattern:@"/vitural/articles/:articleID\\.json" method:RKRequestMethodPOST];

    [manager enqueueBatchOfObjectRequestOperationsWithRoute:route
                                                    objects:@[articleA, articleB, articleC]
                                                   progress:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {
                                                       NSLog(@"完成了 %lu 个操作", (unsigned long)numberOfFinishedOperations);
                                                   } completion:^ (NSArray *operations) {
                                                       NSLog(@"所有的文章都已获取!");
                                                   }];
</code></pre>

<h3>制作一个种子数据库.</h3>

<p>可以将一个JSON文件转化为一个数据库,用于初始化应用.</p>

<pre><code class="objective-c">NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
    RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
    NSError *error = nil;
    BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
    if (! success) {
        RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
    }

    NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"RestKit.sqlite"]; // 此处要和自己的CoreData数据库的名字一致.

    NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
    if (! persistentStore) {
        RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
    }
    [managedObjectStore createManagedObjectContexts];

    RKEntityMapping *articleMapping = [RKEntityMapping mappingForEntityForName:@"Article" inManagedObjectStore:managedObjectStore];
    [articleMapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

    NSString *seedPath = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"MySeedDatabase.sqlite"]; // 这个数据库文件不必存在,用来充当应用的初始数据库.
    RKManagedObjectImporter *importer = [[RKManagedObjectImporter alloc] initWithManagedObjectModel:managedObjectStore.managedObjectModel storePath:seedPath];

    //  使用 RKEntityMapping 从工程文件 "articles.json" 导入数据.
    // JSON 类似于: {"articles": [ {"title": "Article 1", "body": "Text", "author": "Blake" ]}

    error = nil;

    NSBundle *mainBundle = [NSBundle mainBundle];
    [importer importObjectsFromItemAtPath:[mainBundle pathForResource:@"articles" ofType:@"json"] // 工程中要有这个文件.
                              withMapping:articleMapping
                                  keyPath:@"articles"
                                    error:&amp;error];

    success = [importer finishImporting:&amp;error];

    if (success) {
        [importer logSeedingInfo];
    }
</code></pre>

<h3>给实体添加索引并检索</h3>

<pre><code class="objective-c">// 要额外添加头文件: #import &lt;RestKit/Search.h&gt;

NSManagedObjectModel *managedObjectModel = [NSManagedObjectModel mergedModelFromBundles:nil];
RKManagedObjectStore *managedObjectStore = [[RKManagedObjectStore alloc] initWithManagedObjectModel:managedObjectModel];
NSError *error = nil;
BOOL success = RKEnsureDirectoryExistsAtPath(RKApplicationDataDirectory(), &amp;error);
if (! success) {
    RKLogError(@"Failed to create Application Data Directory at path '%@': %@", RKApplicationDataDirectory(), error);
}
NSString *path = [RKApplicationDataDirectory() stringByAppendingPathComponent:@"Store.sqlite"];
NSPersistentStore *persistentStore = [managedObjectStore addSQLitePersistentStoreAtPath:path fromSeedDatabaseAtPath:nil withConfiguration:nil options:nil error:&amp;error];
if (! persistentStore) {
    RKLogError(@"Failed adding persistent store at path '%@': %@", path, error);
}
[managedObjectStore createManagedObjectContexts];
[managedObjectStore addSearchIndexingToEntityForName:@"Article" onAttributes:@[ @"title", @"body" ]];
[managedObjectStore addInMemoryPersistentStore:nil];
[managedObjectStore createManagedObjectContexts];
[managedObjectStore startIndexingPersistentStoreManagedObjectContext];

Article *article1 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext];
article1.title = @"First Article";
article1.body = "This should match search";

Article *article2 = [NSEntityDescription insertNewObjectForEntityForName:@"Article" inManagedObjectContext:managedObjectStore.mainQueueManagedObjectContext];
article2.title = @"Second Article";
article2.body = "Does not";

BOOL success = [managedObjectStore.mainQueueManagedObjectContext saveToPersistentStore:nil];

RKSearchPredicate *predicate = [RKSearchPredicate searchPredicateWithText:@"Match" type:NSAndPredicateType];
NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Article"];
fetchRequest.predicate = predicate;

// Contains article1 due to body text containing 'match'
NSArray *matches = [managedObjectStore.mainQueueManagedObjectContext executeFetchRequest:fetchRequest error:nil];
NSLog(@"Found the matching articles: %@", matches);
</code></pre>

<h3>对映射进行单元测试</h3>

<pre><code class="objective-c">// JSON looks like {"article": {"title": "My Article", "author": "Blake", "body": "Very cool!!"}}
RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[Article class]];
[mapping addAttributeMappingsFromArray:@[@"title", @"author", @"body"]];

NSDictionary *article = @{ @"article": @{ @"title": @"My Title", @"body": @"The article body", @"author": @"Blake" } };
RKMappingTest *mappingTest = [[RKMappingTest alloc] initWithMapping:mapping sourceObject:article destinationObject:nil];

[mappingTest expectMappingFromKeyPath:@"title" toKeyPath:@"title" value:@"My Title"];
[mappingTest performMapping];
[mappingTest verify];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[RestKit 是一个用于更好支持RESTful风格服务器接口的iOS库,可直接将联网获取的json/xml数据转换为iOS对象.]]></excerpt:encoded>
		<wp:post_id>308</wp:post_id>
		<wp:post_date>2015-09-14 15:18:06</wp:post_date>
		<wp:post_date_gmt>2015-09-14 07:18:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>restkit</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="restkit"><![CDATA[RestKit]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[restkit-%e6%9b%b4%e5%a5%bd%e6%94%af%e6%8c%81restful%e9%a3%8e%e6%a0%bc%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%8e%a5%e5%8f%a3%e7%9a%84ios%e5%ba%93]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>SVProgressHUD--比MBProgressHUD更好用的 iOS进度提示组件</title>
		<link>http://www.ios122.com/2015/09/svprogresshud/</link>
		<pubDate>Tue, 15 Sep 2015 07:29:36 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=310</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

<p><img src="http://f.cl.ly/items/2G1F1Z0M0k0h2U3V1p39/SVProgressHUD.gif" alt="SVProgressHUD" /></p>

<p><code>SVProgressHUD</code>是简单易用的显示器,用于指示一个持续进行的任务的进度.</p>

<ul>
<li>项目主页: <a href="https://github.com/TransitApp/SVProgressHUD">SVProgressHUD</a></li>
<li>最新示例: <a href="https://github.com/TransitApp/SVProgressHUD/archive/master.zip">点击下载</a></li>
</ul>

<h1>快速入门</h1>

<h2>安装</h2>

<h3>通过Cocoapods</h3>

<pre><code class="ruby">pod 'SVProgressHUD'
</code></pre>

<h3>手动安装</h3>

<ul>
<li>拖拽 <code>SVProgressHUD/SVProgressHUD</code> 文件 到你的项目.</li>
<li>注意把 <code>SVProgressHUD.bundle</code> 添加进 <code>Targets-&gt;Build Phases-&gt;Copy Bundle Resources</code>.</li>
<li>添加 <strong>QuartzCore</strong> framework 到你的项目.</li>
</ul>

<h2>使用</h2>

<p>(参见Xcode项目文档 <code>/Demo</code>)</p>

<p><code>SVProgressHUD</code> 作为一个单例（也就是说，它并不需要创建和实例化，你直接调用, 如<code>[SVProgressHUD method]</code>).</p>

<p><strong>使用<code>SVProgressHUD</code>是非常明智的！常用场景：下拉刷新，无限滚动，发送消息</strong></p>

<p>使用<code>SVProgressHUD</code>在您的应用程序通常看起来简单:</p>

<pre><code class="objective-c">[SVProgressHUD show];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // time-consuming task
    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD dismiss];
    });
});
</code></pre>

<h3>显示 HUD</h3>

<p>您可以使用下面的方法中的任意一个来显示HUD,以及指示任务的状态：</p>

<pre><code class="objective-c">+ (void)show;
+ (void)showWithStatus:(NSString*)string;
</code></pre>

<p>如果您想在HUD指示任务的进度，请使用下列操作之一：</p>

<pre><code class="objective-c">+ (void)showProgress:(CGFloat)progress;
+ (void)showProgress:(CGFloat)progress status:(NSString*)status;
</code></pre>

<h3>隐藏 HUD</h3>

<p>HUD可以用以下方法隐藏:</p>

<pre><code class="objective-c">+ (void)dismiss;
+ (void)dismissWithDelay:(NSTimeInterval)delay;
</code></pre>

<p>如果你想显示多个HUD ，可以使用使用一下方法：</p>

<pre><code class="objective-c">+ (void)popActivity;
</code></pre>

<p>该HUD将自动消失, <code>popActivity</code>将与显示的次数匹配。</p>

<h3>显示一个提示消息</h3>

<p>也可以用于显示一个提示信息。所述显示时间取决于给定的字符串的长度（ 0.5至5秒）。</p>

<pre><code class="objective-c">+ (void)showInfoWithStatus:(NSString *)string;
+ (void)showSuccessWithStatus:(NSString*)string;
+ (void)showErrorWithStatus:(NSString *)string;
+ (void)showImage:(UIImage*)image status:(NSString*)string;
</code></pre>

<h3>自定义</h3>

<p><code>SVProgressHUD</code> 可通过下列方法进行个性化定制:</p>

<pre><code class="objective-c">+ (void)setDefaultStyle:(SVProgressHUDStyle)style;                  // 默认是SVProgressHUDStyleLight
+ (void)setDefaultMaskType:(SVProgressHUDMaskType)maskType;         // 默认是SVProgressHUDMaskTypeNone
+ (void)setDefaultAnimationType:(SVProgressHUDAnimationType)type;   // 默认是 SVProgressHUDAnimationTypeFlat
+ (void)setRingThickness:(CGFloat)width;                            // 默认是 2 pt
+ (void)setCornerRadius:(CGFloat)cornerRadius;                      // 默认是 14 pt
+ (void)setFont:(UIFont*)font;                                      // 默认是 [UIFont preferredFontForTextStyle:UIFontTextStyleSubheadline]
+ (void)setForegroundColor:(UIColor*)color;                         // 默认是 [UIColor blackColor], 仅对 SVProgressHUDStyleCustom 有效
+ (void)setBackgroundColor:(UIColor*)color;                         // 默认是 [UIColor whiteColor], 仅对 SVProgressHUDStyleCustom 有效
+ (void)setInfoImage:(UIImage*)image;                               //默认是bundle文件夹中的提示图片.
+ (void)setSuccessImage:(UIImage*)image;                            // 默认是bundle文件夹中的成功图片.
+ (void)setErrorImage:(UIImage*)image;                              // 默认是bundle文件夹中的错误图片.
+ (void)setViewForExtension:(UIView*)view;                          // 默认是nil,仅当设置了 #define SV_APP_EXTENSIONS 时有效.
</code></pre>

<h3>通知</h3>

<p><code>SVProgressHUD</code>通过<code>NSNotificationCenter</code> 注册4份通知,以响应正在显示/消失:
* <code>SVProgressHUDWillAppearNotification</code> 提示框即将出现
* <code>SVProgressHUDDidAppearNotification</code> 提示框已经出现
* <code>SVProgressHUDWillDisappearNotification</code> 提示框即将消失
* <code>SVProgressHUDDidDisappearNotification</code> 提示框已经消失</p>

<p>每个通知传递一个<code>userInfo</code>字典,字典中包含HUD的状态字符串（如果有的话） ，可通过<code>SVProgressHUDStatusUserInfoKey</code>作为键来获取。</p>

<p><code>SVProgressHUD</code>还发送通知: 
<code>SVProgressHUDDidReceiveTouchEventNotification</code>当用户触摸整体屏幕上 和
' SVProgressHUDDidTouchDownInsideNotification<code>当用户直接在HUD接触。这两个通知没有</code> userInfo<code>参数，但包含了有关的触摸的</code>UIEvent` 参数.</p>

<h3>App 扩展(App Extension)</h3>

<p>当在应用程序中使用<code>SVProgressHUD</code>时， 要定义常量 <code>#define  SV_APP_EXTENSIONS</code>避免使用不可用的API。然后从你的扩展视图控制器中通过<code>self.view</code> 调用<code>setViewForExtension:</code> 即可。
注意: 此处指的是"App Extension",不是类目."File->New->Target...-> iOS -> App Extension->Photo Editing Extension". 如果未用到,可忽略.  更多细节参考: <a href="https://github.com/TransitApp/SVProgressHUD/issues/390">https://github.com/TransitApp/SVProgressHUD/issues/390</a></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>310</wp:post_id>
		<wp:post_date>2015-09-15 15:29:36</wp:post_date>
		<wp:post_date_gmt>2015-09-15 07:29:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>svprogresshud</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="svprogresshud"><![CDATA[SVProgressHUD]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[svprogresshud-%e6%af%94mbprogresshud%e6%9b%b4%e5%a5%bd%e7%94%a8%e7%9a%84-ios%e8%bf%9b%e5%ba%a6%e6%8f%90%e7%a4%ba%e7%bb%84%e4%bb%b6]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[iOS提示框,为什么你应该使用 MBProgressHUD? | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/09/mbprogresshud_need/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-09-17 18:52:54</wp:comment_date>
			<wp:comment_date_gmt>2015-09-17 10:52:54</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] SVProgressHUD&#8211;比MBProgressHUD更好用的 iOS进度提示组件 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1442487892.2809131145477294921875;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1442487174.9679400920867919921875;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1442487174]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>iOS提示框,为什么你应该使用 MBProgressHUD?</title>
		<link>http://www.ios122.com/2015/09/mbprogresshud_need/</link>
		<pubDate>Thu, 17 Sep 2015 10:52:52 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=316</guid>
		<description></description>
		<content:encoded><![CDATA[<p>这是一篇带有一定笔者主观感情色彩的比较文章.文章着重对比github上最流行的两个iOS进度提示控件 MBProgressHUD 与 SVProgressHUD的各自优劣,来帮助初学者找到一个适合的iOS提示框解决方案.</p>

<h2>无论如何,你总是需要一个提示框.</h2>

<p>提示框,进度提示,加载中提示等等,无论怎样,你总是需要提示框来指示某个状态正在后台努力进行中.一个合适的提示框,更多的是用来增强用户体验.把最多的时间,用来做更核心的事;把这些不是非常重要的事,你应该试着使用一个成熟稳定的第三方来解决.</p>

<h2>MBProgressHUD 还是 SVProgressHUD ?</h2>

<p>许多时候,选择都是很重要的,但是总是要做出选择.每个人考虑的因素和角度不同,结论或许也不同.但是,你要明白,你现在是要找一个合适的方案来解决自己的关于"提示框"的需求,而不是去无意义的讨论与分析.我推荐你使用 MBProgressHUD. 如果你只是想找一个答案,看到这里就够了.下面会进行一些对比分析.有时候,罗列一些可选答案,总是让人感觉很舒服的;但是我们最终都要做出选择,表明自己的态度.就像你可以依然坚持自己的看法,我会依然深度使用 MBProgressHUD一样.下面的分析不是要证明 MBProgressHUD 或 SVProgressHUD 谁好或者不好,更多的只是为了说明,我的选择可能不是最佳的,但还是靠点谱的!</p>

<h3>github 流行度: MBProgressHUD - SVProgressHUD = 2500</h3>

<p>截止目前, MBProgressHUD 的关注度为 8556, SVProgressHUD 的关注度为 6003,差额在 2500左右.github上面的流行度是很能说明两个第三方的相对优劣的,这就像各个书店上图书的购买量和评论量总是和一本书的价值成正相关一样!诚然, MBProgressHUD 和 SVProgressHUD 的关注度都是非常高的了,都已经属于非常流行的 iOS 第三方了.但是,既然我要选一个深度使用,肯定是关注度更高的那个!在大多数时候,我相信"大家"的选择,对自己是可有参考价值的!</p>

<h3>接口易用性: MBProgressHUD == SVProgressHUD</h3>

<p>以下是MBProgressHUD 和 SVProgressHUD 各自项目的github主页上,各自的基本用法示例:</p>

<pre><code class="objective-c">[MBProgressHUD showHUDAddedTo:self.view animated:YES];
dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
    // Do something...
    dispatch_async(dispatch_get_main_queue(), ^{
        [MBProgressHUD hideHUDForView:self.view animated:YES];
    });
});
</code></pre>

<pre><code class="objective-c">[SVProgressHUD show];
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // time-consuming task
    dispatch_async(dispatch_get_main_queue(), ^{
        [SVProgressHUD dismiss];
    });
});
</code></pre>

<p>在大多数场景中,你几乎只会用到<code>显示</code>与<code>隐藏</code>这两个最基本的方法,所以说,尽管 SVProgressHUD 自称更加易用,但是我还是认为这真的看不出什么优势.</p>

<h3>接口丰富性: MBProgressHUD >> SVProgressHUD</h3>

<p>MBProgressHUD 和 SVProgressHUD 都支持简单的进度提示和文字提示.单从各自github主页上来看, SVProgressHUD 似乎拥有更多的接口,但是事实并非如此.如果你下载过MBProgressHUD的示例就会发现,它能实现的功能要远远多于 文档示例给出的简单的 <code>显示</code> 与 <code>隐藏</code>.为了能让大家更多的了解MBProgressHUD,列出部分方法与参数常量,具体信息可参考官方示例:</p>

<pre><code class="objective-c">/**
 * 创建一个新的HUD,并把它添加并显示到提供的视图上.与之相对应的方法是 hideHUDForView:animated:.
 *
 * @note 这个方法会设置HUD的属性`removeFromSuperViewOnHide`为YES.HUD会在隐藏时自动从父视图上移除.
 *
 * @param view 将HUD添加到此视图上.
 * @param animated YES,显示时使用当前的动画类型显示;NO,直接显示不使用动画效果.
 * @return 新创建的HUD.
 *
 * @see hideHUDForView:animated:
 * @see animationType
 */
+ (MB_INSTANCETYPE)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;

/**
 * 找到并隐藏子视图最顶层的HUD.与之对应的方法是 showHUDAddedTo:animated:.
 *
 * @note 这个方法会设置HUD的属性`removeFromSuperViewOnHide`为YES.HUD会在隐藏时自动从父视图上移除.
 *
 * @param view 用来在其子视图中查找HUD的视图.
 * @param animated YES,隐藏时使用当前的动画类型显示;NO,直接隐藏不使用动画效果.
 * @return YES,如果某个HUD被找到并被移除;否则返回NO.
 *
 * @see showHUDAddedTo:animated:
 * @see animationType
 */
+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;

/**
 * 找到子视图中所有的HUD,并隐藏.
 *
 * @note 这个方法会设置HUD的属性`removeFromSuperViewOnHide`为YES.HUD会在隐藏时自动从父视图上移除.
 *
 * @param view 用来在其子视图中查找HUD的视图.
 * @param animated YES,隐藏时使用当前的动画类型显示;NO,直接隐藏不使用动画效果.
 * @return 找到并移除的HUD的数量.
 *
 * @see hideHUDForView:animated:
 * @see animationType
 */
+ (NSUInteger)hideAllHUDsForView:(UIView *)view animated:(BOOL)animated;

/**
 * 找到并返回子视图最顶层的HUD.
 *
 * @param view 用来在其子视图中查找HUD的视图.
 * @return 子视图最顶层的HUD.
 */
+ (MB_INSTANCETYPE)HUDForView:(UIView *)view;

/**
 * 找到并返回子视图中所有的HUD.
 *
 * @param view 用来在其子视图中查找HUD的视图.
 * @return 所有找到的HUD视图(存储 MBProgressHUD 对象的数组).
 */
+ (NSArray *)allHUDsForView:(UIView *)view;

/**
 * 使用屏幕尺寸创建HUD的便利初始化方法. 
 *
 * @param window 提供边框值以初始化HUD的窗口.应该和HUD未来的父视图相同(比如,创建 HUD 后,将HUD添加到此窗口上).
 */
- (id)initWithWindow:(UIWindow *)window;

/**
 * 使用指定视图的边框尺寸创建HUD的便利初始化方法. 
 *
 * @param view 提供边框值以初始化HUD的视图.应该和HUD未来的父视图相同(比如,创建 HUD 后,将HUD添加到此视图上).
 */
- (id)initWithView:(UIView *)view;

/** 
 * 显示HUD.你需要确保调用此方法时,主线程未被其他任务阻塞,以便于更新视图.当你已经在新的线程中开始(比如,使用NSOperation或者NSURLRequest的异步请求等)执行某个任务后,再执行此方法. 
 *
 * @param animated YES,显示时使用当前的动画类型显示;NO,直接显示不使用动画效果. *
 * @see animationType
 */
- (void)show:(BOOL)animated;

/** 
 * 隐藏HUD.这个仍然会去尝试调用代理的hudWasHidden:方法.此方法是 show: 的配对方法.当你的任务完成时,再使用它. 
 *
 * @param animated YES,隐藏时使用当前的动画类型显示;NO,直接隐藏不使用动画效果.
 *
 * @see animationType
 */
- (void)hide:(BOOL)animated;

/** 
 *  延时隐藏HUD.这个仍然会去尝试调用代理的hudWasHidden:方法.此方法是 show: 的配对方法.当你的任务完成时,再使用它.  
 *  *
 * @param animated YES,隐藏时使用当前的动画类型显示;NO,直接隐藏不使用动画效果.
 * @param delay Delay in seconds until the HUD is hidden.
 *
 * @see animationType
 */
- (void)hide:(BOOL)animated afterDelay:(NSTimeInterval)delay;

/** 
 * 当在新线程执行某个后台任务时,显示HUD;任务完成时,自动隐藏HUD.
 *
 * 这个方法会处理自动释放池的相关技术细节,所以你可以安全使用它.
 *
 * @param method HUD显示期间,被执行的方法.这个方法会在一个新的线程中执行.
 * @param target HUD显示期间,被调用的方法归属的实例对象.
 * @param object 用来传递给方法的可选对象.
 * @param animated YES,HUD使用当前的 animationType 动画类型来显示或隐藏;否则,显示或隐藏时不使用动画效果.
 * animations while (dis)appearing.
 */
- (void)showWhileExecuting:(SEL)method onTarget:(id)target withObject:(id)object animated:(BOOL)animated;

#if NS_BLOCKS_AVAILABLE

/**
 * 当在后台队列中执行block时,显示HUD;并在block执行完毕后,隐藏HUD.
 *
 * @see showAnimated:whileExecutingBlock:onQueue:completionBlock:
 */
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block;

/**
 * 当在后台队列中执行block时,显示HUD;并在block执行完毕后,隐藏HUD.
 *
 * @see showAnimated:whileExecutingBlock:onQueue:completionBlock:
 */
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block completionBlock:(MBProgressHUDCompletionBlock)completion;

/**
 * 当在后台队列中执行block时,显示HUD;并在block执行完毕后,隐藏HUD.
 *
 * @see showAnimated:whileExecutingBlock:onQueue:completionBlock:
 */
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(dispatch_queue_t)queue;

/** 
 * 当在一个指定的队列中执行block时,显示HUD;block执行完毕后在主线程执行completion block;然后隐藏HUD.
 *
 * @param animated YES,HUD使用当前的 animationType 动画类型来显示或隐藏;否则,显示或隐藏时不使用动画效果.
 * @param block HUD显示期间执行的block.
 * @param queue block在此队列中执行.
 * @param completion 完成时执行的block.
 *
 * @see completionBlock
 */
- (void)showAnimated:(BOOL)animated whileExecutingBlock:(dispatch_block_t)block onQueue:(dispatch_queue_t)queue
          completionBlock:(MBProgressHUDCompletionBlock)completion;
</code></pre>

<h3>接口灵活性和可扩展性: MBProgressHUD > SVProgressHUD</h3>

<p>首先,二者都是开放源代码的,如果有特殊需求,可以完全自主定制;所以这里主要讨论的是 MBProgressHUD 和 SVProgressHUD自身在不修改核心代码的前提下的接口灵活性和可扩展性.同样的但从文档来看, SVProgressHUD 表现出更多的灵活性,参见: <a href="http://www.ios122.com/2015/09/svprogresshud/">SVProgressHUD–比MBProgressHUD更好用的 iOS进度提示组件</a>.但是事实并非如此! MBProgressHUD 入门文档相对很少提及其灵活性,但其提供的DEMO中较完整地展示了它的强大之处.个人认为,单单允许使用自定义视图作为提供框的视图这一点,就足以让SVProgressHUD 的绝大部分特性黯然失色;这也是我最终决定选定 MBProgressHUD 并深入使用 MBProgressHUD的重要原因.初次之外, MBProgressHUD 还支持自定义部分进度条相关的属性.具体细节如下:</p>

<pre><code>@interface MBProgressHUD : UIView
/**
 * HUD完全隐藏后执行的block.
 */
@property (copy) MBProgressHUDCompletionBlock completionBlock;

/** 
 * MBProgressHUD 操作模式. 默认是 MBProgressHUDModeIndeterminate.
 *
 * @see MBProgressHUDMode
 */
@property (assign) MBProgressHUDMode mode;

/**
 * HUD显示和隐藏时使用的动画类型.
 *
 * @see MBProgressHUDAnimation
 */
@property (assign) MBProgressHUDAnimation animationType;

/**
 * HUD处于MBProgressHUDModeCustomView模式时,显示此自定义视图(比如一个 UIImageView).
 * 最好设置自定义视图宽高为 37x37(这是HUD内建指示器的边框值).
 */
@property (MB_STRONG) UIView *customView;

/** 
 * HUD代理对象.
 *
 * @see MBProgressHUDDelegate
 */
@property (MB_WEAK) id&lt;MBProgressHUDDelegate&gt; delegate;

/** 
 *状态指示器下可选显示的短消息.HUD会自动调整文字的尺寸. 如果文字过长,后面会用"..."代替.
  */
@property (copy) NSString *labelText;

/** 
 * 可选显示在labelText的细节文字信息.支持多行显示.
 */
@property (copy) NSString *detailsLabelText;

/** 
 * HUD的不透明度.默认是0.8.
 */
@property (assign) float opacity;

/**
 * HUD的颜色.默认黑色.设置此值后, opacity属性的值将不再使用,因为颜色也可以设置透明度.
 */
@property (MB_STRONG) UIColor *color;

/** 
 * HUD相对于父视图中心点的水平偏移量.
 */
@property (assign) float xOffset;

/** 
 * HUD相对于父视图中心点的垂直偏移量.
 */
@property (assign) float yOffset;

/**
 * HUD边缘与HUD的元素之间(比如标签,指示器,自定义视图等)的空白距离. 
 * 默认 20.0
 */
@property (assign) float margin;

/**
 * HUD圆角半径,默认10.0.
 */
@property (assign) float cornerRadius;

/** 
 * 是否给父视图添加一个放射线样式的遮罩层.默认NO.
 */
@property (assign) BOOL dimBackground;

/*
 * 用于指定某个方法执行一段时间之后再显示HUD,以秒记.如果方法在这段时间之前就执行完成,就不再显示HUD. 
 * 这主要是为了优化耗时可能极短的任务的体验.
 * 默认值为 0.
 * 这个属性仅在可以任务的状态可以知晓时,才有作用.
 * @see taskInProgress
 */
@property (assign) float graceTime;

/**
 * HUD显示的最小时间(以秒记.)
 * 这可以避免HUD刚一显示立即又隐藏所带来的不好的用户体验.
 * 默认是 0.
 */
@property (assign) float minShowTime;

/**
 * 指示被执行的操作是否还在执行. graceTime 属性依赖于这个属性.
 * 如果你没有设置graceTime(和设置为0.0不同),这个属性没有任何作用.
 * 当使用showWhileExecuting:onTarget:withObject:animated:时,这个值会被自动设置.
 * 当直接使用show:或hide:等方法显示或隐藏HUD时,你应该手动设置taskInProgress 属性的值,以保证 graceTime 能正确发挥作用.
 */
@property (assign) BOOL taskInProgress;

/**
 * HUD隐藏时,是否从父视图中移除.
 * 默认 NO. 
 */
@property (assign) BOOL removeFromSuperViewOnHide;

/** 
 * 用于主标签的字体值.
 */
@property (MB_STRONG) UIFont* labelFont;

/**
 * 主标签颜色值.
 */
@property (MB_STRONG) UIColor* labelColor;

/**
 * 详情标签字体值.
 */
@property (MB_STRONG) UIFont* detailsLabelFont;

/** 
 * 详情标签颜色.
 */
@property (MB_STRONG) UIColor* detailsLabelColor;

/**
 * 指示器颜色.默认 [UIColor whiteColor]
 */
@property (MB_STRONG) UIColor *activityIndicatorColor;

/** 
 * 进度指示器的颜色,可选 0.0 ~ 1.0,默认0.0.
 */
@property (assign) float progress;

/**
 * HUD面板的最小尺寸.默认 CGSizeZero.
 */
@property (assign) CGSize minSize;


/**
 *  HUD面板的实际尺存,只读.
 *  你可以使用它来限制HUD的可点击区域.
 * @see https://github.com/jdg/MBProgressHUD/pull/200
 */
@property (atomic, assign, readonly) CGSize size;


/**
 * 是否强制设置HUD为正方形,默认NO.
 */
@property (assign, getter = isSquare) BOOL square;

@end


@protocol MBProgressHUDDelegate &lt;NSObject&gt;

@optional

/** 
 * HUD完全从屏幕中隐藏时调用此方法.
 */
- (void)hudWasHidden:(MBProgressHUD *)hud;

@end


/**
 * 一个饼状图样式的进图指示视图.
 */
@interface MBRoundProgressView : UIView 

/**
 * 进度 (0.0 to 1.0)
 */
@property (nonatomic, assign) float progress;

/**
 * 进度指示器颜色.默认 [UIColor whiteColor].
 */
@property (nonatomic, MB_STRONG) UIColor *progressTintColor;

/**
 * 进度指示的背景部分的颜色.
 * 默认白色半透(透明度0.1)
 */
@property (nonatomic, MB_STRONG) UIColor *backgroundTintColor;

/*
 * 显示模式.NO,圆形;YES,环形.默认圆形.
 */
@property (nonatomic, assign, getter = isAnnular) BOOL annular;

@end


/**
 * 一个水平进度条视图. 
 */
@interface MBBarProgressView : UIView

/**
 * 进度 (0.0 to 1.0)
 */
@property (nonatomic, assign) float progress;

/**
 * 进度条边框线的颜色.
 * 默认白色 [UIColor whiteColor].
 */
@property (nonatomic, MB_STRONG) UIColor *lineColor;

/**
 * 进度条背景色.
 * 默认是 [UIColor clearColor];
 */
@property (nonatomic, MB_STRONG) UIColor *progressRemainingColor;

/**
 * 进度的颜色.
 * 默认 [UIColor whiteColor].
 */
@property (nonatomic, MB_STRONG) UIColor *progressColor;

@end
</code></pre>

<h2>结论</h2>

<p>总而言之, 不管你开发什么应用,你总是需要一个MBProgressHUD,而我真的推荐你使用 MBProgressHUD.官方文档对MBProgressHUD的具体功能提的过于精简,希望能借助这篇文章,能让大家一起更全面的认识 MBProgressHUD.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[这是一篇带有一定笔者主观感情色彩的比较文章.文章着重对比github上最流行的两个iOS进度提示控件 MBProgressHUD 与 SVProgressHUD的各自优劣,来帮助初学者找到一个适合的iOS提示框解决方案.]]></excerpt:encoded>
		<wp:post_id>316</wp:post_id>
		<wp:post_date>2015-09-17 18:52:52</wp:post_date>
		<wp:post_date_gmt>2015-09-17 10:52:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mbprogresshud_need</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mbprogresshud"><![CDATA[MBProgressHUD]]></category>
		<category domain="post_tag" nicename="svprogresshud"><![CDATA[SVProgressHUD]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Masonry -- 使用纯代码进行iOS应用的autolayout自适应布局</title>
		<link>http://www.ios122.com/2015/09/masonry/</link>
		<pubDate>Mon, 21 Sep 2015 09:02:51 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=319</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>简介</h1>

<p>简化iOS应用使用纯代码机型自适应布局的工作,使用一种简洁高效的语法替代NSLayoutConstraints.</p>

<ul>
<li>项目主页: <a href="https://github.com/SnapKit/Masonry">Masonry</a></li>
<li>最新示例: <a href="https://github.com/SnapKit/Masonry/archive/master.zip">点击下载</a></li>
<li>项目简议: 如果再看到关于纯代码,xib或storyboard,使用哪种方式进行UI布局更合适的讨论,请推荐他们先试用下 Masonry. Masonry,像xib一样快速,同时拥有作为纯代码方式的灵活性 -- github关注度 7800 + 是有原因的!</li>
</ul>

<h1>快速入门</h1>

<h2>安装</h2>

<h3>使用 CocoaPods 安装</h3>

<pre><code class="ruby">pod 'Masonry'
</code></pre>

<p>推荐在你的在 prefix.pch 中引入头文件:</p>

<pre><code class="obj-c">// 定义这个常量,就可以在使用Masonry不必总带着前缀 `mas_`:
#define MAS_SHORTHAND

// 定义这个常量,以支持在 Masonry 语法中自动将基本类型转换为 object 类型:
#define MAS_SHORTHAND_GLOBALS

#import "Masonry.h"
</code></pre>

<h2>使用</h2>

<h3>初始Masonry</h3>

<p>这是使用MASConstraintMaker创建的约束:</p>

<pre><code class="obj-c">/* 注意:view1应首先添加为某个视图的子视图,superview是一个局部变量,指view1的父视图. */

UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);

[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(superview.mas_top).offset(padding.top);
    make.left.equalTo(superview.mas_left).offset(padding.left);
    make.bottom.equalTo(superview.mas_bottom).offset(-padding.bottom);
    make.right.equalTo(superview.mas_right).offset(-padding.right);
}];
</code></pre>

<p>甚至可以更短:</p>

<pre><code class="obj-c">[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(superview).insets(padding);
}];
</code></pre>

<h2>不止可以表达相等关系</h2>

<blockquote>
  <p><code>.equalTo</code> 等价于 <strong>NSLayoutRelationEqual</strong></p>
  
  <p><code>.lessThanOrEqualTo</code> 等价于 <strong>NSLayoutRelationLessThanOrEqual</strong></p>
  
  <p><code>.greaterThanOrEqualTo</code> 等价于 <strong>NSLayoutRelationGreaterThanOrEqual</strong></p>
</blockquote>

<p>这三个表达相等关系的语句,可以接受一个参数;此参数可以为以下任意一个:</p>

<h3>1. MASViewAttribute</h3>

<pre><code class="obj-c">make.centerX.lessThanOrEqualTo(view2.mas_left);
</code></pre>

<table>
<thead>
<tr>
  <th>MASViewAttribute</th>
  <th>NSLayoutAttribute</th>
</tr>
</thead>
<tbody>
<tr>
  <td>view.mas_left</td>
  <td>NSLayoutAttributeLeft</td>
</tr>
<tr>
  <td>view.mas_right</td>
  <td>NSLayoutAttributeRight</td>
</tr>
<tr>
  <td>view.mas_top</td>
  <td>NSLayoutAttributeTop</td>
</tr>
<tr>
  <td>view.mas_bottom</td>
  <td>NSLayoutAttributeBottom</td>
</tr>
<tr>
  <td>view.mas_leading</td>
  <td>NSLayoutAttributeLeading</td>
</tr>
<tr>
  <td>view.mas_trailing</td>
  <td>NSLayoutAttributeTrailing</td>
</tr>
<tr>
  <td>view.mas_width</td>
  <td>NSLayoutAttributeWidth</td>
</tr>
<tr>
  <td>view.mas_height</td>
  <td>NSLayoutAttributeHeight</td>
</tr>
<tr>
  <td>view.mas_centerX</td>
  <td>NSLayoutAttributeCenterX</td>
</tr>
<tr>
  <td>view.mas_centerY</td>
  <td>NSLayoutAttributeCenterY</td>
</tr>
<tr>
  <td>view.mas_baseline</td>
  <td>NSLayoutAttributeBaseline</td>
</tr>
</tbody>
</table>

<h3>2. UIView/NSView</h3>

<p>如果你需要 view.left 大于或等于label.left:</p>

<pre><code class="obj-c">// 下面两个约束是完全等效的.
make.left.greaterThanOrEqualTo(label);
make.left.greaterThanOrEqualTo(label.mas_left);
</code></pre>

<h3>3. NSNumber</h3>

<p>自适应布局允许将宽度或高度设置为固定值.
如果你想要给视图一个最小或最大值,你可以这样:</p>

<pre><code class="obj-c">//width &gt;= 200 &amp;&amp; width &lt;= 400
make.width.greaterThanOrEqualTo(@200);
make.width.lessThanOrEqualTo(@400)
</code></pre>

<p>但是自适应布局不支持将 left,right, centerY等设为固定值.
如果你给这些属性传递一个常量, Masonry会自动将它们转换为相对于其父视图的相对值:</p>

<pre><code class="obj-c">//creates view.left = view.superview.left + 10
make.left.lessThanOrEqualTo(@10)
</code></pre>

<p>除了使用 NSNumber 外,你可以使用基本数据类型或者结构体来创建约束:</p>

<pre><code class="obj-c">make.top.mas_equalTo(42);
make.height.mas_equalTo(20);
make.size.mas_equalTo(CGSizeMake(50, 100));
make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));
make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));
</code></pre>

<h3>4. NSArray</h3>

<p>一个数组,里面可以混合是前述三种类型的任意几种:</p>

<pre><code class="obj-c">// 表达三个视图等高的约束.
make.height.equalTo(@[view1.mas_height, view2.mas_height]);
make.height.equalTo(@[view1, view2]);
make.left.equalTo(@[view1, @100, view3.right]);
</code></pre>

<h2>约束的优先级</h2>

<blockquote>
  <p><code>.priority</code> 允许你指定一个精确的优先级,数值越大优先级越高.最高1000.</p>
  
  <p><code>.priorityHigh</code> 等价于 <strong>UILayoutPriorityDefaultHigh</strong>.优先级值为 750.</p>
  
  <p><code>.priorityMedium</code> 介于高优先级和低优先级之间,优先级值在 250~750之间.</p>
  
  <p><code>.priorityLow</code> 等价于 <strong>UILayoutPriorityDefaultLow</strong>, 优先级值为 250.</p>
</blockquote>

<p>优先级可以在约束的尾部添加:</p>

<pre><code class="obj-c">make.left.greaterThanOrEqualTo(label.mas_left).with.priorityLow();

make.top.equalTo(label.mas_top).with.priority(600);
</code></pre>

<h2>等比例自适应</h2>

<blockquote>
  <p><code>.multipliedBy</code> 允许你指定一个两个视图的某个属性等比例变化</p>
  
  <p><code>item1.attribute1 = multiplier × item2.attribute2 + constant</code>,此为约束的计算公式, <code>.multipliedBy</code>本质上是用来限定 <code>multiplier</code>的</p>
  
  <p>注意,因为编程中的坐标系从父视图左上顶点开始,所以指定基于父视图的left或者top的multiplier是没有意义的,因为父视图的left和top总为0.</p>
  
  <p>如果你需要一个视图随着父视图的宽度和高度,位置自动变化,你应该同时指定 right,bottom,width,height与父视图对应属性的比例(基于某个尺寸下的相对位置计算出的比例),并且constant必须为0.</p>
</blockquote>

<pre><code class="obj-c">// 指定宽度为父视图的 1/4.
make.width.equalTo(superview).multipliedBy(0.25);
</code></pre>

<h2>工具方法</h2>

<p>Masonry提供了一些工具方法来进一步简化约束的创建.</p>

<h3>edges 边界</h3>

<pre><code class="obj-c">//使 top, left, bottom, right等于 view2
make.edges.equalTo(view2);

//使 top = superview.top + 5, left = superview.left + 10,
//      bottom = superview.bottom - 15, right = superview.right - 20
make.edges.equalTo(superview).insets(UIEdgeInsetsMake(5, 10, 15, 20))
</code></pre>

<h3>size 尺寸</h3>

<pre><code class="obj-c">// 使宽度和高度大于或等于 titleLabel
make.size.greaterThanOrEqualTo(titleLabel)

//使 width = superview.width + 100, height = superview.height - 50
make.size.equalTo(superview).sizeOffset(CGSizeMake(100, -50))
</code></pre>

<h3>center 中心</h3>

<pre><code class="obj-c">//使 centerX和 centerY = button1
make.center.equalTo(button1)

//使 centerX = superview.centerX - 5, centerY = superview.centerY + 10
make.center.equalTo(superview).centerOffset(CGPointMake(-5, 10))
</code></pre>

<p>你可以使用链式语法来增强代码可读性:</p>

<pre><code class="obj-c">// 除top外,其他约束都与父视图相等.
make.left.right.bottom.equalTo(superview);
make.top.equalTo(otherView);
</code></pre>

<h2>更新约束</h2>

<p>有时,你需要修改已经存在的约束来实现动画效果或者移除/替换已有约束.
在 Masonry 中,有几种不同的更新视图约束的途径:</p>

<h3>1. References 引用</h3>

<p>你可以把 Masonry 语法返回的约束或约束数组,存储到一个局部变量或者类的属性中,以供后续操作某个约束.</p>

<pre><code class="obj-c">// 声明属性
@property (nonatomic, strong) MASConstraint *topConstraint;

...

// when making constraints
[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    self.topConstraint = make.top.equalTo(superview.mas_top).with.offset(padding.top);
    make.left.equalTo(superview.mas_left).with.offset(padding.left);
}];

...
// 然后你就可以操作这个属性.
[self.topConstraint uninstall];
</code></pre>

<h3>2. mas_updateConstraints</h3>

<p>如果你只是想添加新的约束,你可以使用便利方法<code>mas_updateConstraints</code>,不需要使用 <code>mas_makeConstraints</code>. <code>mas_updateConstraints</code>,不会移除已经存在的约束(即使新旧约束间相互冲突).</p>

<pre><code class="obj-c">// 重写视图的updateConstraints方法: 这是Apple推荐的添加/更新约束的位置.
// 这个方法可以被多次调用以响应setNeedsUpdateConstraints方法.
// setNeedsUpdateConstraints 可以被UIKit内部调用或者由开发者在自己的代码中调用以更新视图约束. 
- (void)updateConstraints {
    [self.growingButton mas_updateConstraints:^(MASConstraintMaker *make) {
        make.center.equalTo(self);
        make.width.equalTo(@(self.buttonSize.width)).priorityLow();
        make.height.equalTo(@(self.buttonSize.height)).priorityLow();
        make.width.lessThanOrEqualTo(self);
        make.height.lessThanOrEqualTo(self);
    }];

    //根据apple机制,最后应调用父类的updateConstraints方法.
    [super updateConstraints];
}
</code></pre>

<h3>3. mas_remakeConstraints</h3>

<p><code>mas_remakeConstraints</code>与<code>mas_updateConstraints</code>相似,不同之处在于: <code>mas_remakeConstraints</code> 会先移除视图上已有的约束,再去创建新的约束.</p>

<pre><code class="obj-c">- (void)changeButtonPosition {
    [self.button mas_remakeConstraints:^(MASConstraintMaker *make) {
        make.size.equalTo(self.buttonSize);

        if (topLeft) {
            make.top.and.left.offset(10);
        } else {
            make.bottom.and.right.offset(-10);
        }
    }];
}
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[简化iOS应用使用纯代码机型自适应布局的工作,使用一种简洁高效的语法替代NSLayoutConstraints.]]></excerpt:encoded>
		<wp:post_id>319</wp:post_id>
		<wp:post_date>2015-09-21 17:02:51</wp:post_date>
		<wp:post_date_gmt>2015-09-21 09:02:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>masonry</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="masonry"><![CDATA[Masonry]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[masonry-%e4%bd%bf%e7%94%a8%e7%ba%af%e4%bb%a3%e7%a0%81%e8%bf%9b%e8%a1%8cios%e5%ba%94%e7%94%a8%e7%9a%84autolayout%e8%87%aa%e9%80%82%e5%ba%94%e5%b8%83%e5%b1%80]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[有了Auto Layout,为什么你还是害怕写UITabelView的自适应布局? | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/09/autolayoutcell/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-09-23 17:00:55</wp:comment_date>
			<wp:comment_date_gmt>2015-09-23 09:00:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] Masonry &#8212; 使用纯代码进行iOS应用的autolayout自适应布局 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1442998855]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1442998855.5820829868316650390625;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1442999182.54049396514892578125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[有了Auto Layout,为什么你还是害怕写UITabelView的自适应布局? &#8211; iOS122 | 查问题]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.chawenti.com/articles/33012.html</wp:comment_author_url>
			<wp:comment_author_IP>153.92.41.61</wp:comment_author_IP>
			<wp:comment_date>2015-09-24 05:39:16</wp:comment_date>
			<wp:comment_date_gmt>2015-09-23 21:39:16</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 坦白说,咱都是刚入行的人,使用AutoLayout布局,写一个自适应的Cell,大家估计也都会.可以用xib,也可以用纯代码写.如果准备用纯代码写,建议你先好好研究下 Masonry — 使用纯代码进行iOS应用的autolayout自适应布局 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1443044356]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1443044356.0130879878997802734375;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1443062825.02472209930419921875;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>有了Auto Layout,为什么你还是害怕写UITableView的自适应布局?</title>
		<link>http://www.ios122.com/2015/09/autolayoutcell/</link>
		<pubDate>Wed, 23 Sep 2015 09:00:49 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=327</guid>
		<description></description>
		<content:encoded><![CDATA[<p>Apple 算是最重视应用开发体验的公司了.从Xib到StoryBoard,从Auto Layout到Size Class,每一次的更新,都会给iOS应用的开发带来不小的便利.但是,对于绝对多数iOS攻城狮来说,我们依然还是很害怕写UITableVIew的自适应布局.当然,害怕不是因为我们不会写,或者本身有什么特殊的技术点,而是因为太麻烦.当然,文章的后半部分,会给出相应的解决方案,毕竟本文不是为了吐槽而吐槽.</p>

<h1>UITableView的自适应布局有多麻烦?</h1>

<h2>数据类型的不确定性:种类越多,页面越复杂.</h2>

<p><img src="http://ios122.bj.bcebos.com/IMG_1716.PNG" alt="网易新闻" /></p>

<p>以网易新闻的客户端为例,可能的数据包括文字新闻,图片新闻,图集,推广,视频等.每一种数据,又根据来源或点击量等细分出许多不同的状态.基本上每种数据类型,都至少需要一种单独的Cell去呈现,每一个Cell的布局,都要单独去写.所以说,数据的类型将直接决定页面本身的复杂度.</p>

<h2>数据长度的不确定性: 不确定字段越多,迭代成本越高.</h2>

<p><img src="http://ios122.bj.bcebos.com/D555E2ADE02F7F3885772B82D686C1D8.png" alt="新浪微博" /></p>

<p>上图取自新浪微博.稍微有点经验的iOS攻城狮,都猜到我要吐槽什么了吧!没错,就是同种数据类型,但是内部字段的长度可能不同,而且还要都要给他们显示出来!其实我也很希望自家的应用都像网易那样,固定长度显示新闻,显示不完,就直接截断--可惜那样的应用都是别人公司的应用.可能你会说: 顶部给个非微博正文区域给个固定高度;文字区域动态计算出高度;图片部分,图片高度固定,根据数量动态计算高度;转发部分同理;然后根据数据在tableView的代理方法 <code>tableView:heightForRowAtIndexPath:</code>  中动态返回高度即可.是的,思路就是这么个思路,但是你确定产品经理一直不会改需求?你确定不需要适配 6plus时,字号要大点?你确定自己的应用不希望大屏上一样能显示更多的图片?你确定老板不是盘算着 iPad版也交给你维护?所以说,对于这种数据长度不确定,但是又要求完全显示的设计,最复杂的不在于实现,而在于后期的迭代.可变字段越多,迭代越复杂.如果连显示方式都改了,那就基本等于重做了几遍.</p>

<h2>cell高度计算有坑: 难以理解的诡异问题</h2>

<p>在 <code>tableView:heightForRowAtIndexPath:</code> 中计算高度时,是有坑的,对于刚接触iOS的攻城狮来说,几乎是难以理解的诡异问题.这里简单说两个,其他的大家可跟帖补充:</p>

<h3>1.文字高度计算时 0.1 高度误差问题.</h3>

<p>cell中经常需要使用 <code>textRectForBounds: limitedToNumberOfLines:</code> 来计算某一个文字的显示高度.这里,其实有一个很大的坑的,如果你没遇到只能说明你很幸运.由于浮点数四舍五入机制的存在,所以偶现UILabel最后一行无法显示的情况.原因也很诡异: 在你计算时,部分值会存在稍许的不超过0.01的误差,大多数情况下,这个误差值,可以安全忽略,但是确实存在那0.01误差刚好是绝对换行与不换行的分界值,因为0.01的误差,可能计算出来的高度就不足以显示最后几个文字.为了安全起见,如果需要计算文本高度,我都是加上一个额外的0.1来保证最后一行肯定可以显示.</p>

<h3>2.手动调用 tableView:cellForRowAtIndexPath: 获取cell,引起的卡顿问题.</h3>

<p>这个可能也是一些有经验的开发者也会混淆的问题: 不要在自己的代码中调用 <code>tableView:cellForRowAtIndexPath:</code> 方法来获取某一个位置的 cell,来进行关于这个cell的某些计算,因为你手动调用这个方法产生的cell不会参与cell的复用! 各种缘由,不过多解释,总之结论就是,只要系统自己调用 <code>tableView:cellForRowAtIndexPath:</code> 方法产生的 cell才会参与cell的复用. 
关于这个话题,比较易犯的错误是,竟然有开发者在</p>

<p><code>tableView:heightForRowAtIndexPath:</code> 中调用 <code>tableView:cellForRowAtIndexPath:</code> 来获取cell,然后计算cell高度.然后你会发现,凡是稍微涉及到图片显示的界面,你的显示是对的,但是滚动非常卡顿,因为你在自己浑然不觉的情况下创建了N个Cell,而且这些Cell绝对不会参与复用.</p>

<h1>为什么我现在不再害怕写UITableView的自适应布局?</h1>

<p>是的,我现在一点也不担心去处理各种UITableView布局.不是因为我有一股所谓的不畏艰难的伟大工作精神,而是因为我切实找到了解决办法.具体该怎么做呢?</p>

<h2>1.使用AutoLayout 布局你的cell</h2>

<p>坦白说,咱都不是刚入行的人,使用AutoLayout布局,写一个自适应的Cell,大家估计也都会.可以用xib,也可以用纯代码写.如果准备用纯代码写,建议你先好好研究下 <a href="http://www.ios122.com/2015/09/masonry/">Masonry — 使用纯代码进行iOS应用的autolayout自适应布局</a></p>

<h2>2.使用 UITableView-FDTemplateLayoutCell 根据单元格内容的约束自适应单元格高度</h2>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-23%20%E4%B8%8B%E5%8D%884.34.43.png" alt="博客讨论" /></p>

<p>坦白说,我原来也是: 虽然cell用着AutoLayout,但是计算cell高度时,也是看着设计图返回一个适合的值--想想都虐心.前天,一个热心的开发者在我博客留言说: 他用 Masonry 进行Cell的高度自适应时遇到了问题.我第一反应是: Masonry 能用来计算cell高度?! 然后,他提到了一个第三方UITableView-FDTemplateLayoutCell,好像是国内的大神写的,具体介绍可以看这里: <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/">优化UITableViewCell高度计算的那些事</a>.这篇文章的博主关于 UITableView-FDTemplateLayoutCell 分析很详尽,用一句总结就是: 一行代码解决cell高度动态计算问题.</p>

<h2>3.一个关于Masonry 和 UITableView-FDTemplateLayoutCell结合使用的小例子</h2>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-09-23%20%E4%B8%8B%E5%8D%884.46.10.png" alt=" 一个关于Masonry 和 UITableView-FDTemplateLayoutCell结合使用的小例子" /></p>

<p>示例下载地址: <a href="https://github.com/ios122/ios122">点击下载</a></p>

<p>非常感谢 <a href="http://www.cnblogs.com/ios122/p/4826700.html#3271618">@未来帅哥 的讨论</a>,给了我很大启发和帮助,我也如约做了一个关于Masonry 和 UITableView-FDTemplateLayoutCell结合使用的小例子,以解决他的问题:关于如何让左侧图片底部总是不被遮盖.</p>

<p>核心代码片段:</p>

<pre><code class="obj-c">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{

    CGFloat height = [tableView fd_heightForCellWithIdentifier: NSStringFromClass([YFAutoLayoutCell class]) cacheByIndexPath:indexPath configuration:^(YFAutoLayoutCell * cell) {
        YFAutoLayoutCellModel * model = [self.data objectAtIndex: indexPath.row];

        cell.model = model;
    }];

    return height;
}
</code></pre>

<pre><code class="obj-c"><br />/**
 *  初始化视图.
 */
- (void) setupView
{
    self.imgView = [[UIImageView alloc] init];
    self.introLabel = [[UILabel alloc] init];

    [self.contentView addSubview: self.imgView];
    [self.contentView addSubview: self.introLabel];

    self.introLabel.numberOfLines = 0;

    [self.imgView makeConstraints:^(MASConstraintMaker *make) {
        make.top.left.equalTo(8);
        make.size.equalTo(CGSizeMake(60, 60));
        make.bottom.lessThanOrEqualTo(-8); // 这里是关键
    }];

    [self.introLabel makeConstraints:^(MASConstraintMaker *make) {
        make.left.equalTo(self.imgView.right).offset(8);
        make.top.equalTo(self.imgView);
        make.right.equalTo(-8);
        make.bottom.equalTo(-8);
    }];
}
</code></pre>

<h1>小结</h1>

<p>有了Auto Layout,为什么你还是害怕写UITableView的自适应布局?因为你还在用传统的方式去计算cell的高度! Auto Layout + UITableView-FDTemplateLayoutCell + Masonry,耐心研究几个小时,绝对让你受益匪浅!</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[Apple 算是最重视应用开发体验的公司了.从Xib到StoryBoard,从Auto Layout到Size Class,每一次的更新,都会给iOS应用的开发带来不小的便利.但是,对于绝对多数iOS攻城狮来说,我们依然还是很害怕写UITableVIew的自适应布局.当然,害怕不是因为我们不会写,或者本身有什么特殊的技术点,而是因为太麻烦.当然,文章的后半部分,会给出相应的解决方案]]></excerpt:encoded>
		<wp:post_id>327</wp:post_id>
		<wp:post_date>2015-09-23 17:00:49</wp:post_date>
		<wp:post_date_gmt>2015-09-23 09:00:49</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>autolayoutcell</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="masonry"><![CDATA[Masonry]]></category>
		<category domain="post_tag" nicename="uitableview-fdtemplatelayoutcell"><![CDATA[UITableView-FDTemplateLayoutCell]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[Saucheong Ye]]></wp:comment_author>
			<wp:comment_author_email>sauchyer@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://sauchye.com/</wp:comment_author_url>
			<wp:comment_author_IP>121.35.210.155</wp:comment_author_IP>
			<wp:comment_date>2015-09-25 09:48:14</wp:comment_date>
			<wp:comment_date_gmt>2015-09-25 01:48:14</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[赞，多谢博主，多谢开源~]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1443145694]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1443145694.78779888153076171875;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1443149604.0389840602874755859375;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>12</wp:comment_id>
			<wp:comment_author><![CDATA[shansir]]></wp:comment_author>
			<wp:comment_author_email>639226747@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>118.112.57.17</wp:comment_author_IP>
			<wp:comment_date>2015-10-15 01:03:00</wp:comment_date>
			<wp:comment_date_gmt>2015-10-14 17:03:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[博主 关于tableView:cellForRowAtIndexPath:  人为调用的问题有什么可行的解决办法吗 ？比如cell中包含进度条 需要实时更新每个cell的进度信息  cell数目比较多的情况 只能选择复用  在返回进度信息的回调方法中 不可能每个进度信息返回都去reload  目前我采用tableView:cellForRowAtIndexPath: 的方法去获取对应cell 然后更新内容。但是看过你的文章之后，才知道这种cell不会复用，所以问问有什么可行的解决办法，THX]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444898513.6628589630126953125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444842180]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444842180.817802906036376953125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[iOS122 运营组]]></wp:comment_author>
			<wp:comment_author_email>yanfengstyle@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.247.180.210</wp:comment_author_IP>
			<wp:comment_date>2015-10-15 16:51:32</wp:comment_date>
			<wp:comment_date_gmt>2015-10-15 08:51:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我确实处理过类似的问题,当时采取的一种不太完善的方案是: 定义一个字典cellDict,以index.row为键,以cell为值来存储cell;通过cellDict去获取对应的cell;cell 中应有一个block属性prepareForReuseCallback,在cell的 prepareForReuse方法调用时触发此回调函数;获取cell的位置,应设置 prepareForReuseCallback,在其内部实现从 cellDict 移除对应的cell. 其他问题,欢迎加入QQ群讨论: 477952275]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>12</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444899092]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1444899092.88657093048095703125;s:5:"event";s:11:"check-error";s:4:"user";s:12:"yanfengstyle";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>DateTools,可能是最好用的iOS日期工具库</title>
		<link>http://www.ios122.com/2015/09/datetools/</link>
		<pubDate>Fri, 25 Sep 2015 14:55:08 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=338</guid>
		<description></description>
		<content:encoded><![CDATA[<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/DateToolsHeader.png" alt="Banner" /></p>

<h2>项目简介</h2>

<p>DateTools 用于提高Objective-C中日期和时间相关操作的效率.灵感来源于 <a href="http://msdn.microsoft.com/en-us/library/system.datetime(v=vs.110).aspx">DateTime</a>和[Time Period Library](Time Period Library).</p>

<ul>
<li>项目主页: <a href="https://github.com/MatthewYork/DateTools">DateTools</a></li>
<li>最新示例: <a href="https://github.com/MatthewYork/DateTools/archive/master.zip">点击下载</a></li>
<li>工程简议: 支持国际化,支持中文输出,真的很贴心!</li>
</ul>

<h2>安装</h2>

<h3>使用 Cocoapods 安装</h3>

<pre><code class="ruby">pod 'DateTools'
</code></pre>

<h2>NSDate+DateTools</h2>

<p>DateTools让NSDate功能更完整,可以让你更容易地去获取日期各个组件的信息,如年 月 日等.</p>

<h3>获取字符串形式的时间间隔.</h3>

<p>DateTools 可以让你获取距离一个过去的时间点距离当前时间的字符串表示.和Twitter中很像,这个时间字符串有完整形式和缩略形式两种.你可以像下面这样使用:</p>

<pre><code class="objc">NSDate *timeAgoDate = [NSDate dateWithTimeIntervalSinceNow:-4];
NSLog(@"Time Ago: %@", timeAgoDate.timeAgoSinceNow);
NSLog(@"Time Ago: %@", timeAgoDate.shortTimeAgoSinceNow);

//输出:
//Time Ago: 4 seconds ago
//Time Ago: 4s

// 如果工程支持国际化,并且模拟器或真机环境设为简体中文,则会输出:
// Time Ago: 4秒钟前
// Time Ago: 4秒
</code></pre>

<p>如果你的工程支持国际化,<code>DateTools</code>现在会自动支持以下语言的本地化:</p>

<ul>
<li>ar (Arabic)</li>
<li>bg (Bulgarian)</li>
<li>ca (Catalan)</li>
<li>zh_Hans (简体中文)</li>
<li>zh_Hant (繁体中文)</li>
<li>cs (Czech)</li>
<li>da (Danish)</li>
<li>nl (Dutch)</li>
<li>en (English)</li>
<li>fi (Finnish)</li>
<li>fr (French)</li>
<li>de (German)</li>
<li>gre (Greek)</li>
<li>gu (Gujarati)</li>
<li>he (Hebrew)</li>
<li>hi (Hindi)</li>
<li>hu (Hungarian)</li>
<li>is (Icelandic)</li>
<li>id (Indonesian)</li>
<li>it (Italian)</li>
<li>ja (Japanese)</li>
<li>ko (Korean)</li>
<li>lv (Latvian)</li>
<li>ms (Malay)</li>
<li>nb (Norwegian)</li>
<li>pl (Polish)</li>
<li>pt (Portuguese)</li>
<li>ro (Romanian)</li>
<li>ru (Russian)</li>
<li>sl (Slovenian)</li>
<li>es (Spanish)</li>
<li>sv (Swedish)</li>
<li>th (Thai)</li>
<li>tr (Turkish)</li>
<li>uk (Ukrainian)</li>
<li>vi (Vietnamese)</li>
<li>cy (Welsh)</li>
<li>hr (Croatian)</li>
</ul>

<h3>获取日期的某个组成部分,如年月周日时分秒等.</h3>

<p>使用 DateTools 可以很容易地获取日期对象的某一组成部分:</p>

<pre><code class="objc">NSDate * date = [NSDate date];
NSInteger year = date.year;
NSInteger month = date.month;
NSLog(@"year: %ld, month: %ld", (long)year, (long)month); // year: 2015, month: 9
</code></pre>

<p>如果你不想使用公历,可以这样做:</p>

<pre><code class="objc">NSInteger day = [date dayWithCalendar:calendar];
</code></pre>

<p>如果你想改变 DateTools 使用的默认日历,可以改写 <code>NSDate+DateTools.m</code> 中的 <code>defaultCalendar</code> 方法.</p>

<h3>日期编辑</h3>

<p>可以使用 <code>dateByAdding...</code> 或 <code>dateBySubtractingYears...</code> 进行日期按年/月/日/时分/秒等增加或减少:</p>

<pre><code class="objc">NSDate * date = [NSDate date];
NSInteger oldYear = date.year;

NSDate *newDate = [date dateByAddingYears:1];
NSInteger newYear = newDate.year;

NSLog(@"oldYear: %ld newYear: %ld", (long)oldYear, (long)newYear); // 输出: oldYear: 2015 newYear: 2016
</code></pre>

<h3>日期比较</h3>

<p>DateTools 提供下列方法,比较两个日期的大小,返回结果为一个布尔值:</p>

<ul>
<li>isEarlierThan</li>
<li>isEarlierThanOrEqualTo</li>
<li>isLaterThan</li>
<li>isLaterThanOrEqualTo</li>
</ul>

<p>如果想获取两个日期具体的差值: 获取毫秒间隔可以使用 NSDate 提供的 <code>timeIntervalSinceDate:</code>和 <code>timeIntervalSinceNow</code> 方法;获取相差多少年/月/周/日/时/分/秒等,可以直接使用 DateTools的扩展方法.</p>

<pre><code class="objc">NSInteger yearsApart = [firstDate yearsFrom:secondDate];
</code></pre>

<p>类似<code>yearsFrom:</code>用于日期比较的方法包括:</p>

<ul>
<li><code>yearsFrom:</code>, <code>yearsUntil</code>, <code>yearsAgo</code>, <code>yearsEarlierThan:</code>, <code>yearsLaterThan:</code></li>
<li><code>monthsFrom:</code>, <code>monthsUntil</code>, <code>monthsAgo</code>, <code>monthsEarlierThan:</code>, <code>monthsLaterThan:</code></li>
<li><code>weeksFrom:</code>, <code>weeksUntil</code>, <code>weeksAgo</code>, <code>weeksEarlierThan:</code>, <code>weeksLaterThan:</code></li>
<li><code>daysFrom:</code>, <code>daysUntil</code>, <code>daysAgo</code>, <code>daysEarlierThan:</code>, <code>daysLaterThan:</code></li>
<li><code>hoursFrom:</code>, <code>hoursUntil</code>, <code>hoursAgo</code>, <code>hoursEarlierThan:</code>, <code>hoursLaterThan:</code></li>
<li><code>minutesFrom:</code>, <code>minutesUntil</code>, <code>minutesAgo</code>, <code>minutesEarlierThan:</code>, <code>minutesLaterThan:</code></li>
<li><code>secondsFrom:</code>, <code>secondsUntil</code>, <code>secondsAgo</code>, <code>secondsEarlierThan:</code>, <code>secondsLaterThan:</code></li>
</ul>

<h3>日期的格式化输出</h3>

<p>可以使用 code>formattedDateWithStyle:</code> 和 <code>formattedDateWithFormat:</code> 方法格式化输出日期:</p>

<pre><code class="objc">NSDate * date = [NSDate date];
NSString * dateStr = [date formattedDateWithStyle: NSDateFormatterFullStyle];

// 此处输出的具体内容会根据你的手机或模拟器语言环境的不同而不同.
NSLog(@"%@", dateStr); // 输出: 2015年9月25日 星期五

dateStr =  [date formattedDateWithFormat:@"YYYY/MM/dd HH:mm:ss"];
NSLog(@"%@", dateStr); // 输出: 2015/09/25 15:19:23
</code></pre>

<h2>时间段</h2>

<p>DateTools 通过 <code>DTTimePeriod</code>类来简化时间段相关的操作.</p>

<h3>初始化</h3>

<p>已知开始和结束时间,可以使用下面的方法初始化时间段对象:</p>

<pre><code class="objc">DTTimePeriod *timePeriod = [[DTTimePeriod alloc] initWithStartDate:startDate endDate:endDate];
</code></pre>

<p>或者,已知起始或结束时间,同时知道时间段的总时长,可以用类似下面的方法创建时间端对象:</p>

<pre><code class="objc">// 创建一个时间段,从现在开始,共5个小时.
DTTimePeriod *timePeriod = [DTTimePeriod timePeriodWithSize:DTTimePeriodSizeHour amount:5 startingAt:[NSDate date]];
</code></pre>

<h3>时间段信息</h3>

<p>可以通过 DTTimePeriod 的实例方法来获取时间段的相关信息:</p>

<ul>
<li><code>hasStartDate</code> - 返回YES,如果有起始时间.</li>
<li><code>hasEndDate</code> - 返回YES,如果有结束时间.</li>
<li><code>isMoment</code> - 返回YES,如果起始时间和结束时间相同.</li>
<li><code>durationIn....</code> -  返回指定单位下时间段的长度.</li>
</ul>

<pre><code class="objc">DTTimePeriod *timePeriod = [[DTTimePeriod alloc] initWithStartDate:date endDate: [date dateByAddingDays: 10]];

NSLog(@"相差 %g 天", [timePeriod durationInDays]); // 输出: 相差 10 天
</code></pre>

<h3>操作</h3>

<p>可以对时间段进行移动,延长或缩短的操作.</p>

<p><strong>移动</strong></p>

<p>当一个时间段被移动时,起始时间和结束时间会相应地同步迁移或推后.可以使用下面两个方法移动时间段:</p>

<ul>
<li><code>shiftEarlierWithSize:amount:</code> 时间段整体前移</li>
<li><code>shiftLaterWithSize:amount:</code> 时间段整体推后</li>
</ul>

<p><strong>延长/缩短</strong></p>

<p>可以通过保持起始点/中间时间点/结束时间点不变,然后改变开始或结束时间点,以得到延长或缩短时间段的目的:</p>

<pre><code class="objc">// 通过前移起始时间,把时间段总时长从1分钟变为2分钟.
DTTimePeriod *timePeriod  = [DTTimePeriod timePeriodWithSize:DTTimePeriodSizeMinute endingAt:[NSDate date]];
[timePeriod lengthenWithAnchorDate:DTTimePeriodAnchorEnd size:DTTimePeriodSizeMinute amount:1];
</code></pre>

<h3>关系</h3>

<p>可以使用 <code>DTTimePeriod</code>的关系操作相关的方法,来判断两个时间段的相互关系,如是否包含,是否是同一段时间等.</p>

<p><strong>基础</strong></p>

<p>下图表格列出了两个时间段所有可能的关系:
<img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/PeriodRelations.png" alt="TimePeriods" /></p>

<p>可通过下列方法判断两个时间段的关系:</p>

<ul>
<li>isEqualToPeriod:</li>
<li>isInside:</li>
<li>contains:</li>
<li>overlapsWith:</li>
<li>intersects:</li>
</ul>

<p>你可以通过下面这个方法获取相对于另一个时间段的关系:</p>

<pre><code class="objc">-(DTTimePeriodRelation)relationToPeriod:(DTTimePeriod *)period;
</code></pre>

<p>所有可能的时间段间的关系都列在了枚举 <code>DTTimePeriodRelation</code> 中了.</p>

<p><strong>点击示例中 Time Periods 按钮,然后滑动滑块,可以更好地掌握时间段之间的相互关系</strong></p>

<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/TimePeriodsDemo.gif" alt="TimePeriods" /></p>

<h2>时间段集合</h2>

<p>DateTools 提供两种时间段集合类: <code>DTTimePeriodCollection</code> 和 <code>DTTimePeriodChain</code>.前者,允许存储彼此有交集的时间段;后者,不允许存储彼此有交集的时间段.</p>

<p>这两个时间段集合类,操作和 NSArray 很像.你可以添加,插入和移除 DTTimePeriod 对象,就像你在数组时的那样.唯一的不同是,两中集合存储时间段的方式.</p>

<p><code>DTTimePeriodCollection</code> 和 <code>DTTimePeriodChain</code>,是为了简化基于多个时间段的逻辑处理.比如同一团队中,给不同的人设置任务的起始和结束时间,此时如果使用 DTTimePeriodCollection 来处理各个时间段,可以直接得到团队总任务的起始时间和结束时间.</p>

<h3>DTTimePeriodCollection</h3>

<p>DTTimePeriodCollection 是一个规则相对宽松的集合.默认无序(指的是顺序和各个时间段的起止时间无关.),但支持手动排序;拥有自己的属性,比如基于内粗存储的时间段计算出的此集合的开始时间和结束时间.这个结合允许存储有交集的时间段.</p>

<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/TimePeriodCollection.png" alt="TimePeriodCollections" /></p>

<p>可以像下面这样创建新的DTTimePeriodCollection集合:</p>

<pre><code class="objc">// 创建集合.
DTTimePeriodCollection *collection = [DTTimePeriodCollection collection];

// 创建时间段
NSDateFormatter * dateFormatter = [[NSDateFormatter alloc]init];
[dateFormatter setDateFormat: @"YYYY MM dd HH:mm:ss.SSS"];
DTTimePeriod *firstPeriod = [DTTimePeriod timePeriodWithStartDate:[dateFormatter dateFromString:@"2014 11 05 18:15:12.000"] endDate:[dateFormatter dateFromString:@"2015 11 05 18:15:12.000"]];
DTTimePeriod *secondPeriod = [DTTimePeriod timePeriodWithStartDate:[dateFormatter dateFromString:@"2015 11 05 18:15:12.000"] endDate:[dateFormatter dateFromString:@"2016 11 05 18:15:12.000"]];

// 把时间段添加到集合中.
[collection addTimePeriod:firstPeriod];
[collection addTimePeriod:secondPeriod];

// 从集合中获取时间段.
firstPeriod = collection[0];
</code></pre>

<p><strong>排序</strong></p>

<p>有三类给集合内时间段排序的方法:</p>

<ul>
<li><strong>根据起始时间排序</strong> - <code>sortByStartAscending</code>, <code>sortByStartDescending</code></li>
<li><strong>根据结束时间排序</strong> - <code>sortByEndAscending</code>, <code>sortByEndDescending</code></li>
<li><strong>根据时长排序</strong> - <code>sortByDurationAscending</code>, <code>sortByDurationDescending</code></li>
</ul>

<p><strong>操作</strong></p>

<p>也可以去获取一个 NSDate 对象或一个 DTTimePeriod 对象与一个 时间段结合的相对关系.例如,你可以通过 <cdoe>periodsIntersectedByDate:</code> 方法获取所有与某个时间有交集的时间段.这个方法会返回一个新的 DTTimePeriodCollection 对象,里面包含所有符合条件的时间段.</p>

<p>有许多类似的方法,如下图:</p>

<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/TimePeriodCollectionOperations.png" alt="TimePeriodCollectionOperations" /></p>

<h3>DTTimePeriodChain</h3>

<p>DTTimePeriodChain 以较为严格的方式存储时间段对象. DTTimePeriodChain集合通常依据开始和结束时间存储时间段对象,并且有自己的属性,如 根据内部存储的时间段对象推断出来的此集合的开始时间和结束时间. DTTimePeriodChain 内部存储的时间段对象不允许有交集.这种集合很适用于连续会议或约会等日程类事务的建模.</p>

<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/TimePeriodChain.png" alt="TimePeriodChains" /></p>

<p>创建一个新的 DTTimePeriodChain 集合:</p>

<pre><code class="objc">// 创建集合.
DTTimePeriodChain *chain = [DTTimePeriodChain chain];

// 创建时间段
NSDateFormatter * dateFormatter = [[NSDateFormatter alloc]init];
[dateFormatter setDateFormat: @"YYYY MM dd HH:mm:ss.SSS"];

DTTimePeriod *firstPeriod = [DTTimePeriod timePeriodWithStartDate:[dateFormatter dateFromString:@"2014 11 05 18:15:12.000"] endDate:[dateFormatter dateFromString:@"2015 11 05 18:15:12.000"]];
DTTimePeriod *secondPeriod = [DTTimePeriod timePeriodWithStartDate:[dateFormatter dateFromString:@"2015 11 05 18:15:12.000"] endDate:[dateFormatter dateFromString:@"2016 11 05 18:15:12.000"]];

// 添加时间段对象到集合中.
[chain addTimePeriod:firstPeriod];

// 如果后存入的时间和前一个存入的时间无法前后完全衔接,则后一个时间会适当前移或后移,以使前后时间段紧凑.
[chain addTimePeriod:secondPeriod];

// 获取集合中的元素.
firstPeriod = chain[0];
</code></pre>

<p>新加入的时间段,时长不变,起始时间变为前一个时间段的结束时间,结束时间对应前移后后移.在非零位置新插入的时间,其后的时间段相应后移.在零位置插入的时间,集合的起始时间前移.操作图解如下:</p>

<p><strong>操作</strong>
像 DTTimePeriodCollection 一样, DTTimePeriodChain 也可以进行相等性比较,并且也可以前移后后移.其他执行的方法在下图列出:</p>

<p><img src="https://raw.githubusercontent.com/MatthewYork/Resources/master/DateTools/TimePeriodChainOperations.png" alt="TimePeriodChainOperations" /></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[DateTools 用于提高Objective-C中日期和时间相关操作的效率.]]></excerpt:encoded>
		<wp:post_id>338</wp:post_id>
		<wp:post_date>2015-09-25 22:55:08</wp:post_date>
		<wp:post_date_gmt>2015-09-25 14:55:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>datetools</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="datetools"><![CDATA[DateTools]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>如何把设计图自动转换为iOS代码? 在线等,挺急的!</title>
		<link>http://www.ios122.com/2015/10/auto_view_component/</link>
		<pubDate>Tue, 06 Oct 2015 21:33:23 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=349</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>如何把设计图自动转换为iOS代码? 在线等,挺急的!</h1>

<p>这是一篇可能略显枯燥的技术深度讨论与实践文章.如何把设计图自动转换为对应的iOS代码?作为一个 iOS开发爱好者,这是我很感兴趣的一个话题.最近也确实有了些许灵感,也确实取得了一点小成果,和大家分享一下.欢迎感兴趣的iOS爱好者能和我一起研究讨论!</p>

<h2>这是一个可以节省 70% 工作量的话题</h2>

<p>我觉得,如果真的能把一张设计图自动转换为代码,任何开发工程师都会感兴趣的.单以 iOS 应用为例, 在一个最常用的MVC架构的APP中,主要的代码,无非就是集中于: M 的网络请求部分, V的数据显示部分, C的逻辑交互部分.对于controller控制器层,往往需要结合业务逻辑去处理,代码量并不算大;对于Model数据模型层,我们有 <a href="http://www.ios122.com/tag/afnetworking/">AFNetworing</a>, <a href="http://www.ios122.com/tag/restkit/">RestKit</a>, <a href="http://www.ios122.com/tag/mjextension/">MJExtension</a>等,可以大大简化网络接口到数据模型的转换;对于View视图层,代码最繁杂,最枯燥无趣,迭代最让人头疼的部分,又有什么可以凭借呢?我没有详实的数据统计来确认各个iOS开发者的日常开发中,MVC各个层面,具体的时间成本如何;单从我个人角度来说, View布局的拆分与转换,占据了我 70% 以上的时间.我们公司通常是按单个完整任务来拆分工作的,单个任务的MVC三层,都是应该由一个人独立完成.每次都把大把时间浪费在"画UI"上,真的感觉好无趣,好浪费生命;临时遇到产品经理改动需求,可能一个对方看似更加"合理"的改动,我这边几乎要大动干戈!我想我对编程本身确实是感兴趣的,但是整天浪费时间在 UI上,真的感觉有点虚度光阴.所以说,在本不充裕的空闲里,我一直在思考的一个命题就是: 如何实现 UI 的自动化与独立化.</p>

<h2>过往的尝试: 基于Xib的视图模块化.</h2>

<p>尽管作为一名iOS开发人员,我依然对苹果公司提供的开发技术及其发展方向持谨慎和保守态度.前一段时间,尝试使用 Xib来布局视图,遇到一些坑,但是熟悉之后,也确实比原来单纯基于绝对位置的纯代码布局更灵活些,也更快捷些.在此期间,我研究的一个重要话题就是如何实现Xib之间的嵌套复用,即在一个Xib上如何直接嵌入另一个Xib.乍听起来很简单,但是在亲身实践之后,才发现其难度.我不是来吐槽的,个中曲折不再一一赘述,下面是我研究的成果:</p>

<p><img src="http://ios122.bj.bcebos.com/2015-10-07-01.png" alt="XIB效果图" /></p>

<p>上图,是一个Xib模块,其中的色块部分,嵌套的是另一个Xib模块.最终显示是,色块会自动被对应的Xib模块替代.</p>

<p>核心代码如下:</p>

<pre><code class="obj-c">//
//  MCComponent.h
//  iOS122
//
//  Created by 颜风 on 15/7/5.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "MCConstants.h"

/**
 *  可复用组件.用于编写可嵌套的 xib 组件.
 *  
 *  适用场景: 需要静态确定布局的页面内的UI元素的复用性问题.
 *  使用方法: 在xib或storyboard中,将某一用于占位的view的 custom class 设为对一个的 component, 则初始化时,会自动使用此component对应的xib文件中的内容去替换对应位置.
 *  注意: 对于可动态确定布局的部分,如tableView中的cell,直接自行从xib初始化即可,不必继承于 MCComponent.
 */
@interface MCComponent : UIView

@property (strong, nonatomic) UIView * contentView; //!&lt; 真正的内容视图.
@property (weak, nonatomic, readonly) UIViewController * viewController; //!&lt; 当前视图所在的控制器.
@property (weak, nonatomic, readonly)NSLayoutConstraint * heightContronstraint; //!&lt; 高度的约束.不存在,则返回nil.
@property (strong, nonatomic) id virtualModel; //!&lt; 虚拟model.用于测试.默认返回nil.当不为nil,优先使用它.
@property (strong, nonatomic)  id model; //!&lt; 视图数据模型.内部会自动根据virtualModel的值,进行不同的处理.
@property (assign, nonatomic, readonly) BOOL isTest; //!&lt; 是否是测试.如果是,将优先使用 virtualModel来替换model.系统内部处理.默认为NO.

/**
 *   初始化.
 *
 *   子类需要继承此方法,以完成自定义初始化操作. 不要手动调用此方法.
 */
- (void)setup;

/**
 *  重新加载数据.
 *
 *  子类可根据需要,具体实现此方法.
 */
- (void)reloadData;


/**
 *  返回上一级.
 */
- (void) back;

/**
 *  便利构造器.子类应根据需要重写.
 *
 *  @return 默认返回self.
 */
+ (instancetype)sharedInstance;

/**
 *  更新视图.
 *
 *  子类应根据需要重写此方法.默认不做任何处理.
 */
- (void) updateView;

@end
</code></pre>

<pre><code class="obj-c">//
//  MCComponent.m
//  iOS122
//
//  Created by 颜风 on 15/7/5.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "MCComponent.h"

@interface MCComponent ()
@end
@implementation MCComponent
@dynamic virtualModel;
@synthesize model = _model;

- (instancetype)init
{
    self = [super init];

    if (nil != self) {
        [self mcSetup: NO];
    }

    return self;
}

- (instancetype)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame: frame];

    if (nil != self) {
        [self mcSetup: NO];
    }

    return self;
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self = [super initWithCoder:aDecoder];

    if (nil != self) {
        [self mcSetup: YES];
    }

    return self;
}

/**
 *  是否从xib初始化此类.
 *
 *  @param isFromXib 是否从xib或sb初始化此类.
 *
 *  注意: 无论此类是否从xib或sb初始化,组件内部都将从xib文件初始化.
 *
 *  @return 实例对象.
 */
- (instancetype) mcSetup: (BOOL) isFromXib
{
    UIView * contentView = [[[NSBundle mainBundle] loadNibNamed: NSStringFromClass([self class]) owner:self options:nil] firstObject];
    self.contentView = contentView;

    contentView.translatesAutoresizingMaskIntoConstraints = NO;

    // 这一句,是区别初始化方式后的,核心不同.
    self.translatesAutoresizingMaskIntoConstraints = ! isFromXib;

    [self addSubview: contentView];

    self.backgroundColor = contentView.backgroundColor;

    if (nil == self.backgroundColor) {
        self.backgroundColor = [UIColor clearColor];
    }

    [self addConstraint: [NSLayoutConstraint constraintWithItem: contentView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem: self attribute:NSLayoutAttributeLeft multiplier: 1.0 constant: 0]];
    [self addConstraint: [NSLayoutConstraint constraintWithItem: contentView attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem: self attribute:NSLayoutAttributeRight multiplier: 1.0 constant: 0]];
    [self addConstraint: [NSLayoutConstraint constraintWithItem: contentView attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem: self attribute:NSLayoutAttributeTop multiplier: 1.0 constant: 0]];
    [self addConstraint: [NSLayoutConstraint constraintWithItem: contentView attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem: self attribute:NSLayoutAttributeBottom multiplier: 1.0 constant: 0]];

    [self setup];

    return self;
}


- (void)setup
{
    /* 子类需要继承此方法,以完成自定义初始化操作. */
}

- (void)reloadData
{
    /* 子类根据需要,自行实现. */
}

- (UIViewController*)viewController {
    for (UIView* next = [self superview]; next; next = next.superview) {
        UIResponder* nextResponder = [next nextResponder];
        if ([nextResponder isKindOfClass:[UIViewController class]]) {
            return (UIViewController*)nextResponder;
        }
    }
    return nil;
}


- (void)back
{
    if (nil != self.viewController.navigationController) {
        [self.viewController.navigationController popViewControllerAnimated: YES];
    }
    else{
        [self.viewController  dismissViewControllerAnimated: YES completion:NULL];
    }
}

- (NSLayoutConstraint *)heightContronstraint
{
    __block NSLayoutConstraint * heightCons = nil;
    [self.constraints enumerateObjectsUsingBlock:^(NSLayoutConstraint * obj, NSUInteger idx, BOOL *stop) {
        if (NSLayoutAttributeHeight == obj.firstAttribute &amp;&amp; nil == obj.secondItem &amp;&amp; [obj.firstItem isEqual: self]) {
            heightCons = obj;

            * stop = YES;
        }
    }];


    return heightCons;
}

+ (instancetype)sharedInstance
{
    /* 子类应根据需要重写这个方法. */
    return nil;
}

- (id)virtualModel
{
    return nil;
}

- (void)setModel:(id)model
{
    _model = model;

    // 更新视图.
    [self updateView];
}

- (id)model
{
    id model = _model;

    if(YES == self.isTest){
        model = self.virtualModel;
    }

    return model;
}

- (void)updateView
{
    /*子类应根据需要重写此方法.默认不做任何处理.*/
}


- (BOOL)isTest
{
    /* 子类应根据自己需要,重写这个方法. */
    return NO;
}
@end
</code></pre>

<p>你的Xib视图组件,应该由一个 MCComponent的子类的.h/.m与一个同名的 .xib 文件组成,如MCTextComponent.h, MCTextComponent.m, MCTextComponent.xib.此时应把XIB的File's Owder与自定义的MCComponent关联起来.按照以上步骤,即可实现图示效果.</p>

<p>此策略已经在我们的项目中试用了一段时间,也已经填了些坑,多次优化,感兴趣的可以直接拿过去用.但是,基于XIB的视图模块化,终究还是需要手动的参与,对工作效率的提升也似乎达到了一个极限:因为它终究需要人工深度参与.关于它的讨论,暂时到此为止.</p>

<h2>目前的探索: 基于 Masonry 的视图模块化</h2>

<p><a href="http://www.ios122.com/tag/masonry/">Masonry</a>,是一个基于纯代码的AutoLayout库.初次涉及时,只是感觉它很方便,既有Xib的易读性,又有纯代码的灵活性.试用一段时间之后,突然想到: 或许借助Masonry,建立一个纯代码的不依赖Xib的AutoLayout视图组件机制.</p>

<h3>目前能得到的效果</h3>

<ul>
<li>视图基于 AutoLayout;</li>
<li>视图自动适配不同屏幕尺寸;</li>
<li>视图完全独立于数据与业务逻辑;</li>
<li>视图严肃仅与父视图有位置关系;</li>
<li>可以将视图模块的元素与模块同名属性自动关联;</li>
<li>仅需知道父视图的宽高,模块内某一个UI元素的宽高, UI元素的 bottom 与 right, 就可以唯一确定任意元素的位置.</li>
</ul>

<h3>核心理论基础: AutoLayout中,如何唯一确定元素在不同尺寸屏幕上的位置?</h3>

<ul>
<li>既定方案,必须基于AutoLayout,至于AutoLayout与Frame的区别于优势,不做赘述.</li>
<li>在不考虑多屏幕兼容的情况下, AutoLayout,可以直接使用固定的约束常量值来确定,但是 马上iPhone 7 都要出来了,指不定什么尺寸呢? 一个机型,一个UI代码?是不是想想都让人头大!</li>
<li>考虑到多屏幕尺寸,UI设计图等比缩放的常用情况,我分享一个可以唯一确定UI元素的方案:</li>
</ul>

<pre><code class="obj-c">[subView makeConstraints:^(MASConstraintMaker *make) {
    UIView * superView = subView.superview;

    make.width.equalTo(superView).multipliedBy(subWidth / superWidth);
    make.height.equalTo(superView).multipliedBy(subHeight / superHeight);

    make.right.equalTo(superView).multipliedBy(subRight / superWidth);
    make.bottom.equalTo(superView).multipliedBy(subBottom / superHeight);
}];
</code></pre>

<p>以上代码,是整个代码的核心,其巧妙之处在于:不使用constant,而是使用比例来指定约束.选取的是 width,height,right,bottom,而不是其他属性,其巧妙之处,大家试用下其他属性就知道了.</p>

<h3>核心代码,打造自己的视图模块库.</h3>

<p>直接继承YFViewComponent类,然后实现类方法 subViewsConfig 即可.</p>

<pre><code class="obj-c">//
//  YFViewComponent.h
//  iOS122
//
//  Created by 颜风 on 15/10/6.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import &lt;UIKit/UIKit.h&gt;

/**
 *  预定义常量的声明.
 */
extern const NSString *  YFViewComponentSelfHolderWidthKey; //!&lt; 同一设计图中,视图模块本身的宽度.
extern const NSString *  YFViewComponentSelfHolderHeightKey; //!&lt; 同一设计图中,视图模块本身的高度.
extern const NSString *  YFViewComponentSubViewsKey; //!&lt; 同一设计图中,模块的所有子视图.
extern const NSString *  YFViewComponentSubViewClassNameKey; //!&lt; 子视图的类型.
extern const NSString *  YFViewComponentSubViewPropNameKey; //!&lt; 子视图对应的属性,模块中应有属性与其对应,且可通过此属性访问对应的子视图.
extern const NSString *  YFViewComponentSubViewHolderWidthKey; //!&lt; 同一设计图中,子视图的宽度.
extern const NSString *  YFViewComponentSubViewHolderHeightKey; //!&lt; 同一设计图中,子视图的高度.
extern const NSString *  YFViewComponentSubViewHolderRightKey; //!&lt; 同一设计图中,子视图的右内边距值(right).
extern const NSString *  YFViewComponentSubViewHolderBottomKey; //!&lt; 同一设计图中,子视图的底部边距值(bottom).


@interface YFViewComponent : UIView

/**
 *  子视图配置信息.
 *
 *  子类应重写覆盖此方法.
 *
 一个示例:
 @{
 YFViewComponentSelfHolderWidthKey: @640.0,
 YFViewComponentSelfHolderHeightKey: @155.0,
 YFViewComponentSubViewsKey:
 @[@{
 YFViewComponentSubViewClassNameKey: NSStringFromClass([UIImageView class]) ,
 YFViewComponentSubViewPropNameKey: @"imageView", YFViewComponentSubViewHolderWidthKey: @160, YFViewComponentSubViewHolderHeightKey: @120, YFViewComponentSubViewHolderBottomKey: @140, YFViewComponentSubViewHolderRightKey: @180
 }]}
 *
 *  @return 返回子视图的配置信息.
 */
+ (NSDictionary *) subViewsConfig;

@end
</code></pre>

<pre><code class="obj-c">//
//  YFViewComponent.m
//  iOS122
//
//  Created by 颜风 on 15/10/6.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFViewComponent.h"

/**
 *  预定义常量的定义.
 */
const NSString *  YFViewComponentSelfHolderWidthKey = @"YFViewComponentSelfHolderWidthKey";
const NSString *  YFViewComponentSelfHolderHeightKey = @"YFViewComponentSelfHolderHeightKey";
const NSString *  YFViewComponentSubViewsKey = @"YFViewComponentSubViewsKey";
const NSString *  YFViewComponentSubViewClassNameKey = @"YFViewComponentSubViewClassNameKey";
const NSString *  YFViewComponentSubViewPropNameKey = @"YFViewComponentSubViewPropNameKey";
const NSString *  YFViewComponentSubViewHolderWidthKey = @"YFViewComponentSubViewHolderWidthKey";
const NSString *  YFViewComponentSubViewHolderHeightKey = @"YFViewComponentSubViewHolderHeightKey";
const NSString *  YFViewComponentSubViewHolderRightKey = @"YFViewComponentSubViewHolderRightKey";
const NSString *  YFViewComponentSubViewHolderBottomKey = @"YFViewComponentSubViewHolderBottomKey";

@implementation YFViewComponent

- (instancetype)init
{
    self = [super init];

    if (nil != self) {
        UIView * holderView = self;

        NSDictionary * config = [[self class] subViewsConfig];

        CGFloat superHeight = [[config objectForKey: YFViewComponentSelfHolderHeightKey] floatValue];
        CGFloat superWidth = [[config objectForKey: YFViewComponentSelfHolderWidthKey] floatValue];;

        NSArray * locatArray = [config objectForKey: YFViewComponentSubViewsKey];

        [locatArray enumerateObjectsUsingBlock:^(NSDictionary * obj, NSUInteger idx, BOOL *stop) {
            NSString * classString = [obj objectForKey: YFViewComponentSubViewClassNameKey];

            Class viewClass = NSClassFromString(classString);

            if (YES != [viewClass  isSubclassOfClass:[UIView class]]) {
                return;
            }

            UIView * subView = [[viewClass alloc] init];
            [holderView addSubview: subView];

            NSString * viewKey = [obj objectForKey: YFViewComponentSubViewPropNameKey];

            [holderView setValue: subView forKey: viewKey];

            CGFloat subWidth = [[obj objectForKey: YFViewComponentSubViewHolderWidthKey] floatValue];
            CGFloat subHeight = [[obj objectForKey: YFViewComponentSubViewHolderHeightKey] floatValue];
            CGFloat subBottom = [[obj objectForKey: YFViewComponentSubViewHolderBottomKey] floatValue];
            CGFloat subRight = [[obj objectForKey: YFViewComponentSubViewHolderRightKey] floatValue];

            [subView makeConstraints:^(MASConstraintMaker *make) {
                UIView * superView = subView.superview;

                make.width.equalTo(superView).multipliedBy(subWidth / superWidth);
                make.height.equalTo(superView).multipliedBy(subHeight / superHeight);

                make.right.equalTo(superView).multipliedBy(subRight / superWidth);
                make.bottom.equalTo(superView).multipliedBy(subBottom / superHeight);
            }];
        }];
    }

    return self;
}


+ (NSDictionary *) subViewsConfig{
    return nil;
}

@end
</code></pre>

<h3>一个示例: 仿网易新闻的新闻单元格.</h3>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-05%20%E4%B8%8B%E5%8D%8810.34.46.png" alt="网易原图" /></p>

<p>这个示例,取材自网易新闻.图示中已经标注了单元格的宽高,单元格内各个UI元素的width,height,bottom,right.此处UI设计师可根据屏幕尺寸出图,我们根据一份跟定的设计图,直接使用 <a href="http://www.getmarkman.com">MarkMan</a>(一个非常好用的标准工具)丈量标记即可. 因为我们是基于比例来添加约束,不同屏幕下,会自动等比变换.</p>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8A%E5%8D%881.54.30.png" alt="元素效果图" /></p>

<p>这是一个简单的示例,为了方便演示,临时加上了:</p>

<pre><code class="ojc-c">//
//  YFAutoTransView.h
//  iOS122
//
//  Created by 颜风 on 15/10/6.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFViewComponent.h"

@interface YFAutoTransView : YFViewComponent
@property (weak, nonatomic) UIImageView * imageView;
@property (weak, nonatomic) UILabel * titleLabel;
@property (weak, nonatomic) UILabel * detailLabel;
@property (weak, nonatomic) UIButton * chatBtn;

@end
</code></pre>

<pre><code class="obj-c">//
//  YFAutoTransView.m
//  iOS122
//
//  Created by 颜风 on 15/10/6.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFAutoTransView.h"

@implementation YFAutoTransView

+ (NSDictionary *) subViewsConfig{
    NSNumber * holderWidth = @640.0;
    NSNumber * holderHeight = @155.0;

    NSArray * subConfig = @[
  @[NSStringFromClass([UIImageView class]), @"imageView", @160, @120, @140, @180],
  @[NSStringFromClass([UILabel class]), @"titleLabel", @420, @31, @55, @615],
  @[NSStringFromClass([UILabel class]), @"detailLabel", @410, @60, @136, @605],
  @[NSStringFromClass([UIButton class]), @"chatBtn", @120, @28, @141, @628]];

    NSMutableArray * subViewsConfig = [NSMutableArray arrayWithCapacity: 42];

    [subConfig enumerateObjectsUsingBlock:^(NSArray * obj, NSUInteger idx, BOOL *stop) {
        if (6 != obj.count) {
            return;
        }

        NSDictionary * configDict =
        @{
          YFViewComponentSubViewClassNameKey: obj[0],
          YFViewComponentSubViewPropNameKey: obj[1], YFViewComponentSubViewHolderWidthKey: obj[2],YFViewComponentSubViewHolderHeightKey: obj[3], YFViewComponentSubViewHolderBottomKey: obj[4], YFViewComponentSubViewHolderRightKey: obj[5]
          };

        [subViewsConfig addObject: configDict];
    }];

    NSDictionary * config = @{
                              YFViewComponentSelfHolderWidthKey: holderWidth,
                              YFViewComponentSelfHolderHeightKey: holderHeight,
                              YFViewComponentSubViewsKey: subViewsConfig};

    return config;
}

@end
</code></pre>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8A%E5%8D%882.09.56.png" alt="运行时断点调试查看效果" /></p>

<p>这是运行时,我们看到对应属性,确实与UI元素关联了起来.</p>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-06%20%E4%B8%8A%E5%8D%885.06.08.png" alt="显示的效果图" /></p>

<p>这是与数据结合之后的效果图.只是个初稿,还需要进一步调试.也就是说,以后再写UI界面,你的注意力将可以集中在 数据与视图本身的交互处理上.</p>

<pre><code class="obj-c">    YFAutoTransView * autoTestView = [[YFAutoTransView alloc] init];

    autoTestView.frame = CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 155.0/2);

    autoTestView.imageView.image = [UIImage imageNamed:@"autoTrans.png"];

    autoTestView.titleLabel.text = @"爱马仕版苹果表开售8688元起";
    autoTestView.titleLabel.font = [UIFont systemFontOfSize:15];
    [autoTestView.titleLabel adjustsFontSizeToFitWidth];

    autoTestView.detailLabel.text = @"爱马仕版苹果表盘和表带并不会单独销售.";
    autoTestView.detailLabel.numberOfLines = 0;
    autoTestView.detailLabel.font = [UIFont systemFontOfSize:12];

    [autoTestView.chatBtn setTitle:@"跟帖" forState: UIControlStateNormal];
    autoTestView.chatBtn.backgroundColor = [UIColor redColor];

    [self.view addSubview: autoTestView];
</code></pre>

<h2>小结</h2>

<p>我在此文着重分享了我目前正在研究的 基于Masonry的视图模块化方案.在以后的工作和学习中,我会继续使用与完善,以期进一步提高写UI界面的效率.可能尚有不完备之处,欢迎大家共同提出讨论.</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[这是一篇可能略显枯燥的技术深度讨论与实践文章.如何把设计图自动转换为对应的iOS代码?作为一个 iOS开发爱好者,这是我很感兴趣的一个话题.最近也确实有了些许灵感,也确实取得了一点小成果,和大家分享一下.欢迎感兴趣的iOS爱好者能和我一起研究讨论!]]></excerpt:encoded>
		<wp:post_id>349</wp:post_id>
		<wp:post_date>2015-10-07 05:33:23</wp:post_date>
		<wp:post_date_gmt>2015-10-06 21:33:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>auto_view_component</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="masonry"><![CDATA[Masonry]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[iHTCboy]]></wp:comment_author>
			<wp:comment_author_email>ihtcboy@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>119.131.76.108</wp:comment_author_IP>
			<wp:comment_date>2015-10-16 00:00:53</wp:comment_date>
			<wp:comment_date_gmt>2015-10-15 16:00:53</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[非常好，学习到了好多！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444924853]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444924853.1794040203094482421875;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444960957.0409450531005859375;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>15</wp:comment_id>
			<wp:comment_author><![CDATA[iOS122 运营组]]></wp:comment_author>
			<wp:comment_author_email>yanfengstyle@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.247.180.210</wp:comment_author_IP>
			<wp:comment_date>2015-10-16 10:02:37</wp:comment_date>
			<wp:comment_date_gmt>2015-10-16 02:02:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[共同学习]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>14</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444960957]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1444960957.30554294586181640625;s:5:"event";s:11:"check-error";s:4:"user";s:12:"yanfengstyle";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>iOS程序猿如何快速掌握 PHP,化身&quot;全栈攻城狮&quot;?</title>
		<link>http://www.ios122.com/2015/10/ios_to_php/</link>
		<pubDate>Fri, 09 Oct 2015 14:13:25 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=355</guid>
		<description></description>
		<content:encoded><![CDATA[<p>这是一篇以 iOS 开发人员的视角写给广大iOS 程序猿的 PHP 入门指南.在这篇文章里我努力去发掘 objectiv-c 与 php 之间的共性,来帮助有一定 iOS 开发经验的攻城狮来快速上手一门后台开发语言.后台开发语言,就是以"数据接口"的形式出现在我们的开发文档的那个东西!掌握PHP,无论对自己目前的iOS开发工作还是以后个人职场生涯的长久发展,都会大有裨益!最重要的是,PHP本身不是一个玩具语言,而是目前相当一部分公司仍然在用的后台开发语言,甚至包括你目前的公司;这篇文章,也不是一个简单的基础手册,而是以一种更适合 iOS 开发人员理解的方式来系统讲解 PHP 中最核心最重要最常用的概念和功能.阅读并有效实践本文,将有助于你拥有独立编写后台数据接口的能力.</p>

<h2>必要的准备与说明</h2>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8B%E5%8D%884.05.00.png" alt="下载最新版XAMPP" /></p>

<p>首先,你需要下载最新版 XAMPP软件,以在本地搭建一个 php 服务器.下载地址: <a href="https://www.apachefriends.org/download.html">https://www.apachefriends.org/download.html</a>.</p>

<p>下载完成后,双击安装.安装成功后,选择 Mange Servers-->Start All启动本地服务器.启动成功后,在浏览器中输入 <a href="http://localhost">http://localhost</a>,就可以看到一个默认的PHP页面.</p>

<p>你的php服务器文件默认放在: 应用程序-->XAMPP-->htdocs 目录下.</p>

<p>然后你还需要下载一款PHP编辑器,此时我使用Github的Atom编辑器.个人感觉界面很舒适,代码高亮看着也很舒服,你可以到这里下载: <a href="https://atom.io">https://atom.io</a>.下载完成后,点击安装即可.</p>

<p>最后要说明的是:PHP版本很多,下面的讲解支持目前最常用的 php 5.3.0 及其以上版本.</p>

<h2>Hello World!</h2>

<p>下面编写最简单的 Hello World 程序,请在以下步骤执行.</p>

<h3>1.在 应用程序-->XAMPP-->htdocs 目录下新建目录 find_php.</h3>

<p>没有特别的意思,纯碎是为了演示方便,同时不干扰默认存在的php文件.</p>

<h3>2.打开Atom编辑器,使用 <code>cmd+N</code> 新建文件,并输入以下代码,并 <code>cmd+S</code> 保存到 find_php目录,文件命名为 index.php.</h3>

<pre><code class="php">&lt;?php
echo 'Hello World';
?&gt;
</code></pre>

<p>如果PHP无法如中一样高亮显示,可能就需要点击文件右下角,以手动指定当前问文件的语法高亮方式.
<img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8B%E5%8D%884.23.35.png" alt="HelloWorld" /></p>

<h3>3.在浏览器地址栏输入: <a href="http://localhost/find_php/index.php">http://localhost/find_php/index.php</a>,即可看到用PHP写的Hello World.</h3>

<p><img src="http://ios122.bj.bcebos.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202015-10-09%20%E4%B8%8B%E5%8D%884.29.42.png" alt="hello World 显示" /></p>

<h2>AppDelegate 入口文件</h2>

<p>iOS应用通常是以 AppDelegate 文件作为编码的起始(准确说的是 main.m,在此不细究).在PHP中,你可以使用一个 index.php 文件作为你的 php 程序的唯一入口.你的所有的php页面间的访问与跳转,都将是由此处开始.下面的代码可以先先复制到你的 index.php种,它实现了一个基本的页面访问与控制的框架:</p>

<pre><code class="php">&lt;?php
$controller  = '';
$model = array();

if (isset($_GET['viewController'])) {
  $controller = $_GET['viewController'];
}

if (isset($_GET['model'])) {
  $model = $_GET['model'];
}

echo '控制器:'.$controller.'&lt;br /&gt;';

echo '数据模型:&lt;br /&gt;';
foreach ($model as $key =&gt; $value) {
  echo $key.':'.$value.'&lt;br /&gt;';
}

?&gt;
</code></pre>

<p>然后在浏览器地址栏,输入:  <code>http://localhost/find_php/index.php?viewController=HomeViewController&amp;model[id]=42&amp;model[name]=iOS122&amp;model[age]=25</code>
页面输入:</p>

<pre><code>控制器:HomeViewController
数据模型:
id:42
name:iOS122
age:25
</code></pre>

<p><code>viewController=</code>后面跟的是你你的表示你的视图控制器, <code>model</code>是一个字典,用于存储数据模型,支持输入多个键值对.<code>id</code>,<code>name</code>,<code>age</code>等都是自定义的键,用于表示你想要传给新页面的数据,如果没有可以不写.</p>

<p>注意: 此处暂仅考虑简单的GET请求,至于其他变体可在熟悉PHP语法后,自行书写.学习新语言的初期,努力寻找新东西与已经掌握的东西的共通之处,总是可以事半功倍!</p>

<h2>MVC 设计模式</h2>

<p>我们仍然从常用的MVC模式来开始更进一步的讨论.M,即Model数据模型,对应于我们在地址栏输入的model;V,即视图View,更直接地说是显示数据,为了简化讨论,我们此处仅对移动端开发常用的JSON格式数据的显示作一实现;C,即Controller控制器,也就是我们常说的视图控制器,下面会具体讨论如何在PHP中定义视图控制器.</p>

<p>注意: 移动端数据接口只是PHP的应用场景之一.其实你日常接触的绝对部分网站都是由 PHP 驱动的,要想写出布局优美的网站,你需要学习HTML和JS相关的知识.如果有兴趣,建议去这个网站: <a href="http://www.w3school.com.cn">http://www.w3school.com.cn</a></p>

<h3>改进后的 index.php</h3>

<pre><code class="php">&lt;?php // index.php
/* 实现类文件的自动加载 */
function __autoload($className) {
         if (file_exists($className . '.php')) {
             require_once $className . '.php';
             return true;
         }
         return false;
   }

// --------------------------------

/* 获取用户想要访问的页面的相关信息. */
$controllerName  = '';
$model = array();

if (isset($_GET['viewController'])) {
  $controllerName = $_GET['viewController'];
}

if (isset($_GET['model'])) {
  $model = $_GET['model'];
}

/* 跳转到指定页面. */
if ('' !== $controllerName) {
  /* 我们约定每个控制器都至少有一个$model属性和 show方法 */
  $controller = new $controllerName();
  $controller-&gt;model = $model;
  $controller-&gt;show();
}
?&gt;
</code></pre>

<p>这个方法可以实现根据用户输入自动跳转至对应的界面.你直接把代码复制到index.php中即可,因为它暂时不再需要做变更了.一些说明的技术点是:</p>

<ul>
<li>实现了 魔术方法 __autoload,以实现自动加载相关的类文件.这有些类似于我们在 .pch中全局引入某个头文件,然后整个工程处处可用一样.</li>
<li>php 是一种弱类型语言,你定义变量时不必声明类型,但是变量要以 美元符号 $开头.</li>
<li>php 使用 new 函数来创建一个对象,语法是 <code>new 类名()</code>,这不禁让我想起 oc 中的 new函数,它的语法是: [类名 new];</li>
<li>php 中的函数,看起来更像是C语言函数,也许说更像 oc 中的block,可能更好理解些.</li>
<li>php 访问属性,使用的是 <code>-&gt;</code>,而不是 <code>.</code>;另一种 php 访问属性的方式是使用 <code>obj['属性名']</code>,如$controller['model'].</li>
</ul>

<p>此时你访问 <code>http://localhost/find_php/index.php?viewController=HomeViewController&amp;model[id]=42&amp;model[name]=iOS122&amp;model[age]=25</code>,应该会报错:</p>

<pre><code>syntax error, unexpected '&gt;' in /Applications/XAMPP/xamppfiles/htdocs/find_php/HomeViewController.php on line 38
</code></pre>

<p>因为你还<strong>没有定义视图控制器<stong>!</p>

<h3>Controller:定义视图控制器</h3>

<p>在find_php文件夹新建 HomeViewController.php 文件,并把下面的代码复制进去:</p>

<pre><code class="php">&lt;?php // HomeViewController.php

/* 建议一个文件中只有一个 与文件同名的类.
如果需要继承自其他类,可以使用关键字 extends,如 */
class HomeViewController
{
  /*
  定义属性,允许定义时,给属性一个默认值,这一点比OC灵活.
  public 关键字用于指定外部可访问;
  类似的还有 private(仅允许内部访问),protected(仅允许自身及其子类访问);
  属性前必须有关键字 public/private/protected 中的一个.
   */
  public $model = array(); // 定义允许外部访问的属性.

  /* 构造函数,相当于init初始化方法;
  当调用New 函数新建对象时,此方法会被自动调用;
  array 指明参数类型, $model是实参, $model = array(),用于指定默认参数;
  指定了默认参数的参数,在调用时,可以不传;
  public 关键字作用等同于属性的关键字,默认可以不传,不传则为public;
  */
  public  function __construct(array $model = array())
  {

    /* 在实例方法内部访问对象的属性,使用 $this 关键字,且属性名前没有美元符号$;
    类似于 oc 中的self,但是使用的是 `-&gt;` 而不是 `.` */
    $this-&gt;model = $model;
  }

  /*
  析构函数,作用和 oc 中的dealloc很像.
  */
  public function __destruct()
  {
    $this-&gt;model = NULL;
  }

  /* 获取内容,用于输出显示. */
  protected function getContent()
  {
     /* 默认把用户输入以JSON格式返回 */
     $content = json_encode($this-&gt;model);

     return $content;
  }

  /*
  定义实例方法:show;
  定义方法使用的是关键字 function,且无法指定返回值,这点不如 oc 方便;
   */
  public function show()
  {
    /* 使用$this关键字来调用另一个实例方法. */
   $content = $this-&gt;getContent();

   echo $content;
  }
}
</code></pre>

<p>此时你访问 <code>http://localhost/find_php/index.php?viewController=HomeViewController&amp;model[id]=42&amp;model[name]=iOS122&amp;model[age]=25</code>,输出应该是:</p>

<pre><code>{"id":"42","name":"iOS122","age":"25"}
</code></pre>

<p>说明,页面的确跳转到了 HomeViewController控制器,并有效输出;而且输出的是我们移动端开发最常接触的 json 格式的数据.</p>

<p>以上的代码,充分展示了php作为一门面向对象(OOP)语言最常用的几个功能,如定义属性,定义实例方法,在示例方法内访问属性与实例方法等.PHP作为一门弱类型的OOP语言,也有一些非常强大的特性,推荐阅读:</p>

<ul>
<li><a href="http://ua2.php.net/manual/zh/language.oop5.overloading.php">重载</a></li>
<li><a href="http://ua2.php.net/manual/zh/language.oop5.magic.php">魔术方法</a></li>
<li><a href="http://ua2.php.net/manual/zh/language.oop5.late-static-bindings.php">后期静态绑定</a></li>
</ul>

<h3>Model: 关于数据模型的几点说明.</h3>

<ul>
<li>网上关于MVC中M的讨论,此处我选取的是最基本的一种: M专指用于存储某种数据的类的实例.它可以用于数据的格式化存储和传递,但不应包含发起网络请求和读写数据库等操作;</li>
<li>在本文讨论的Model中,我们进一步简化了Model,允许且只允许用于通过URL来定义某个控制器的Model;</li>
<li>PHP 是一本弱类型的语言,所以不必专门为某种控制器指定某种类型的Model.</li>
<li>"PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。"</li>
</ul>

<h3>View: 一个显示HTML的实例.</h3>

<p>返回 JSON 格式的数据,已经达到了做移动端开发的需要,但此处仍然使用HTML语法来显示数据,以便于更好地理解.用下面的代码替换 HomeViewController.php 文件的 getContent 方法:</p>

<pre><code class="php">  /* 获取内容,用于输出显示. */
  protected function getContent()
  {
    $content = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;';

    foreach ($this-&gt;model as $key =&gt; $value) {
      $content .= "&lt;li&gt;$key:$value&lt;/li&gt;";
    }

    $content .= '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;';

     return $content;
  }
</code></pre>

<p>此时你访问 <code>http://localhost/find_php/index.php?viewController=HomeViewController&amp;model[id]=42&amp;model[name]=iOS122&amp;model[age]=25</code>,输出应该是:</p>

<ul>
<li>id:42</li>
<li>name:iOS122</li>
<li>age:25</li>
</ul>

<p>浏览器中会被自动解析为一个列表.对应的HTML代码如下:</p>

<pre><code class="html">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
&lt;ul&gt;
&lt;li&gt;id:42&lt;/li&gt;
&lt;li&gt;name:iOS122&lt;/li&gt;
&lt;li&gt;age:25&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;&lt;/html&gt;
</code></pre>

<p>此处使用了简单的HTML标签.</p>

<h2>小结</h2>

<p>本文通过模拟实现 iOS 的MVC的设计模式,来概要性地讲解了PHP中的对应的各个概念.熟悉以上操作,可以使你具备自定义服务器接口的基本能力.更全面地信息,参见PHP官方中文文档: <a href="http://ua2.php.net/manual/zh/langref.php">http://ua2.php.net/manual/zh/langref.php</a></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[这是一篇以 iOS 开发人员的视角写给广大iOS 程序猿的 PHP 入门指南.在这篇文章里我努力去发掘 objectiv-c 与 php 之间的共性,来帮助有一定 iOS 开发经验的攻城狮来快速上手一门后台开发语言.后台开发语言,就是以"数据接口"的形式出现在我们的开发文档的那个东西!掌握PHP,无论对自己目前的iOS开发工作还是以后个人职场生涯的长久发展,都会大有裨益!最重要的是,PHP本身不是一个玩具语言,而是目前相当一部分公司仍然在用的后台开发语言,甚至包括你目前的公司;这篇文章,也不是一个简单的基础手册,而是以一种更适合 iOS 开发人员理解的方式来系统讲解 PHP 中最核心最重要最常用的概念和功能.阅读并有效实践本文,将有助于你拥有独立编写后台数据接口的能力.]]></excerpt:encoded>
		<wp:post_id>355</wp:post_id>
		<wp:post_date>2015-10-09 22:13:25</wp:post_date>
		<wp:post_date_gmt>2015-10-09 14:13:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ios_to_php</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="php"><![CDATA[PHP]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>10</wp:comment_id>
			<wp:comment_author><![CDATA[Saucheong Ye]]></wp:comment_author>
			<wp:comment_author_email>sauchyer@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://sauchye.com/</wp:comment_author_url>
			<wp:comment_author_IP>119.123.112.134</wp:comment_author_IP>
			<wp:comment_date>2015-10-10 11:14:51</wp:comment_date>
			<wp:comment_date_gmt>2015-10-10 03:14:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[曾经捣鼓过php，不过没有坚持下来，挺喜欢php的。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444447544.7909910678863525390625;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444446891]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444446891.0131580829620361328125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>11</wp:comment_id>
			<wp:comment_author><![CDATA[iOS122 运营组]]></wp:comment_author>
			<wp:comment_author_email>yanfengstyle@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.247.180.210</wp:comment_author_IP>
			<wp:comment_date>2015-10-10 11:26:24</wp:comment_date>
			<wp:comment_date_gmt>2015-10-10 03:26:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我是这几天,刚好又看了下在线的php中文文档,顺便总结下]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>10</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444447584]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1444447584.7742519378662109375;s:5:"event";s:11:"check-error";s:4:"user";s:12:"yanfengstyle";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景 | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/10/mvvm_1/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-10-16 18:49:28</wp:comment_date>
			<wp:comment_date_gmt>2015-10-16 10:49:28</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] iOS程序猿如何快速掌握 PHP,化身&#8221;全栈攻城狮&#8221;? [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1444992568]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1444992568.629829883575439453125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445057734.7494990825653076171875;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景 &#8211; iOS122 | 查问题]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.chawenti.com/articles/33453.html</wp:comment_author_url>
			<wp:comment_author_IP>153.92.41.61</wp:comment_author_IP>
			<wp:comment_date>2015-10-17 09:18:52</wp:comment_date>
			<wp:comment_date_gmt>2015-10-17 01:18:52</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 如果你有自己的服务器接口,直接使用即可;但是下面的oc代码,你可能也要对应变换下;如果你对服务器接口开发不是很了解,可以先阅读下这篇文章: iOS程序猿如何快速掌握 PHP,化身”全栈攻城狮”?. [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445044732]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445044732.3221149444580078125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445057819.2084128856658935546875;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>RDVTabBarController--可自由定制的iOS底部导航控件</title>
		<link>http://www.ios122.com/2015/10/rdvtabbarcontroller/</link>
		<pubDate>Sat, 10 Oct 2015 07:06:51 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=357</guid>
		<description></description>
		<content:encoded><![CDATA[<ul>
<li>RDVTabBarController：一个十分完善的tabBarController，可以自定义角标个数，爽的停不下来。</li>
<li>RDVTabBarController地址：<a href ="https://github.com/robbdimitrov/RDVTabBarController">RDVTabBarController</a></li>
<li>Demo地址：<a href ="https://github.com/sauchye/SYTipsDemo">欢迎Star</a></li>
</ul>

<hr />

<h3>说明</h3>

<ul>
<li>此教程是旨在让你快速入手，如需更加深层次的了解，请直接RDVTabBarController地址分析即可；</li>
</ul>

<h3>使用</h3>

<pre><code class="objective-c">pod 'RDVTabBarController'
</code></pre>

<p>建议直接CocoaPods管理，对CocoaPods有兴趣的童鞋可以戳<a href="http://code4app.com/article/cocoapods-install-usage">cocoapods-install-usage</a></p>

<h3>结构</h3>

<pre><code class="objective-c">RDVTabBar 
@interface RDVTabBar : UIView
</code></pre>

<pre><code class="objective-c">RDVTabBarController
@interface RDVTabBarController : UIViewController 
</code></pre>

<pre><code class="objective-c">RDVTabBarItem
@interface RDVTabBarItem : UIControl
</code></pre>

<p>RDVTabBarController Example Usage其实已经很详细了，接下来看初始化</p>

<pre><code class="objective-c"> //VString宏定义，为了就是更好的国际化语言，适配多语言，刚好此Demo也国际化了，可以参看https://github.com/sauchye/dev_notes/issues/4 🙈
#define VString(x)      NSLocalizedString(x, nil)
</code></pre>

<pre><code class="objective-c">- (void)setupViewControllers{
    SYFirstViewController *firstVC = [[SYFirstViewController alloc] init];
    SYSecondViewController *secondVC = [[SYSecondViewController alloc] init];
    SYThirdViewController *thirdVC = [[SYThirdViewController alloc] init];
    firstVC.title = VString(@"Home");
    secondVC.title = VString(@"Found");
    thirdVC.title = VString(@"Me");
    self.firstNav = [[SYBaseNavigationController alloc] initWithRootViewController:firstVC];
    self.secondNav = [[SYBaseNavigationController alloc] initWithRootViewController:secondVC];
    self.thirdNav = [[SYBaseNavigationController alloc] initWithRootViewController:thirdVC];
    [self setViewControllers:@[self.firstNav, self.secondNav, self.thirdNav]];
    [self customizeTabBarForController];
}
</code></pre>

<pre><code class="objective-c">- (void)customizeTabBarForController{

    //tabbar 背景图片 tabbar_background
    UIImage *backgroundImage = [UIImage imageNamed:@"tabbar_background"];
    //选项卡图片
    NSArray *tabBarItemImages;
    //这里添加tabBar icon图片
    //= @[VString(@"First"), VString(@"Second"),VString(@"Third")];

    NSArray *tabBarItemTitles = @[VString(@"Home"), VString(@"Found"), VString(@"Me")];
    NSInteger index = 0;
    for (RDVTabBarItem *item in [[self tabBar] items])
    {
        item.titlePositionAdjustment = UIOffsetMake(0, 2.0);
        [item setBackgroundSelectedImage:backgroundImage withUnselectedImage:backgroundImage];
        UIImage *selectedimage = [UIImage imageNamed:[NSString stringWithFormat:@"%@_selected",[tabBarItemImages objectAtIndex:index]]];

        UIImage *unselectedimage = [UIImage imageNamed:[NSString stringWithFormat:@"%@_normal",[tabBarItemImages objectAtIndex:index]]];

        [item setFinishedSelectedImage:selectedimage withFinishedUnselectedImage:unselectedimage];

        [item setTitle:[tabBarItemTitles objectAtIndex:index]];
        item.selectedTitleAttributes = @{
                                         NSFontAttributeName: [UIFont boldSystemFontOfSize:12],
                                         NSForegroundColorAttributeName:kNAVIGATION_BAR_COLOR,
                                         };
        item.unselectedTitleAttributes = @{
                                           NSFontAttributeName: [UIFont boldSystemFontOfSize:12],
                                           NSForegroundColorAttributeName:RGB(217, 217, 217),
                                           };

        [item setTitle:[tabBarItemTitles objectAtIndex:index]];
        index++;

    }
}
</code></pre>

<h3>这样你的tabBar基本搭建好了，但是还需要完善一些，比如，角标设置，push隐藏等。</h3>

<ul>
<li><p>Push隐藏tabBar，你只需要这样即可</p>

<pre><code class="objective-c">- (void)viewWillAppear:(BOOL)animated{
  [super viewWillAppear:animated];
  [[self rdv_tabBarController] setTabBarHidden:YES animated:YES];
}
</code></pre></li>
<li><p>设置角标数</p>

<pre><code class="objective-c">[[self rdv_tabBarItem] setBadgeValue:@"3"];
</code></pre></li>
<li><p>RDVTabBarControllerDelegate，相信你看就会明白，好的方法命名很重要啊~</p>

<pre><code class="objective-c">/**
* Asks the delegate whether the specified view controller should be made active.
*/
- (BOOL)tabBarController:(RDVTabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController;

/**
* Tells the delegate that the user selected an item in the tab bar.
*/
- (void)tabBarController:(RDVTabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController;
</code></pre></li>
<li><p>还有需要多等待你去发现...</p></li>
</ul>

<hr />

<h3>结语</h3>

<p>RDVTabBarController是一个很棒的第三方tabBarController，值得我们学习和思考。</p>

<ul>
<li>相比传统第三方，你会发现可以很好的定制角标，这是极好的，当然你也可以自定义；</li>
<li>但是不能定义中间凸起的tabBar，好早之前去哪儿就是中间凸起一个tabBar，不过现在去哪儿也改成传统的tabBar了；</li>
</ul>

<hr />

<p>本文,由我们 <a href="http://shang.qq.com/wpa/qunwpa?idkey=87fb9e5cea0e31f2d7b349a0f784dc1be68f3f9e7423c97c661b38ac57279825">iOS122</a> 的小伙伴 <a href="http://sauchye.com/2015/10/09/third-party-frameworks-RDVTabBarController.html">@Sauchye</a>​供稿,更多讨论,参见: <a href="http://www.ios122.com/tag/rdvtabbarcontroller/">http://www.ios122.com/tag/rdvtabbarcontroller/</a></p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[DVTabBarController是一个很棒的第三方tabBarController，值得我们学习和思考。相比传统第三方，你会发现可以很好的定制角标，这是极好的，当然你也可以自定义；但是不能定义中间凸起的tabBar，好早之前去哪儿就是中间凸起一个tabBar，不过现在去哪儿也改成传统的tabBar了.]]></excerpt:encoded>
		<wp:post_id>357</wp:post_id>
		<wp:post_date>2015-10-10 15:06:51</wp:post_date>
		<wp:post_date_gmt>2015-10-10 07:06:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>rdvtabbarcontroller</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="rdvtabbarcontroller"><![CDATA[RDVTabBarController]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>盘点国内程序员不常用的热门iOS第三方库:看完,还敢自称”精通iOS开发”吗?</title>
		<link>http://www.ios122.com/2015/10/renwuchi_2/</link>
		<pubDate>Mon, 12 Oct 2015 16:24:17 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=364</guid>
		<description></description>
		<content:encoded><![CDATA[<p>综合github上各个项目的关注度与具体使用情况,涵盖功能,UI,数据库,自动化测试,编程工具等类型,看完,还敢自称”精通iOS开发”吗?</p>

<ul>
<li><a href="https://github.com/syedhali/EZAudio">https://github.com/syedhali/EZAudio</a> 基于核心音频,有助于进行实时，低延迟音频处理和可视化的iOS和OSX音频可视化框架。</li>
<li><a href="https://github.com/bang590/JSPatch">https://github.com/bang590/JSPatch</a> JSPatch使用Objective-C运行时桥接Objective-C和Javascript。你可以只包括一个此库,就可以通过JavaScript调用Objective-C中的任何类和方法。 JSPatch一般用于动态修复iOS应用程序。</li>
<li><a href="https://github.com/Jawbone/JBChartView">https://github.com/Jawbone/JBChartView</a> 基于iOS的用于线路和条形图的图表库。</li>
<li><a href="https://github.com/danielgindi/ios-charts">https://github.com/danielgindi/ios-charts</a> 一个美丽MPAndroidChart的IOS版本.- 用于iOS应用的美丽图表！</li>
<li><a href="https://github.com/rentzsch/mogenerator">https://github.com/rentzsch/mogenerator</a> Core Data 代码生成器.</li>
<li><a href="https://github.com/realm/realm-cocoa">https://github.com/realm/realm-cocoa</a> </li>
<li><a href="https://github.com/realm/realm-cocoa">https://github.com/realm/realm-cocoa</a> Realm 是移动端专用 数据库：用于替换核心数据与SQLite</li>
<li><a href="https://github.com/yapstudios/YapDatabase">https://github.com/yapstudios/YapDatabase</a> YapDatabase是一种用于iOS和Mac的可扩展的数据库。</li>
<li><a href="https://github.com/Marxon13/M13ProgressSuite">https://github.com/Marxon13/M13ProgressSuite</a>含有许多工具套件，以在iOS上显示进度信息。</li>
<li><a href="https://github.com/mxcl/PromiseKit">https://github.com/mxcl/PromiseKit</a> 用于iOS和OS X的Promises</li>
<li><a href="https://github.com/SwiftyJSON/SwiftyJSON">https://github.com/SwiftyJSON/SwiftyJSON</a> 用于处理Swift中的JSON数据的更好方法</li>
<li><a href="https://github.com/stig/json-framework">https://github.com/stig/json-framework</a> JSON（JavaScript对象符号）是一种轻量的数据交换格式，易于读写人类和计算机一样。该框架实现了用在Objective-C严格的JSON解析器和编码器。</li>
<li><a href="https://github.com/SnapKit/SnapKit">https://github.com/SnapKit/SnapKit</a> 一个可用于为iOS和OS X的Swift自动布局DSL</li>
<li><a href="https://github.com/robb/Cartography">https://github.com/robb/Cartography</a> 一个用于Swift的声明性自动布局DSL</li>
<li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack">https://github.com/CocoaLumberjack/CocoaLumberjack</a>快速和简单，但功能强大而灵活的日志框架适用于Mac和iOS</li>
<li><a href="https://github.com/fpillet/NSLogger">https://github.com/fpillet/NSLogger</a> 一个现代化的，灵活的日志工具</li>
<li><a href="https://github.com/Haneke/HanekeSwift">https://github.com/Haneke/HanekeSwift</a> 一个用于iOS的轻量级通用的高速缓存库,使用Swift编写,对图像有特别优化.</li>
<li><a href="https://github.com/vfr/Reader">https://github.com/vfr/Reader</a>iOS PDF阅读器核心库</li>
<li><a href="https://github.com/robbiehanson/XMPPFramework">https://github.com/robbiehanson/XMPPFramework</a>一个XMPP架构,使用Objective-C编写,适用于Mac和iOS</li>
<li><a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a>优雅的HTTP网络库,使用Swift编写</li>
<li><a href="https://github.com/Cocoanetics/DTCoreText">https://github.com/Cocoanetics/DTCoreText</a> 方法集,允许在CoreText中使用HTML代码</li>
<li><a href="https://github.com/mdiep/MMMarkdown">https://github.com/mdiep/MMMarkdown</a>一个Objective-C的静态库,用于将Markdown语法转换换为HTML。</li>
<li><a href="https://github.com/usebutton/DeepLinkKit">https://github.com/usebutton/DeepLinkKit</a>极佳的路线匹配方式，基于块的方法来处理你的深层链接。</li>
<li><a href="https://github.com/KrauseFx/TSMessages">https://github.com/KrauseFx/TSMessages</a> 易于使用和定制的消息/通知,用于 iOS版Tweetbot.</li>
<li><a href="https://github.com/jessesquires/JSQMessagesViewController">https://github.com/jessesquires/JSQMessagesViewController</a> 一个优雅的iOS信息UI库</li>
<li><a href="https://github.com/Grouper/FlatUIKit">https://github.com/Grouper/FlatUIKit</a>令人惊叹的iOS扁平化UI组件集合。</li>
<li><a href="https://github.com/ViccAlexander/Chameleon">https://github.com/ViccAlexander/Chameleon</a>iOS (Obj-C &amp; Swift)扁平化颜色框架</li>
<li><a href="https://github.com/bryankeller/">https://github.com/bryankeller/BLKFlexibleHeightBar</a> 用BLKFlexibleHeightBar创建缩合的iOS应用程序标题栏就像出现在Facebook，Square Cash，和Safari浏览器的一样。</li>
<li><a href="https://github.com/victorBaro/VBFPopFlatButton">https://github.com/victorBaro/VBFPopFlatButton</a>扁平化风格的按钮在9个不同的国家使用POP</li>
<li><a href="https://github.com/hackiftekhar/IQKeyboardManager">https://github.com/hackiftekhar/IQKeyboardManager</a>(IQKeyboardManager）无代码插入式通用库,可以防止键盘滑动起来的问题，涵盖的UITextField/ UITextView的。既不需要编写任何代码，也不需要任何设置等。</li>
<li><a href="https://github.com/TransitApp/SVWebViewController">https://github.com/TransitApp/SVWebViewController</a>一个下拉内嵌浏览器为您的iOS应用提供帮助。</li>
<li><a href="https://github.com/facebook/AsyncDisplayKit/">https://github.com/facebook/AsyncDisplayKit/</a>流畅的异步用户界面的的iOS应用程序。</li>
<li><a href="https://github.com/layerhq/Atlas-iOS">https://github.com/layerhq/Atlas-iOS</a>Atlas是原生的iOS通信用户界面组件层的库。</li>
<li><a href="https://github.com/telly/TLYShyNavBar">https://github.com/telly/TLYShyNavBar</a>与那些所有嚣张的UINavigationBar比，这个是害羞，而且谦虚的！轻松创建自动滚动导航栏！</li>
<li><a href="https://github.com/okmr-d/DOFavoriteButton">https://github.com/okmr-d/DOFavoriteButton</a>用Swift写可爱的动画按钮。* [https://github.com/inFullMobile/WobbleView是在你的应用程序的任何视图最近受欢迎摆动效果的实现。它可以用于容易地动态添加到用户交互和过渡。</li>
<li><a href="https://github.com/ninjaprox/NVActivityIndicatorView">https://github.com/ninjaprox/NVActivityIndicatorView</a>收集好的加载动画</li>
<li><a href="https://github.com/devinross/tapkulibrary">https://github.com/devinross/tapkulibrary</a>tap + haiku = tapku，一个精心设计的开源的iOS框架</li>
<li><a href="https://github.com/xmartlabs/XLForm">https://github.com/xmartlabs/XLForm</a>XLForm是最灵活和最强大的iOS库创建动态表视图形式。与Swift和Obj-C 完全兼容。</li>
<li><a href="https://github.com/yoavlt/LiquidFloatingActionButton">https://github.com/yoavlt/LiquidFloatingActionButton</a> 液态材料设计浮动的操作按钮</li>
<li><a href="https://github.com/cwRichardKim/RKNotificationHub">https://github.com/cwRichardKim/RKNotificationHub</a>做任何UIView的一个完全成熟的通知中心</li>
<li><a href="https://github.com/square/SocketRocket">https://github.com/square/SocketRocket</a>一个符合的Objective-C的WebSocket客户端库。</li>
<li><a href="https://github.com/realm/SwiftLint">https://github.com/realm/SwiftLint</a>实验工具来执行Swift风格和约定。..</li>
<li><a href="https://github.com/facebook/chisel">https://github.com/facebook/chisel</a>确切的LLDB集合命令来帮助调试的iOS应用程序。* <a href="https://github.com/Flipboard/FLEX">https://github.com/Flipboard/FLEX</a>一个为iOS在应用程序的调试和探测工具</li>
<li><a href="https://github.com/krzysztofzablocki/KZBootstrap">https://github.com/krzysztofzablocki/KZBootstrap</a>
iOS的项目引导瞄准高质量的编码。</li>
<li><a href="https://github.com/mattt/GroundControl">https://github.com/mattt/GroundControl</a>为iOS远程配置</li>
<li><a href="https://github.com/supermarin/ObjectiveSugar">https://github.com/supermarin/ObjectiveSugar</a> ObjectiveC新增于人类。 Ruby的风格。</li>
<li><a href="https://github.com/EvgenyKarkan/EKAlgorithms">https://github.com/EvgenyKarkan/EKAlgorithms</a>EKAlgorithms）EKAlgorithms包含一些知名的CS算法和数据结构。</li>
<li><a href="https://github.com/robb/Underscore.m">https://github.com/robb/Underscore.m</a>DSL数据操作</li>
<li><a href="https://github.com/matthewpalmer/Locksmith">https://github.com/matthewpalmer/Locksmith</a>一个强大的面向协议库，与Swift的钥匙串工作。</li>
<li><a href="https://github.com/jspahrsummers/libextobjc">https://github.com/jspahrsummers/libextobjc</a>Cocoa库扩展的Objective-C编程语言.</li>
<li><a href="https://github.com/square/Valet">https://github.com/square/Valet</a>代客可以让你安全地存储在iOS和OS X的钥匙串数据，而无需了解的钥匙扣如何工作的事情。 小菜一碟。我们承诺。</li>
<li><a href="https://github.com/kishikawakatsumi/UICKeyChainStore">https://github.com/kishikawakatsumi/UICKeyChainStore</a>UICKeyChainStore是一个简单的包装钥匙串上的iOS。使得使用钥匙串的API一样容易的NSUserDefaults。</li>
<li><a href="https://github.com/thoughtbot/liftoff">https://github.com/thoughtbot/liftoff</a>用于创建和配置新的Xcode项目的CLI</li>
<li><a href="https://github.com/gh-unit/gh-unit">https://github.com/gh-unit/gh-unit</a>对于Objective-C的测试框架* <a href="https://github.com/AliSoftware/OHHTTPStubs">https://github.com/AliSoftware/OHHTTPStubs</a>轻松存网络的要求！测试你的应用程序使用假网络数据和定制的响应时间，响应代码和头部！</li>
<li><a href="https://github.com/Quick/Quick">https://github.com/Quick/Quick</a>Swift（和Objective-C）测试框架。</li>
<li><a href="https://github.com/specta/specta">https://github.com/specta/specta</a>一个轻量级的TDD/ BDD框架的Objective-C和Cocoa</li>
<li><a href="https://github.com/kiwi-bdd/Kiwi">https://github.com/kiwi-bdd/Kiwi</a>简单的BDD为iOS</li>
<li><a href="https://github.com/kif-framework/KIF">https://github.com/kif-framework/KIF</a>保持它的功能 - 在iOS功能测试框架</li>
<li><a href="https://github.com/facebook/ios-snapshot-test-case">https://github.com/facebook/ios-snapshot-test-case</a>保持它的功能 - 在iOS功能测试框架</li>
<li><a href="https://github.com/square/PonyDebugger">https://github.com/square/PonyDebugger</a>使用Chrome的开发人员工具,远程网络和数据调试您的本地iOS应用</li>
<li><a href="https://github.com/krausefx/snapshot">https://github.com/krausefx/snapshot</a>自动把你的iOS应用程序的局部截图在每个设备上</li>
<li><a href="https://github.com/krausefx/deliver">https://github.com/krausefx/deliver</a>上传截图，元数据和您的应用程序在App Store使用一个命令</li>
<li><a href="https://github.com/KrauseFx/fastlane">https://github.com/KrauseFx/fastlane</a>将所有iOS的部署工具为一个简化的工作流程</li>
<li><a href="https://github.com/johnno1962/injectionforxcode">https://github.com/johnno1962/injectionforxcode</a>运行时代码注入的Objective-C和Swift</li>
<li><a href="https://github.com/DyCI/dyci-main">https://github.com/DyCI/dyci-main</a>对于Objective-C的动态代码注入工</li>
<li><a href="https://github.com/krzysztofzablocki/KZPlayground">https://github.com/krzysztofzablocki/KZPlayground</a>Playgrounds for Objective-C</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[综合github上各个项目的关注度与具体使用情况,涵盖功能,UI,数据库,自动化测试,编程工具等类型,看完,还敢自称”精通iOS开发”吗?]]></excerpt:encoded>
		<wp:post_id>364</wp:post_id>
		<wp:post_date>2015-10-13 00:24:17</wp:post_date>
		<wp:post_date_gmt>2015-10-12 16:24:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>renwuchi_2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="task"><![CDATA[任务池]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>写给iOS小白的MVVM教程(序)</title>
		<link>http://www.ios122.com/2015/10/mvvm_start/</link>
		<pubDate>Tue, 13 Oct 2015 10:43:44 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=372</guid>
		<description></description>
		<content:encoded><![CDATA[<p>这几天,需要重构下部分代码,这里简要记录下.但是涉及的技术要点还是很多,所以分为多个篇章叙述.此教程来源于,并将于应用于实践,不做过多的概念性阐释和争论.每个篇章都会附上实际的可执行的代码.因涉及的技术点,有许多探索的部分,暂定每两天更新一个篇章.欢迎广大iOS同行,批评指正!</p>

<h2>教程内容,按更新顺序排序</h2>

<ul>
<li>从MVC到MVVM: 结合实际的例子,提出并应用一种从MVC迁移到MVVM的可行性方案.

<ul>
<li><a href="http://www.ios122.com/2015/10/mvvm_1/">写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景</a></li>
<li><a href="http://www.ios122.com/2015/10/mvvm_2/">写给iOS小白的MVVM教程(二): 从MVC到MVVM之一个典型应用场景的MVVM版本实现</a></li>
</ul></li>
<li>(TODO:)参考RestKit简化网络请求: 此处会参考RestKit,提出并制作一个可直接应用于代码的网络请求实现方案,支持自动翻页,自动配置URL与数据模型的关联关系等.</li>
<li>(TODO:)使用MVVM模式,实现iOS122.com网站的博客阅读: 会涉及到使用Leancloud做服务器端,使用marddown库解析markdwon内容,一个更加实际的MVVM各技术细节的具体实现技巧.</li>
</ul>

<h2>定义良好的接口,是成功的第一步!</h2>

<pre><code class="objective-c">//
//  YFMVVMDelegate.h
//  iOS122
//
//  Created by 颜风 on 15/10/13.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;
@protocol YFMVVMRequestDelegate;



/**
 *  MVVM协议,用于规定MVVM模式的基本约定.
 *
 *  常用于约定"V",此处的V,指的是视图的载体,或者是连接点.可以是一个View,也可以是一个控制器,或者任意NSObject对象.
 */
@protocol YFMVVMDelegate &lt;NSObject&gt;

@required
@property (nonatomic, strong) id model; //!&lt; 数据模型,用于表示从外部传入的数据.
@property (nonatomic, strong, readonly) id viewModel; //!&lt; 数据模型,用于表示直接在视图上显示的数据模型.

@optional
@property (nonatomic, strong) id&lt;YFMVVMRequestDelegate&gt; request; //!&lt; 网络请求.用于联网动态更新数据.

@end

/**
 *  用于规定MVVM中的request网络请求的协议.
 */
@protocol YFMVVMRequestDelegate &lt;NSObject&gt;

@required

/**
 *  获取数据.
 *
 *  @param component   MVVM组件中的V部分,可以是一个View,也可以是一个控制器,或者任意NSObject对象.
 *  @param success     请求成功时的回调.会把视图模型回调出去.
 *  @param failure     请求失败时的回调.会把错误信息回调出去.
 */
-(void) get: (id&lt;YFMVVMDelegate&gt;) component
    success: (void (^)(id))success
    failure:(void (^)(NSError *))failure;

@optional

/**
 *  重置页码,从头刷新.
 *
 *  下次调用 get:success:failure 方法时,会获取最新的数据.
 */
-(void) reset;

/**
 *  移动到下一页.
 *
 *  下次调用 get:success:failure 方法时,会获取下一页的数据.
 */
-(void) nextPage;

@end
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[这几天,需要重构下部分代码,这里简要记录下.但是涉及的技术要点还是很多,所以分为多个篇章叙述.此教程来源于,并将于应用于实践,不做过多的概念性阐释和争论.每个篇章都会附上实际的可执行的代码.因涉及的技术点,有许多探索的部分,暂定每两天更新一个篇章.欢迎广大iOS同行,批评指正!]]></excerpt:encoded>
		<wp:post_id>372</wp:post_id>
		<wp:post_date>2015-10-13 18:43:44</wp:post_date>
		<wp:post_date_gmt>2015-10-13 10:43:44</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mvvm_start</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mvvm"><![CDATA[MVVM]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景</title>
		<link>http://www.ios122.com/2015/10/mvvm_1/</link>
		<pubDate>Fri, 16 Oct 2015 10:49:25 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=376</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>前言</h2>

<p>本着实践为主的原则,此系列文章不做过多的概念性的阐述和讨论;更多的代码和篇幅用来展示MVC和MVVM下的基础代码结构与具体实现,来展示各自优劣.这篇文章,更多的在于发掘MVC与MVVM的共性,以期为那些对MVVM感兴趣的iOS开发者,找到一种平滑的过渡与重构代码的方式.如果对MVVM感兴趣,可以直接将本文的大部分代码引用到自己的项目中,毕竟代码是写出来的!开篇之前,你可以先到这里下载本文的示例工程:  <a href="https://github.com/ios122/ios122">https://github.com/ios122/ios122</a></p>

<p>在这一篇章里,我会分别使用我所理解的MVC与MVVM两种模式来完成同一个应用场景,以期帮助那些熟悉传统MVC模式代码的iOS攻城狮,能更好理解MVVM.限于篇幅,将MVC和MVVM拆分为两个部分,今天要说的是一个典型的MVC的应用场景,为基于MVC的MVVM重构做个基础.这篇文章着重进行了接口准备,必须的知识点的说明等内容.</p>

<h2>预设场景:按分类请求一组博客,点击获取博客详情</h2>

<p>我们选取最常见的一组场景: 根据某种规则获取一组数据,点击某一条数据,可以跳转到下一界面获取数据详情.这里我会根据分类请求此分类下的博客列表,点击某一条信息,可跳转到博客详情页.简单说,其实我们真正需要实现的只有两个页面: 博客分类列表页 与 博客详情页.</p>

<h2>数据接口准备</h2>

<p>我们至少需要两个接口,一个可以根据分类来获取博客列表,一个用来根据id获取博客详情.</p>

<h3>使用预定义的接口</h3>

<p>如果你没有自己的服务器或者对服务器开发不熟悉,可以使用我准备的这两个测试接口:</p>

<h4>博客列表接口</h4>

<pre><code>http://www.ios122.com/find_php/index.php?viewController=YFPostListViewController&amp;model[category]=ui&amp;model[page]=2
</code></pre>

<ul>
<li><code>ui</code>分类名称,目前预定义支持: <code>ui</code>, <code>network</code>, <code>tool</code>,<code>autolayout</code> 四个分类.</li>
<li><code>2</code>,获取第几页的数据,从0开始计数,指请求此分类下第几页的数据.预定义每个分类下有100条数据,每20条数据一页.</li>
<li>返回示例:</li>
</ul>

<pre><code class="json">[
    {
        "id": "ui_40",
        "title": "title_ui_40",
        "desc": "desc_ui_40"
    },
    {
        "id": "ui_41",
        "title": "title_ui_41",
        "desc": "desc_ui_41"
    },
    {
        "id": "ui_42",
        "title": "title_ui_42",
        "desc": "desc_ui_42"
    },
    {
        "id": "ui_43",
        "title": "title_ui_43",
        "desc": "desc_ui_43"
    },
    {
        "id": "ui_44",
        "title": "title_ui_44",
        "desc": "desc_ui_44"
    },
    {
        "id": "ui_45",
        "title": "title_ui_45",
        "desc": "desc_ui_45"
    },
    {
        "id": "ui_46",
        "title": "title_ui_46",
        "desc": "desc_ui_46"
    },
    {
        "id": "ui_47",
        "title": "title_ui_47",
        "desc": "desc_ui_47"
    },
    {
        "id": "ui_48",
        "title": "title_ui_48",
        "desc": "desc_ui_48"
    },
    {
        "id": "ui_49",
        "title": "title_ui_49",
        "desc": "desc_ui_49"
    },
    {
        "id": "ui_50",
        "title": "title_ui_50",
        "desc": "desc_ui_50"
    },
    {
        "id": "ui_51",
        "title": "title_ui_51",
        "desc": "desc_ui_51"
    },
    {
        "id": "ui_52",
        "title": "title_ui_52",
        "desc": "desc_ui_52"
    },
    {
        "id": "ui_53",
        "title": "title_ui_53",
        "desc": "desc_ui_53"
    },
    {
        "id": "ui_54",
        "title": "title_ui_54",
        "desc": "desc_ui_54"
    },
    {
        "id": "ui_55",
        "title": "title_ui_55",
        "desc": "desc_ui_55"
    },
    {
        "id": "ui_56",
        "title": "title_ui_56",
        "desc": "desc_ui_56"
    },
    {
        "id": "ui_57",
        "title": "title_ui_57",
        "desc": "desc_ui_57"
    },
    {
        "id": "ui_58",
        "title": "title_ui_58",
        "desc": "desc_ui_58"
    },
    {
        "id": "ui_59",
        "title": "title_ui_59",
        "desc": "desc_ui_59"
    }
]
</code></pre>

<h4>2.博客详情接口</h4>

<pre><code>http://www.ios122.com/find_php/index.php?viewController=YFPostViewController&amp;model[id]=ui_0
</code></pre>

<ul>
<li><code>ui_0</code> 表示博客唯一标识.其应为分类博客列表返回的一个有效id.</li>
<li>返回示例:</li>
</ul>

<pre><code class="json">{
    "title": "title of ui_0",
    "body": "&lt;h2&gt;Hello iOS122&lt;/h2&gt; Scann To Join Us &lt;br /&gt; &lt;image alt=\"qq\" src=\"https://raw.githubusercontent.com/ios122/ios122/master/1443002712802.png\" /&gt;"
}
</code></pre>

<h3>自定义接口</h3>

<p>如果你有自己的服务器接口,直接使用即可;但是下面的oc代码,你可能也要对应变换下;如果你对服务器接口开发不是很了解,可以先阅读下这篇文章: <a href="http://www.ios122.com/2015/10/ios_to_php/">iOS程序猿如何快速掌握 PHP,化身”全栈攻城狮”?</a>.</p>

<p>假定,你已经阅读并领会了 &lt;&lt; iOS程序猿如何快速掌握 PHP,化身”全栈攻城狮”? >>,这篇文章,新建问及那,并把下面的代码复制到对应文件中,然后根据自己的需要更改即可:</p>

<h4>博客列表接口源文件</h4>

<pre><code class="php">&lt;?php // YFPostListViewController.php

class YFPostListViewController
{

  public $model = array(); //!&lt; 传入的数据.
  private $countOfPerPage = 20; //!&lt; 每页数据条数.

  /* 获取内容,用于输出显示. */
  protected function getContent()
  {
    /* 预定义一组数据 */
    $datasource = array();

    $categorys = array('ui', 'network', 'tool', 'autolayout');

    for ($i=0; $i &lt; count($categorys); $i++) {
      $categoryName = $categorys[$i];

      $categoryData = array();

      for ($j=0; $j &lt; 100; $j++) {
        $item = array(
          'id' =&gt; "{$categoryName}_{$j}",
          'title' =&gt; "title_{$categoryName}_{$j}",
          'desc' =&gt; "desc_{$categoryName}_{$j}"
        );

        $categoryData[$j] = $item;
      }

      $datasource[$categoryName] = $categoryData;
    }

    $queryCategoryName = $this-&gt;model['category'];
    $queryPage = $this-&gt;model['page'];

    $targetCategoryData = $datasource[$queryCategoryName];

    $content = array();

    for ($i = $this-&gt;countOfPerPage * $queryPage ; $i &lt; $this-&gt;countOfPerPage * ($queryPage + 1); $i ++ ) {
      $content[] = $targetCategoryData[$i];
    }

    $content = json_encode($content);

     return $content;
  }

  public function show()
  {
   $content = $this-&gt;getContent();

   header("Content-type: application/json");

   echo $content;
  }
}
</code></pre>

<h4>博客详情接口源文件</h4>

<pre><code class="php">&lt;?php // YFPostViewController.php

class YFPostViewController
{

  public $model = array(); //!&lt; 传入的数据.

  /* 获取内容,用于输出显示. */
  protected function getContent()
  {
    $id = $this-&gt;model['id'];

    $content = array(
      'title' =&gt; "title of {$id}",
      'body' =&gt; '&lt;h2&gt;Hello iOS122&lt;/h2&gt; Scann To Join Us &lt;br /&gt; &lt;image alt="qq" src="https://raw.githubusercontent.com/ios122/ios122/master/1443002712802.png" /&gt;'
    );

    $content = json_encode($content);

     return $content;
  }

  public function show()
  {
   $content = $this-&gt;getContent();

   header("Content-type: application/json");

   echo $content;
  }
}
</code></pre>

<h2>MVC 版本实现: 类似的代码,你不知道敲过了多少遍</h2>

<h3>技术要点</h3>

<p>下面列出将要用到的技术点,如有你不熟悉的,可点击对应链接访问:</p>

<ul>
<li>使用 <a href="http://www.ios122.com/tag/afnetworking/">AFNetworking</a> 来处理网络请求;</li>
<li>使用 <a href="http://www.ios122.com/tag/mjextension/">MJExtension</a>实现JSON到数据模型的自动转换;</li>
<li>使用 <a href="http://www.ios122.com/tag/mjrefresh/">MJRefresh</a> 实现下拉刷新与上拉加载更多的效果;</li>
<li>使用 <a href="http://www.ios122.com/tag/masonry/">Masonry</a> 进行AutoLayout布局;</li>
<li>使用 <a href="http://www.ios122.com/tag/mbprogresshud/">MBProgressHUD</a> 优化页面加载时的进度提示;</li>
</ul>

<h3>思路分析</h3>

<ul>
<li><p>博客分类列表页面:</p>

<ol>
<li>在前一页面指定博客分类; </li>
<li>页面加载时自动发起网络请求获取对应分类的数据;</li>
<li>获取数据成功后,自动刷新视图;获取失败,则给出错误提示;</li>
<li>点击某一条数据,可跳转到博客详情页.</li>
</ol></li>
<li><p>博客详情页面:</p>

<ol>
<li>在前一页面指定博客id;</li>
<li>页面加载时自动发起网络请求获取id的博客详情;</li>
<li>获取成功后,自动刷新视图;获取失败,则给出错误提示.</li>
</ol></li>
</ul>

<h3>博客列表页面</h3>

<p><img src="http://ios122.bj.bcebos.com/IMG_1783.PNG" alt="博客列表效果图" /></p>

<h4>1. 在前一页面指定博客分类;</h4>

<p>这一步,大家肯定都会:</p>

<pre><code class="obj-c">YFMVCPostListViewController * mvcPostListVC = [[YFMVCPostListViewController alloc] init];

mvcPostListVC.categoryName = @"ui";

[self.navigationController pushViewController: mvcPostListVC animated: YES];
</code></pre>

<h4>2. 页面加载时自动发起网络请求获取对应分类的数据;</h4>

<p>为了保证每次都能进入列表页,都能自动刷新数据,建议在 <code>viewWillAppear:</code>方法刷新数据:</p>

<pre><code class="obj-c">- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear: animated];

    [self updateData];
}
</code></pre>

<p><code>updateData</code>方法进行数据的更新:</p>

<pre><code class="obj-c">- (void)updateData
{
    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];

    NSString * urlStr = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostListViewController&amp;model[category]=%@&amp;model[page]=0", self.categoryName];

    [manager GET: urlStr parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        NSLog(@"JSON: %@", responseObject);
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        NSLog(@"Error: %@", error);
    }];
}
</code></pre>

<p>此处使用的是预定义接口,数据请求成功后,控制台输入如下:</p>

<pre><code class="ruby">JSON: (
        {
        desc = "desc_ui_0";
        id = "ui_0";
        title = "title_ui_0";
    },
        {
        desc = "desc_ui_1";
        id = "ui_1";
        title = "title_ui_1";
    },
        {
        desc = "desc_ui_2";
        id = "ui_2";
        title = "title_ui_2";
    },
        {
        desc = "desc_ui_3";
        id = "ui_3";
        title = "title_ui_3";
    },
        {
        desc = "desc_ui_4";
        id = "ui_4";
        title = "title_ui_4";
    },
        {
        desc = "desc_ui_5";
        id = "ui_5";
        title = "title_ui_5";
    },
        {
        desc = "desc_ui_6";
        id = "ui_6";
        title = "title_ui_6";
    },
        {
        desc = "desc_ui_7";
        id = "ui_7";
        title = "title_ui_7";
    },
        {
        desc = "desc_ui_8";
        id = "ui_8";
        title = "title_ui_8";
    },
        {
        desc = "desc_ui_9";
        id = "ui_9";
        title = "title_ui_9";
    },
        {
        desc = "desc_ui_10";
        id = "ui_10";
        title = "title_ui_10";
    },
        {
        desc = "desc_ui_11";
        id = "ui_11";
        title = "title_ui_11";
    },
        {
        desc = "desc_ui_12";
        id = "ui_12";
        title = "title_ui_12";
    },
        {
        desc = "desc_ui_13";
        id = "ui_13";
        title = "title_ui_13";
    },
        {
        desc = "desc_ui_14";
        id = "ui_14";
        title = "title_ui_14";
    },
        {
        desc = "desc_ui_15";
        id = "ui_15";
        title = "title_ui_15";
    },
        {
        desc = "desc_ui_16";
        id = "ui_16";
        title = "title_ui_16";
    },
        {
        desc = "desc_ui_17";
        id = "ui_17";
        title = "title_ui_17";
    },
        {
        desc = "desc_ui_18";
        id = "ui_18";
        title = "title_ui_18";
    },
        {
        desc = "desc_ui_19";
        id = "ui_19";
        title = "title_ui_19";
    }
)
</code></pre>

<h4>3. 获取数据成功后,自动刷新视图;获取失败,则给出错误提示;</h4>

<p>这一部分,涉及的变动较多,我就直接贴代码了.你会注意到View和数据已经交叉进行了,很乱的感觉.而这也是我们想要使用MVVM重构代码的重要原因之一.</p>

<pre><code class="obj-c">//
//  YFMVCPostListViewController.m
//  iOS122
//
//  Created by 颜风 on 15/10/14.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFMVCPostListViewController.h"
#import "YFArticleModel.h"
#import &lt;AFNetworking.h&gt;
#import &lt;MJRefresh.h&gt;
#import &lt;MBProgressHUD.h&gt;

@interface YFMVCPostListViewController ()&lt;UITableViewDelegate, UITableViewDataSource&gt;
@property (nonatomic, strong) UITableView * tableView;
@property (nonatomic, strong) NSMutableArray * articles; //!&lt; 文章数组,内部存储AFArticleModel类型.
@property (assign, nonatomic) NSInteger page; //!&lt; 数据页数.表示下次请求第几页的数据.

@end

@implementation YFMVCPostListViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}

- (NSMutableArray *)articles
{
    if (nil == _articles) {
        _articles = [NSMutableArray arrayWithCapacity: 42];
    }

    return _articles;
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear: animated];

    // 马上进入刷新状态
    [self.tableView.header beginRefreshing];
}

- (UITableView *)tableView
{
    if (nil == _tableView) {
        _tableView = [[UITableView alloc] init];

        [self.view addSubview: _tableView];

        [_tableView makeConstraints:^(MASConstraintMaker *make) {
            make.edges.equalTo(UIEdgeInsetsMake(0, 0, 0, 0));
        }];

        _tableView.delegate = self;
        _tableView.dataSource = self;

        NSString * cellReuseIdentifier = NSStringFromClass([UITableViewCell class]);

        [_tableView registerClass: NSClassFromString(cellReuseIdentifier) forCellReuseIdentifier:cellReuseIdentifier];

        _tableView.header = [MJRefreshNormalHeader headerWithRefreshingBlock:^{
            self.page = 0;

            [self updateData];
        }];

        _tableView.footer = [MJRefreshBackNormalFooter footerWithRefreshingBlock:^{
            [self updateData];
        }];

    }

    return _tableView;
}

/**
 * 更新视图.
 */
- (void) updateView
{
    [self.tableView reloadData];
}

/**
 *  更新数据.
 *
 *  数据更新后,会自动更新视图.
 */

- (void)updateData
{
    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];

    NSString * urlStr = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostListViewController&amp;model[category]=%@&amp;model[page]=%ld", self.categoryName, (long)self.page ++];

    [manager GET: urlStr parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        [self.tableView.header endRefreshing];
        [self.tableView.footer endRefreshing];

        if (1 == self.page) { // 说明是在重新请求数据.
            self.articles = nil;
        }

        NSArray * responseArticles = [YFArticleModel objectArrayWithKeyValuesArray: responseObject];

        [self.articles addObjectsFromArray: responseArticles];

        [self updateView];
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        [self.tableView.header endRefreshing];
        [self.tableView.footer endRefreshing];

        MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
        hud.mode = MBProgressHUDModeText;
        hud.labelText = @"您的网络不给力!";
        [hud hide: YES afterDelay: 2];

    }];
}

# pragma mark - tabelView代理方法.

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    NSInteger number  = self.articles.count;

    return number;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    NSString * cellReuseIdentifier = NSStringFromClass([UITableViewCell class]);

    UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier: cellReuseIdentifier forIndexPath:indexPath];

    YFArticleModel * model = self.articles[indexPath.row];

    NSString * content = [NSString stringWithFormat: @"标题:%@ 内容:%@", model.title, model.desc];

    cell.textLabel.text = content;

    return cell;
}

@end
</code></pre>

<h4>4. 点击某一条数据,可跳转到博客详情页.</h4>

<p>只需要再额外实现下 <code>-tableView: didSelectRowAtIndexPath:</code>方法即可:</p>

<pre><code class="obj-c">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 跳转到博客详情.
    YFArticleModel * articleModel = self.articles[indexPath.row];

    YFMVCPostViewController * postVC = [[YFMVCPostViewController alloc] init];

    postVC.articleID = articleModel.id;

    [self.navigationController pushViewController: postVC animated: YES];
}
</code></pre>

<h3>博客详情页面</h3>

<p><img src="http://ios122.bj.bcebos.com/IMG_1785.PNG" alt="博客详情效果图" /></p>

<h4>1. 在前一页面指定博客id;</h4>

<p>这里其实就是博客列表的控制器的那几句:</p>

<pre><code class="obj-c">// 跳转到博客详情.
YFArticleModel * articleModel = self.articles[indexPath.row];

YFMVCPostViewController * postVC = [[YFMVCPostViewController alloc] init];

postVC.articleID = articleModel.id;

[self.navigationController pushViewController: postVC animated: YES];
</code></pre>

<h4>2. 页面加载时自动发起网络请求获取id的博客详情;</h4>

<p>此处为了方便,我们依然使用预定义的博客详情接口:</p>

<pre><code class="obj-c">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];

    NSString * urlStr = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostViewController&amp;model[id]=%@", self.articleID];

    [manager GET: urlStr parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        NSLog(@"%@", responseObject);

        [self updateView];
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {

        MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
        hud.mode = MBProgressHUDModeText;
        hud.labelText = @"您的网络不给力!";
        [hud hide: YES afterDelay: 2];
    }];
</code></pre>

<p>请求的输入,Xcode控制台打印输出,类似于:</p>

<pre><code class="json">{
    body = "&lt;h2&gt;Hello iOS122&lt;/h2&gt; Scann To Join Us &lt;br /&gt; &lt;image alt=\"qq\" src=\"https://raw.githubusercontent.com/ios122/ios122/master/1443002712802.png\" /&gt;";
    title = "title of ui_0";
}
</code></pre>

<h4>3. 获取成功后,自动刷新视图;获取失败,则给出错误提示.</h4>

<p>你会注意到,我们在上一步获取的数据,body部分内部是HTML字符串,所以我们要使用webView来显示博客详情.这和最近炒得很火的的混合开发模式有些像,但是目前主流的博客应用,几乎都是这么做的.完整代码如下:</p>

<pre><code class="obj-c">//
//  YFMVCPostViewController.m
//  iOS122
//
//  Created by 颜风 on 15/10/16.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFMVCPostViewController.h"
#import "YFArticleModel.h"
#import &lt;AFNetworking.h&gt;
#import &lt;MBProgressHUD.h&gt;


@interface YFMVCPostViewController ()&lt;UIWebViewDelegate&gt;
@property (strong, nonatomic) UIWebView * webView;
@property (strong, nonatomic) YFArticleModel * article;
@end

@implementation YFMVCPostViewController

- (UIWebView *)webView
{
    if (nil == _webView) {
        _webView = [[UIWebView alloc] init];

        [self.view addSubview: _webView];

        [_webView makeConstraints:^(MASConstraintMaker *make) {
            make.edges.equalTo(UIEdgeInsetsMake(64, 0, 0, 0));
        }];
    }

    return _webView;
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear: animated];

    [self updateData];
}


/**
 * 更新视图.
 */
- (void) updateView
{
    [self.webView loadHTMLString: self.article.body baseURL:nil];
}

/**
 *  更新数据.
 *
 *  数据更新后,会自动更新视图.
 */

- (void)updateData
{
    [MBProgressHUD showHUDAddedTo:self.view animated: YES];

    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];

    NSString * urlStr = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostViewController&amp;model[id]=%@", self.articleID];

    [manager GET: urlStr parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        self.article = [YFArticleModel objectWithKeyValues: responseObject];

        [self updateView];
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {

        MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];
        hud.mode = MBProgressHUDModeText;
        hud.labelText = @"您的网络不给力!";
        [hud hide: YES afterDelay: 2];
    }];
}


@end
</code></pre>

<h2>小结</h2>

<p>此篇主要展示了一个典型的列表-->详情场景的MVC实现,相关技术代码可以直接用于自己的项目中.尽管这是简化的场景,但依然可以很明显地看出来数据,网络请求与视图间的相互调用,使代码整体的可复用性大大降低! 而这,也是我们下次要用 MVVM 重构这个示例的核心目的之一!</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[在这一篇章里,我会分别使用我所理解的MVC与MVVM两种模式来完成同一个应用场景,以期帮助那些熟悉传统MVC模式代码的iOS攻城狮,能更好理解MVVM.限于篇幅,将MVC和MVVM拆分为两个部分,今天要说的是一个典型的MVC的应用场景,为基于MVC的MVVM重构做个基础.这篇文章着重进行了接口准备,必须的知识点的说明等内容.]]></excerpt:encoded>
		<wp:post_id>376</wp:post_id>
		<wp:post_date>2015-10-16 18:49:25</wp:post_date>
		<wp:post_date_gmt>2015-10-16 10:49:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mvvm_1</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mvvm"><![CDATA[MVVM]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>29</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(二): 从MVC到MVVM之一个典型应用场景的MVVM版本实现 | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/10/%e5%86%99%e7%bb%99ios%e5%b0%8f%e7%99%bd%e7%9a%84mvvm%e6%95%99%e7%a8%8b%e4%ba%8c-%e4%bb%8emvc%e5%88%b0mvvm%e4%b9%8b%e4%b8%80%e4%b8%aa%e5%85%b8%e5%9e%8b%e5%ba%94%e7%94%a8%e</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-10-23 02:13:26</wp:comment_date>
			<wp:comment_date_gmt>2015-10-22 18:13:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445537606]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445537606.3658330440521240234375;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445537666.084320068359375;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>31</wp:comment_id>
			<wp:comment_author><![CDATA[[干货分享]一篇可能会让你爱上MVVM与ReactiveCocoa的文章 &#8211; iOS122 | 查问题]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.chawenti.com/articles/33561.html</wp:comment_author_url>
			<wp:comment_author_IP>153.92.41.61</wp:comment_author_IP>
			<wp:comment_date>2015-10-23 10:13:09</wp:comment_date>
			<wp:comment_date_gmt>2015-10-23 02:13:09</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 在此工程中,本文将讨论将MVC改造为MVVM需要的一些基本方法,同时会适当穿插部分关于MVVM概念性的讨论!本文最大的意义在于,提供了一种读者可以复现的方式,逐步引出从MVC向MVVM尽可能平滑过渡的一种方案;此外,也是为数不多的ReactiveCocoa实例文章之一.本文是MVVM系列文文章的第二篇,在阅读之前,您可能需要先阅读下第一篇文章: 写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445566389]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445566389.9063320159912109375;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445566889.0652310848236083984375;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>33</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(序) | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/10/mvvm_start/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-10-26 14:37:18</wp:comment_date>
			<wp:comment_date_gmt>2015-10-26 06:37:18</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445841438]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445841438.507464885711669921875;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445841507.33640003204345703125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>ReactiveCocoa,最受欢迎的iOS函数响应式编程库(2.5版),没有之一!</title>
		<link>http://www.ios122.com/2015/10/reactivecocoa/</link>
		<pubDate>Mon, 19 Oct 2015 15:41:44 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=382</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>简介</h2>

<ul>
<li>项目主页: <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></li>
<li>实例下载: <a href="https://github.com/ios122/ios122">https://github.com/ios122/ios122</a></li>
<li>简评: 最受欢迎,最有价值的iOS响应式编程库,没有之一!iOS MVVM模式的完美搭档,更多关于MVVM与ReactiveCocoa的讨论,参考这篇文章: <a href="http://www.cocoachina.com/ios/20150526/11930.html">【长篇高能】ReactiveCocoa 和 MVVM 入门</a></li>
<li>注意: ReactiveCocoa 最新3.0版本,使用Swift重写,最低支持iOS8.0,与国内大多数公司实际现状(一般要求最低兼容iOS7.0)不符;故此处选择兼容性版本更低的 2.5 版本来进行对译与解读.</li>
</ul>

<h2>系统要求</h2>

<ul>
<li>iOS 7.0 + (ReactiveCocoa 2.5 版本)</li>
</ul>

<h2>安装</h2>

<p>推荐使用 CocoaPods 安装:</p>

<pre><code class="ruby">platform :ios, '7.0'

pod "ReactiveCocoa" # RAC,一个支持响应式编程的库.
</code></pre>

<h2>入门</h2>

<p>ReactiveCocoa 灵感来源于 <a href="http://blog.maybeapps.com/post/42894317939/input-and-output">函数响应式编程</a>. ReactiveCocoa通常简称为RAC.RAC中,不再使用变量,而是使用信号(以 <code>RACSignal</code>为代表)来捕捉现在和未来的数据或视图的值.</p>

<p>通过对信号的链接,组合与响应, 软件就可以声明式的方式书写;这样就不再需要频繁地去监测和更新数据或视图的值了.</p>

<p>RAC 主要特性之一就是提供了一种单一又统一的方式来处理各种异步操作--包括代理方法,block回调,target-action机制,通知和KVO等.</p>

<p>这是一个简单的例子:</p>

<pre><code class="objc">// 当self.username变化时,在控制台打印新的名字.
//
// RACObserve(self, username) 创建一个新的 RACSignal 信号对象,它将会发送self.username当前的值,和以后 self.username 发生变化时 的所有新值.
// -subscribeNext: 无论signal信号对象何时发送消息,此block回调都将会被执行.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<p>但是和KVO不同的是, signals信号对象支持链式操作:</p>

<pre><code class="objc">// 只打印以"j"开头的名字.
//
// -filter: 当其bock方法返回YES时,才会返回一个新的RACSignal 信号对象;即如果其block方法返回NO,信号不再继续往下传播.

[[RACObserve(self, username)
    filter:^(NSString *newName) {
        return [newName hasPrefix:@"j"];
    }]
    subscribeNext:^(NSString *newName) {
        NSLog(@"%@", newName);
    }];
</code></pre>

<p>Signals信号也可以用于派生属性(即那些由其他属性的值决定的属性,如Person可能有一个属性为 age年龄 和一个属性 isYong是否年轻,isYong 是由 age 属性的值推断而来,由age本身的值决定).不再需要来监测某个属性的值,然后来对应更新其他受此属性的新值影响的属性的值.RAC 可以支持以signales信号和操作的方式来表达派生属性.</p>

<pre><code class="objc">// 创建一个单向绑定, self.password和self.passwordConfirmation 相等
// 时,self.createEnabled 会自动变为true.
//
// RAC() 是一个宏,使绑定看起来更NICE.
// 
// +combineLatest:reduce:  使用一个 signals 信号的数组;
// 在任意signal变化时,使用他们的最后一次的值来执行block;
// 并返回一个新的 RACSignal信号对象来将block的值用作属性的新值来发送;
// 简单说,类似于重写createEnabled 属性的 getter 方法.

RAC(self, createEnabled) = [RACSignal 
    combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] 
    reduce:^(NSString *password, NSString *passwordConfirm) {
        return @([passwordConfirm isEqualToString:password]);
    }];

// 使用时,是不需要考虑属性是否是派生属性以及以何种方式绑定的:
[RACObserve(self, createEnabled) subscribeNext: ^(NSNumber * enbable){
    NSLog(@"%@", enbable);
}];
</code></pre>

<p>Signals信号可以基于任何随时间变化的数据流创建,不仅仅是KVO.例如说,他们可以用来表示一个按钮的点击事件:</p>

<pre><code class="objc">// 任意时间点击按钮,都会打印一条消息. 
//
// RACCommand 创建代表UI事件的signals信号.例如,单个信号都可以代表一个按钮被点击,
// 然后会有一些额外的操作与处理.
//
// -rac_command 是NSButton的一个扩展.按钮被点击时,会将会把自身发送给rac_command self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {
    NSLog(@"button was pressed!");
    return [RACSignal empty];
}];
</code></pre>

<p>或者异步网络请求:</p>

<pre><code class="objc">// 监听"登陆"按钮,并记录网络请求成功的消息.

// 这个block会在来任意开始登陆步骤,执行登陆命令时调用.

self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {
   // 这是一个假想中的 -logIn 方法, 返回一个 signal信号对象,这个对象在网络对象完成时发送 值.
   // 可以使用 -filter 方法来保证当且仅当网络请求完成时,才返回一个 signal 对象.
    return [client logIn];
}];

// -executionSignals 返回一个signal对象,这个signal对象就是每次执行命令时通过上面的block返回的那个signal对象.
[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {
    // 打印信息,不论何时我们登陆成功.
    [loginSignal subscribeCompleted:^{
        NSLog(@"Logged in successfully!");
    }];
}];

// 当按钮被点击时,执行login命令.
self.loginButton.rac_command = self.loginCommand;
</code></pre>

<p>Signals信号 也可以表示定时器,其他的UI事件,或者任何其他会随时间变化的东西.</p>

<p>在异步操作上使用signals信号,让通过链接和转换这些signal信号,构建更加复杂的行为成为可能.可以在一组操作完成后,来触发此操作即可:</p>

<pre><code class="objc">// 执行两个网络操作,并在它们都完成后在控制台打印信息.
//
// +merge: 传入一组signal信号,并返回一个新的RACSignal信号对象.这个新返回的RACSignal信号对象,传递所有请求的值,并在所有的请求完成时完成.即:新返回的RACSignal信号,在每个请求完成时,都会发送个消息;在所有消息完成时,除了发送消息外,还会触发"完成"相关的block.
//
// -subscribeCompleted: signal信号完成时,将会执行block.
[[RACSignal 
    merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] 
    subscribeCompleted:^{
        NSLog(@"They're both done!");
    }];
</code></pre>

<p>Signals 信号可以被链接以连续执行异步操作,而不再需要嵌套式的block调用.用法类似于:</p>

<pre><code class="objc">// 用户登录,然后加载缓存信息,然后从服务器获取剩余的消息.在这一切完成后,输入信息到控制台.
//
// 假想的 -logInUser 方法,在登录完成后,返回一个signal信号对象.
//
// -flattenMap: 无论任何时候,signal信号发送一个值,它的block都将被执行,然后返回一个新的RACSignal,这个新的RACSignal信号对象会merge合并所有此block返回的signals信号为一个RACSignal信号对象.
[[[[client 
    logInUser] 
    flattenMap:^(User *user) {
        // Return a signal that loads cached messages for the user.
        return [client loadCachedMessagesForUser:user];
    }]
    flattenMap:^(NSArray *messages) {
        // Return a signal that fetches any remaining messages.
        return [client fetchMessagesAfterMessage:messages.lastObject];
    }]
    subscribeNext:^(NSArray *newMessages) {
        NSLog(@"New messages: %@", newMessages);
    } completed:^{
        NSLog(@"Fetched all messages.");
    }];
</code></pre>

<p>RAC 甚至让绑定异步操作的结果也更容易:</p>

<pre><code class="objc">// 创建一个单向的绑定,遮掩self.imagView.image就可以在用户的头像下载完成后自动被设置.
//
// 假定的 -fetchUserWithUsername: 方法返回一个发送用户对象的signal信号对象.
//
// -deliverOn: 创建一个新的 signals 信号对象,以在其他队列来处理他们的任务.
// 在这个示例中,这个方法被用来将任务移到后台队列,并在稍后下载完成后返回主线程中.
//
// -map: 每个获取的用户都会传递进到这个block,然后返回新的RACSignal信号对象,这个
// signal信号对象发送从这个block返回的值.
RAC(self.imageView, image) = [[[[client 
    fetchUserWithUsername:@"joshaber"]
    deliverOn:[RACScheduler scheduler]]
    map:^(User *user) {
        // 下载头像(这在后台执行.)
        return [UIImage imageWithData: [NSData dataWithContentsOfURL: user.avatarURL]];
    }]
    // 现在赋值在主线程完成. 
    deliverOn:RACScheduler.mainThreadScheduler];
</code></pre>

<h2>何时使用 ReactiveCocoa ?</h2>

<p>ReactiveCocoa 非常抽象,初次接触,通常很难理解如何使用它来解决具体的问题.</p>

<p>这是一些使用RAC更具有优势的应用场景:</p>

<h3>处理异步或事件驱动的数据源.</h3>

<p>大多说Cocoa程序的重心在于响应用户事件或程序状态的变化上.处理这些情况的代码,很快就会变得很复杂,就像意大利面条那样,拥有许多的回调和状态变量来处理顺序问题.</p>

<p>一些编程模式,表面上看有些相似,比如 UI回调方法,网络请求的响应和KVO通知等;实际上他们拥有许多的共同点. RACSignal 信号类,统一类这些不同的APIS,以便组合使用和操作它们.</p>

<p>例如,如下代码:</p>

<pre><code class="objc"><br />static void *ObservationContext = &amp;ObservationContext;

- (void)viewDidLoad {
    [super viewDidLoad];

    [LoginManager.sharedManager addObserver:self forKeyPath:@"loggingIn" options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext];
    [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager];

    [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged];
    [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];
}

- (void)dealloc {
    [LoginManager.sharedManager removeObserver:self forKeyPath:@"loggingIn" context:ObservationContext];
    [NSNotificationCenter.defaultCenter removeObserver:self];
}

- (void)updateLogInButton {
    BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0;
    BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn;
    self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;
}

- (IBAction)logInPressed:(UIButton *)sender {
    [[LoginManager sharedManager]
        logInWithUsername:self.usernameTextField.text
        password:self.passwordTextField.text
        success:^{
            self.loggedIn = YES;
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
}

- (void)loggedOut:(NSNotification *)notification {
    self.loggedIn = NO;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (context == ObservationContext) {
        [self updateLogInButton];
    } else {
        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
    }
}
</code></pre>

<p>… 可以用RAC这样重写:</p>

<pre><code class="objc">- (void)viewDidLoad {
    [super viewDidLoad];

    @weakify(self);

    RAC(self.logInButton, enabled) = [RACSignal
        combineLatest:@[
            self.usernameTextField.rac_textSignal,
            self.passwordTextField.rac_textSignal,
            RACObserve(LoginManager.sharedManager, loggingIn),
            RACObserve(self, loggedIn)
        ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) {
            return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue);
        }];

    [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) {
        @strongify(self);

        RACSignal *loginSignal = [LoginManager.sharedManager
            logInWithUsername:self.usernameTextField.text
            password:self.passwordTextField.text];

            [loginSignal subscribeError:^(NSError *error) {
                @strongify(self);
                [self presentError:error];
            } completed:^{
                @strongify(self);
                self.loggedIn = YES;
            }];
    }];

    RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter
        rac_addObserverForName:UserDidLogOutNotification object:nil]
        mapReplace:@NO];
}
</code></pre>

<h3>链式依赖的操作.</h3>

<p>依赖关系通常出现在网络请求中,如后一个请求应该等前一个请求完成后再创建,等等:</p>

<pre><code class="objc">[client logInWithSuccess:^{
    [client loadCachedMessagesWithSuccess:^(NSArray *messages) {
        [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) {
            NSLog(@"Fetched all messages.");
        } failure:^(NSError *error) {
            [self presentError:error];
        }];
    } failure:^(NSError *error) {
        [self presentError:error];
    }];
} failure:^(NSError *error) {
    [self presentError:error];
}];
</code></pre>

<p>ReactiveCocoa 可以特别方便地处理这种逻辑模式:</p>

<pre><code class="objc">[[[[client logIn]
    then:^{
        return [client loadCachedMessages];
    }]
    flattenMap:^(NSArray *messages) {
        return [client fetchMessagesAfterMessage:messages.lastObject];
    }]
    subscribeError:^(NSError *error) {
        [self presentError:error];
    } completed:^{
        NSLog(@"Fetched all messages.");
    }];
</code></pre>

<h3>并行独立的工作.</h3>

<p>使用独立数据的并行工作,然后最终将他们合并到一个结果中,在Cocoa中是很琐碎的,并且常常包含许多同步代码:</p>

<pre><code class="objc">__block NSArray *databaseObjects;
__block NSArray *fileContents;

NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];
NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^{
    databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];
}];

NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^{
    NSMutableArray *filesInProgress = [NSMutableArray array];
    for (NSString *path in files) {
        [filesInProgress addObject:[NSData dataWithContentsOfFile:path]];
    }

    fileContents = [filesInProgress copy];
}];

NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^{
    [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];
    NSLog(@"Done processing");
}];

[finishOperation addDependency:databaseOperation];
[finishOperation addDependency:filesOperation];
[backgroundQueue addOperation:databaseOperation];
[backgroundQueue addOperation:filesOperation];
[backgroundQueue addOperation:finishOperation];
</code></pre>

<p>以上代码可以通过复合使用signals信号对象来优化:</p>

<pre><code class="objc">RACSignal *databaseSignal = [[databaseClient
    fetchObjectsMatchingPredicate:predicate]
    subscribeOn:[RACScheduler scheduler]];

RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&lt;RACSubscriber&gt; subscriber) {
    NSMutableArray *filesInProgress = [NSMutableArray array];
    for (NSString *path in files) {
        [filesInProgress addObject:[NSData dataWithContentsOfFile:path]];
    }

    [subscriber sendNext:[filesInProgress copy]];
    [subscriber sendCompleted];
}];

[[RACSignal
    combineLatest:@[ databaseSignal, fileSignal ]
    reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) {
        [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents];
        return nil;
    }]
    subscribeCompleted:^{
        NSLog(@"Done processing");
    }];
</code></pre>

<h3>简化集合的转换.</h3>

<p>更高层级的排序函数,比如 <code>map</code>(映射), <code>filter</code>(过滤器), <code>fold</code>(折叠)/<code>reduce</code>(减少),在Foundation 中严重缺失; 这导致必须编写类似于下面的循环代码:</p>

<pre><code class="objc">NSMutableArray *results = [NSMutableArray array];
for (NSString *str in strings) {
    if (str.length &lt; 2) {
        continue;
    }

    NSString *newString = [str stringByAppendingString:@"foobar"];
    [results addObject:newString];
}
</code></pre>

<p>RACSequence 允许任何Cocoa集合可以使用统一的声明式语法来操作:</p>

<pre><code class="objc">RACSequence *results = [[strings.rac_sequence
    filter:^ BOOL (NSString *str) {
        return str.length &gt;= 2;
    }]
    map:^(NSString *str) {
        return [str stringByAppendingString:@"foobar"];
    }];
</code></pre>
]]></content:encoded>
		<excerpt:encoded><![CDATA[最受欢迎,最有价值的iOS响应式编程库,没有之一!iOS MVVM模式的完美搭档,更多关于MVVM与ReactiveCocoa的讨论,参考这篇文章: [【长篇高能】ReactiveCocoa 和 MVVM 入门](http://www.cocoachina.com/ios/20150526/11930.html)
* 注意: ReactiveCocoa 最新3.0版本,使用Swift重写,最低支持iOS8.0,与国内大多数公司实际现状(一般要求最低兼容iOS7.0)不符;故此处选择兼容性版本更低的 2.5 版本来进行对译与解读.]]></excerpt:encoded>
		<wp:post_id>382</wp:post_id>
		<wp:post_date>2015-10-19 23:41:44</wp:post_date>
		<wp:post_date_gmt>2015-10-19 15:41:44</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>reactivecocoa</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mvvm"><![CDATA[MVVM]]></category>
		<category domain="post_tag" nicename="reactivecocoa"><![CDATA[ReactiveCocoa]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>26</wp:comment_id>
			<wp:comment_author><![CDATA[龚佳亮]]></wp:comment_author>
			<wp:comment_author_email>gongjialiang@126.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>61.50.136.210</wp:comment_author_IP>
			<wp:comment_date>2015-10-20 10:06:43</wp:comment_date>
			<wp:comment_date_gmt>2015-10-20 02:06:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[arc的block嵌套貌似很深，效率可能会有影响，而且这样会不会把整个逻辑绑定的太紧，不利于单元测试？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445306803]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445306803.314487934112548828125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445313337.3306000232696533203125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>27</wp:comment_id>
			<wp:comment_author><![CDATA[iOS122 运营组]]></wp:comment_author>
			<wp:comment_author_email>yanfengstyle@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.247.180.210</wp:comment_author_IP>
			<wp:comment_date>2015-10-20 11:55:37</wp:comment_date>
			<wp:comment_date_gmt>2015-10-20 03:55:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[RAC 结合 MVVM 使用,会有更好的效果! RAC, 需要的不是block嵌套! 另外,单独测试的是ViewModel部分,也不会受RAC的影响!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>26</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445313337]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";d:1445313337.366345882415771484375;s:5:"event";s:11:"check-error";s:4:"user";s:12:"yanfengstyle";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>28</wp:comment_id>
			<wp:comment_author><![CDATA[Saucheong Ye]]></wp:comment_author>
			<wp:comment_author_email>sauchyer@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://sauchye.com/</wp:comment_author_url>
			<wp:comment_author_IP>121.34.144.197</wp:comment_author_IP>
			<wp:comment_date>2015-10-22 19:02:45</wp:comment_date>
			<wp:comment_date_gmt>2015-10-22 11:02:45</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好东西，顶~]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445511765]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445511765.4692919254302978515625;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445522315.923286914825439453125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>30</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(二): 从MVC到MVVM之一个典型应用场景的MVVM版本实现 | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/10/mvvm_2/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-10-23 02:13:47</wp:comment_date>
			<wp:comment_date_gmt>2015-10-22 18:13:47</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] ReactiveCocoa,最受欢迎的iOS函数响应式编程库(2.5版),没有之一! [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445537627]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445537627.284410953521728515625;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445537663.0161240100860595703125;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
		<title>Mantle--国外程序员最常用的iOS模型&amp;字典转换框架</title>
		<link>http://www.ios122.com/2015/10/mantle/</link>
		<pubDate>Tue, 20 Oct 2015 08:22:37 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=387</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>Mantle简介</h2>

<p><a href="https://github.com/mantle/mantle">Mantle</a>是iOS和Mac平台下基于Objective-C编写的一个简单高效的模型层框架。</p>

<h2>Mantle能做什么</h2>

<p>Mantle可以轻松把JSON数据、字典（Dictionary）和模型（即Objective对象）之间的相互转换，支持自定义映射，并且内置实现了NSCoding和NSCoping，大大简化归档操作。</p>

<h2>为什么要使用Mantle</h2>

<h3>传统的模型层方案遇到的问题</h3>

<p>通常我们用Objective－C写的模型层遇到了什么问题？</p>

<p>我们可以用<a href="https://developer.github.com/">Github API</a>来举例。现在假设我们想用Objective-C展现一个<a href="https://developer.github.com/v3/issues/#get-a-single-issue">Github Issue</a>，应该怎么做？</p>

<p>目前我们可以想到</p>

<ol>
<li><p>直接解析JSON数据字典，然后展现给UI</p></li>
<li><p>将JSON数据转换为模型，在赋值给UI</p></li>
</ol>

<p>关于1，弊端有很多，可以参考我的这篇文章：<a href="http://www.terwer.com/ios-dict-to-model.html">在iOS开发中使用字典转模型</a>，现在假设我们选择了2，我们大致会定义下面的<code>GHIssue</code>模型：</p>

<p>GHIssue.h</p>

<pre><code class="objc">    #import &lt;Foundation/Foundation.h&gt;

    typedef enum : NSUInteger {
        GHIssueStateOpen,
        GHIssueStateClosed
    } GHIssueState;

    @class GHUser;
    @interface GHIssue : NSObject &lt;NSCoding, NSCopying&gt;

    @property (nonatomic, copy, readonly) NSURL *URL;
    @property (nonatomic, copy, readonly) NSURL *HTMLURL;
    @property (nonatomic, copy, readonly) NSNumber *number;
    @property (nonatomic, assign, readonly) GHIssueState state;
    @property (nonatomic, copy, readonly) NSString *reporterLogin;
    @property (nonatomic, copy, readonly) NSDate *updatedAt;
    @property (nonatomic, strong, readonly) GHUser *assignee;
    @property (nonatomic, copy, readonly) NSDate *retrievedAt;

    @property (nonatomic, copy) NSString *title;
    @property (nonatomic, copy) NSString *body;

    - (instancetype)initWithDictionary:(NSDictionary *)dictionary;

    @end
</code></pre>

<p>GHIssue.m</p>

<pre><code class="objc">    #import "GHIssue.h"
    #import "GHUser.h"

    @implementation GHIssue

    + (NSDateFormatter *)dateFormatter {
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
        dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
        return dateFormatter;
    }

    - (instancetype)initWithDictionary:(NSDictionary *)dictionary {
        self = [self init];
        if (self == nil) return nil;

        _URL = [NSURL URLWithString:dictionary[@"url"]];
        _HTMLURL = [NSURL URLWithString:dictionary[@"html_url"]];
        _number = dictionary[@"number"];

        if ([dictionary[@"state"] isEqualToString:@"open"]) {
            _state = GHIssueStateOpen;
        } else if ([dictionary[@"state"] isEqualToString:@"closed"]) {
            _state = GHIssueStateClosed;
        }

        _title = [dictionary[@"title"] copy];
        _retrievedAt = [NSDate date];
        _body = [dictionary[@"body"] copy];
        _reporterLogin = [dictionary[@"user"][@"login"] copy];
        _assignee = [[GHUser alloc] initWithDictionary:dictionary[@"assignee"]];

        _updatedAt = [self.class.dateFormatter dateFromString:dictionary[@"updated_at"]];

        return self;
    }

    - (instancetype)initWithCoder:(NSCoder *)coder {
        self = [self init];
        if (self == nil) return nil;

        _URL = [coder decodeObjectForKey:@"URL"];
        _HTMLURL = [coder decodeObjectForKey:@"HTMLURL"];
        _number = [coder decodeObjectForKey:@"number"];
        _state = [coder decodeIntegerForKey:@"state"];
        _title = [coder decodeObjectForKey:@"title"];
        _retrievedAt = [NSDate date];
        _body = [coder decodeObjectForKey:@"body"];
        _reporterLogin = [coder decodeObjectForKey:@"reporterLogin"];
        _assignee = [coder decodeObjectForKey:@"assignee"];
        _updatedAt = [coder decodeObjectForKey:@"updatedAt"];

        return self;
    }

    - (void)encodeWithCoder:(NSCoder *)coder {
        if (self.URL != nil) [coder encodeObject:self.URL forKey:@"URL"];
        if (self.HTMLURL != nil) [coder encodeObject:self.HTMLURL forKey:@"HTMLURL"];
        if (self.number != nil) [coder encodeObject:self.number forKey:@"number"];
        if (self.title != nil) [coder encodeObject:self.title forKey:@"title"];
        if (self.body != nil) [coder encodeObject:self.body forKey:@"body"];
        if (self.reporterLogin != nil) [coder encodeObject:self.reporterLogin forKey:@"reporterLogin"];
        if (self.assignee != nil) [coder encodeObject:self.assignee forKey:@"assignee"];
        if (self.updatedAt != nil) [coder encodeObject:self.updatedAt forKey:@"updatedAt"];

        [coder encodeInteger:self.state forKey:@"state"];
    }

    - (instancetype)copyWithZone:(NSZone *)zone {
        GHIssue *issue = [[self.class allocWithZone:zone] init];
        issue-&gt;_URL = self.URL;
        issue-&gt;_HTMLURL = self.HTMLURL;
        issue-&gt;_number = self.number;
        issue-&gt;_state = self.state;
        issue-&gt;_reporterLogin = self.reporterLogin;
        issue-&gt;_assignee = self.assignee;
        issue-&gt;_updatedAt = self.updatedAt;

        issue.title = self.title;
        issue-&gt;_retrievedAt = [NSDate date];
        issue.body = self.body;

        return issue;
    }

    - (NSUInteger)hash {
        return self.number.hash;
    }

    - (BOOL)isEqual:(GHIssue *)issue {
        if (![issue isKindOfClass:GHIssue.class]) return NO;

        return [self.number isEqual:issue.number] &amp;&amp; [self.title isEqual:issue.title] &amp;&amp; [self.body isEqual:issue.body];
    }
</code></pre>

<p>GHUser.h</p>

<pre><code class="objc">    @interface GHUser : NSObject &lt;NSCoding, NSCopying&gt;

    @property (nonatomic, copy) NSString *login;
    @property (nonatomic, assign) NSUInteger id;
    @property (nonatomic, copy) NSString *avatarUrl;
    @property (nonatomic, copy) NSString *gravatarId;
    @property (nonatomic, copy) NSString *url;
    @property (nonatomic, copy) NSString *htmlUrl;
    @property (nonatomic, copy) NSString *followersUrl;
    @property (nonatomic, copy) NSString *followingUrl;
    @property (nonatomic, copy) NSString *gistsUrl;
    @property (nonatomic, copy) NSString *starredUrl;
    @property (nonatomic, copy) NSString *subscriptionsUrl;
    @property (nonatomic, copy) NSString *organizationsUrl;
    @property (nonatomic, copy) NSString *reposUrl;
    @property (nonatomic, copy) NSString *eventsUrl;
    @property (nonatomic, copy) NSString *receivedEventsUrl;
    @property (nonatomic, copy) NSString *type;
    @property (nonatomic, assign) BOOL siteAdmin;

    - (id)initWithDictionary:(NSDictionary *)dictionary;

    @end
</code></pre>

<p>你会看到，如此简单的事情却有很多弊端。甚至，还有一些其他问题，这个例子里面没有展示出来。</p>

<ol>
<li>无法使用服务器的新数据来更新这个 <code>GHIssue</code></li>
<li>无法反过来将 <code>GHIssue</code> 转换成 <code>JSON</code></li>
<li>对于<code>GHIssueState</code>，如果枚举改编了，现有的归档会崩溃</li>
<li>如果 <code>GHIssue</code> 接口改变了，现有的归档会崩溃。</li>
</ol>

<h3>使用MTLModel</h3>

<p>如果使用MTLModel，我们可以这样，声明一个类继承自MTLModel</p>

<pre><code class="objc">    typedef enum : NSUInteger {
        GHIssueStateOpen,
        GHIssueStateClosed
    } GHIssueState;

    @interface GHIssue : MTLModel &lt;MTLJSONSerializing&gt;

    @property (nonatomic, copy, readonly) NSURL *URL;
    @property (nonatomic, copy, readonly) NSURL *HTMLURL;
    @property (nonatomic, copy, readonly) NSNumber *number;
    @property (nonatomic, assign, readonly) GHIssueState state;
    @property (nonatomic, copy, readonly) NSString *reporterLogin;
    @property (nonatomic, strong, readonly) GHUser *assignee;
    @property (nonatomic, copy, readonly) NSDate *updatedAt;

    @property (nonatomic, copy) NSString *title;
    @property (nonatomic, copy) NSString *body;

    @property (nonatomic, copy, readonly) NSDate *retrievedAt;

    @end
    @implementation GHIssue

    + (NSDateFormatter *)dateFormatter {
        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
        dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
        return dateFormatter;
    }

    + (NSDictionary *)JSONKeyPathsByPropertyKey {
        return @{
            @"URL": @"url",
            @"HTMLURL": @"html_url",
            @"number": @"number",
            @"state": @"state",
            @"reporterLogin": @"user.login",
            @"assignee": @"assignee",
            @"updatedAt": @"updated_at"
        };
    }

    + (NSValueTransformer *)URLJSONTransformer {
        return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
    }

    + (NSValueTransformer *)HTMLURLJSONTransformer {
        return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
    }

    + (NSValueTransformer *)stateJSONTransformer {
        return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
            @"open": @(GHIssueStateOpen),
            @"closed": @(GHIssueStateClosed)
        }];
    }

    + (NSValueTransformer *)assigneeJSONTransformer {
        return [MTLJSONAdapter dictionaryTransformerWithModelClass:GHUser.class];
    }

    + (NSValueTransformer *)updatedAtJSONTransformer {
        return [MTLValueTransformer transformerUsingForwardBlock:^id(NSString *dateString, BOOL *success, NSError *__autoreleasing *error) {
            return [self.dateFormatter dateFromString:dateString];
        } reverseBlock:^id(NSDate *date, BOOL *success, NSError *__autoreleasing *error) {
            return [self.dateFormatter stringFromDate:date];
        }];
    }

    - (instancetype)initWithDictionary:(NSDictionary *)dictionaryValue error:(NSError **)error {
        self = [super initWithDictionary:dictionaryValue error:error];
        if (self == nil) return nil;

        // Store a value that needs to be determined locally upon initialization.
        _retrievedAt = [NSDate date];

        return self;
    }

    @end
</code></pre>

<p>很明显，我们不需要再去实现<code>&lt;NSCoding&gt;</code>, <code>&lt;NSCopying&gt;</code>, <code>-isEqual:</code>和<code>-hash</code>。在你的子类里面生命属性，MTLModel可以提供这些方法的默认实现。</p>

<p>最初例子里面的问题，在这里都得到了很好的解决。</p>

<ul>
<li><p>MTLModel提供了一个<code>- (void)mergeValueForKey:(NSString *)key fromModel:(id&lt;MTLModel&gt;)model{}</code>,可以与其他任何实现了MTLModel协议的模型对象集成。</p></li>
<li><p><code>+[MTLJSONAdapter JSONDictionaryFromModel:error:]</code>可以把任何遵循<code>MTLJSONSerializing&gt;``协议的对象转换成JSON字典，</code>+[MTLJSONAdapter JSONArrayFromModels:error:]```类似，不过转换的是一个数组。</p></li>
</ul>

<p><code>MTLJSONAdapter</code>中的<code>fromJSONDictionary</code>和<code>JSONDictionaryFromModel</code>可以实现模型和JSON的相互转化。</p>

<p><code>JSONKeyPathsByPropertyKey</code>可以实现模型和JSON的自定义映射。</p>

<p><code>JSONTransformerForKey</code>可以对JSON和模型不同类型进行映射。</p>

<p><code>classForParsingJSONDictionary</code> 如果你使用了类簇（关于类簇，请参考：<a href="http://limboy.me/ios/2014/01/04/class-cluster.html">类簇在iOS开发中的应用</a>），classForParsingJSONDictionary可以让你选择使用哪一个类进行JSON反序列化。</p>

<ul>
<li>MTLModel可以用归档很好的存储模型而不需要去实现令人厌烦的NSCoding协议。 <code>-decodeValueForKey:withCoder:modelVersion:</code>方法在解码时会自动调用，如果重写，可以方便的进行自定义。</li>
</ul>

<h2>持久化</h2>

<h3>Mantle配合归档</h3>

<p>MTLModel默认实现了   <code>NSCoding</code>协议，可以利用<code>NSKeyedArchiver</code>方便的对对象进行归档和解档。</p>

<h3>Mantle配合Core Data</h3>

<p>除了SQLite、FMDB之外，如果你想在你的数据里面执行复杂的查询，处理很多关系，支持撤销恢复，Core Data非常适合。</p>

<p>然而，这样也带来了一些痛点：</p>

<ul>
<li>仍然有很多弊端<code>Managed objects</code>解决了上面看到的一些弊端，但是Core Data自生也有他的弊端。正确的配置Core Data和获取数据需要很多行代码。</li>
<li>很难保持正确性。甚至有经验的人在使用Core Data时也会犯错，并且这些问题框架是无法解决的。</li>
</ul>

<p>如果你想获取JSON对象，Core Data需要做很多工作，但是却只能得到很少的回报。</p>

<p>但是，如果你已经在你的APP里面使用了Core Data，Mantle将仍然会是你的API和你的managed model objects之间一个很方便的转换层。</p>

<h3>Mantle配合MagicRecord（一个Core Data框架）</h3>

<p>参考 <a href="http://bawn.github.io/ios/2014/12/15/MagicalRecord.html">MagicalRecord配合Mantle</a></p>

<h2>Mantle为我们带来的好处</h2>

<ul>
<li><p>实现了NSCopying protocol，子类可以直接copy是多么爽的事情</p></li>
<li><p>实现了NSCoding protocol，跟NSUserDefaults说拜拜</p></li>
<li><p>提供了-isEqual:和-hash的默认实现，model作NSDictionary的key方便了许多</p></li>
<li><p>支持自定义映射，这在接口改变的情况下很有用</p></li>
<li><p>简单且把一件事情做好，不掺杂网络相关的操作</p></li>
</ul>

<h2>合理选择</h2>

<p>虽然上面说了一系列的好处，但如果你的App的代码规模只有几万行，或者API只有十几个，或者没有遇到上面这些问题， 建议还是不要引入了，杀鸡用指甲刀就够了。但是，Mantle的实现和思路是值得每位iOS工程师学习和借鉴的。</p>

<h2>代码</h2>

<p><a href="https://github.com/terwer/MantleDemo">https://github.com/terwer/MantleDemo</a></p>

<h2>参考</h2>

<p><a href="https://github.com/mantle/mantle">https://github.com/mantle/mantle</a></p>

<p><a href="http://segmentfault.com/a/1190000002431365">http://segmentfault.com/a/1190000002431365</a></p>

<p><a href="http://yyny.me/ios/Mantle%E3%80%81JSONModel%E3%80%81MJExtension%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/">http://yyny.me/ios/Mantle%E3%80%81JSONModel%E3%80%81MJExtension%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</a></p>

<p>PS: 本文由我们<a href="http:www.ios122.com">iOS122</a>的小伙伴<a href="http://weibo.com/206464069">@TerwerGreen</a>整理编辑,欢迎大家到他的<a href="http://blog.terwer.com">个人博客terwer</a>共同论道!</p>
]]></content:encoded>
		<excerpt:encoded><![CDATA[Mantle可以轻松把JSON数据、字典（Dictionary）和模型（即Objective对象）之间的相互转换，支持自定义映射，并且内置实现了NSCoding和NSCoping，大大简化归档操作。]]></excerpt:encoded>
		<wp:post_id>387</wp:post_id>
		<wp:post_date>2015-10-20 16:22:37</wp:post_date>
		<wp:post_date_gmt>2015-10-20 08:22:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mantle</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mantle"><![CDATA[Mantle]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>写给iOS小白的MVVM教程(二): 从MVC到MVVM之一个典型应用场景的MVVM版本实现</title>
		<link>http://www.ios122.com/2015/10/mvvm_2/</link>
		<pubDate>Thu, 22 Oct 2015 18:13:07 +0000</pubDate>
		<dc:creator><![CDATA[yanfengstyle]]></dc:creator>
		<guid isPermaLink="false">http://www.ios122.com/?p=391</guid>
		<description></description>
		<content:encoded><![CDATA[<h2>概要</h2>

<p>在此工程中,本文将讨论将MVC改造为MVVM需要的一些基本方法,同时会适当穿插部分关于MVVM概念性的讨论!本文最大的意义在于,提供了一种读者可以复现的方式,逐步引出从MVC向MVVM尽可能平滑过渡的一种方案;此外,也是为数不多的ReactiveCocoa实例文章之一.本文是MVVM系列文文章的第二篇,在阅读之前,您可能需要先阅读下第一篇文章: <a href="http://www.ios122.com/2015/10/mvvm_1/">写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景</a></p>

<p>Apple本身的UIKit框架是为MVC模式设计的,所以你在无形之中写就的代码其实就是MVC,而且你甚至会觉得代码就应该这么写,不这么写还能怎么写?!MVVM由于缺乏框架级别的支持,所以在iOS的开发中一直似乎是很鸡肋式的存在.直到出现了<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>!它从框架界别支持MVVM模式,它让你真切地感觉到自己以前的代码真的太乱了,它也让你真正有兴趣去尝试下一些比较流行的编程模式,比如响应式,函数式,MVVM等.出于自己的实际项目需要,必须最低支持 iOS 7版本,所以在进行本文之前,先对 RAC(ReactiveCocoa的简称,后文同)作了一番研究.虽然官方文档指明 3.0版本的RAC,最低支持的 是iOS 8.0,但是我们依然可以通过 CocoaPods 安装 2.5版本的ReactiveCocoa来在自己的项目中使用,具体细节参见: <a href="http://www.ios122.com/2015/10/reactivecocoa/">ReactiveCocoa,最受欢迎的iOS函数响应式编程库(2.5版),没有之一!</a></p>

<h2>基本概念篇: MVC VS MVVM</h2>

<h3>MVC</h3>

<p>提到MVC,你现在可以先自己回想一下自己写过的程序,然后再往下看.</p>

<ul>
<li>M 指的是Model,数据模型,它可以是一个系统自身的类型,比如字符串,数组等,也可以是一个自定义的类型. 以上篇文章为例,你可以认为 YFMVCPostListViewController 的 categoryName 属性是一个Model,也可以认为 articles 属性是Model.Model 就是那个用来存储数据的东西.</li>
<li>V,指的是View,通俗点说,所有UIView及其子类都属于V部分.</li>
<li>C,指的就是UIViewController 及其子类.</li>
</ul>

<p>所以说, UIKit自身就是为MVC模式设计的,而你就算不清除什么是MVC,但你的代码其实就是MVC模式.当你阅读自己以前的代码或者别人的代码时,经常感觉这个代码写的好乱(shi)啊,其实这真的不是自己或别人的锅,这是MVC本身难以避免甚至必然会出现的一个坑!所以,后来有人借鉴其他语言,提出了MVVM模式,并躬身实践!</p>

<h3>MVVM</h3>

<p>首先,MVVM,从概念说上来说,真的很好,很吸引人,即使你可能看不太懂,也感觉很高大上的样子!但是,当你真的去百度相关概念时,往往会很纳闷,似乎比我现在还麻烦,甚至开始怀疑,MVVM应该还只停留在理论阶段吧!--NO,只是因为你没有找到合适的文章,没有找到合适的工具--ReactiveCocoa!还是先说一下 MVVM的基础概念吧,不然没法往下说了:</p>

<ul>
<li>第一个M,和MVC中的M基本一样.但是要求更轻量级.MVC中的M,你可以会放一些和原始数据不相关的推断出来的属性或者工具方法,如Person类,你可能给他写一个方法来根据原始数据年龄来判断是否有资格做某事,比如结婚;但是MVVM中的M,根据我的理解,你直接用它来存放元数据(这里,可能还是有争议的,仅是个人的理解与实践).</li>
<li>第一个V,比MVC中的V要更广泛些,它包括 UIView 与 UIViewController及其子类,View用来显示和交互,UIViewController担当一种类似于桥梁的角色,来使 View 和 ViewModel部分更好通信.</li>
<li>余下的"VM",其实是一个整体,指的是ViewModel,视图数据模型.如果你以前的许多代码都放在Model中,比如没有数据自动联网请求相关的数据什么的话,那你的那个Model其实和这个ViewModel有些像.MVVM中,要求Model更薄,最好只存储原始数据信息;而对于其他的设计到逻辑的代码,建议都放到ViewModel中.你可能会说,这样ViewModel 会不会很乱呢?未必!ViewModel中的代码会很多,但是ViewModel的可复用性和灵活性要远远大于ViewController.更具体点说,以前的一个控制器里面的代码,现在可能会被拆分到1个甚至多个ViewModel中,而且你的ViewModel不仅这个控制器可以用,其他的控制器也可以用.虽然从单个控制器的逻辑代码量来看,优化不是很显著,但是ViewModel的模块化特性,将在涉及到页面复用以及后期维护时,让人感觉心旷神怡!</li>
</ul>

<p>关于MVVM,网上还有一种观点是,其实可以不要Model层,直接使用ViewModel层来存储数据.个人感觉,如果考虑到单元测试,此时如果有单独的Model部分,可以根据一个Model,直接测试ViewModel的逻辑,是极好的,所以目前还是继续保留Model部分.另外,也是考虑到后期可能会设计到Model本身的变更,比如将Model由一个普通的NSObjet变为CoreData的一个实体,可以很容易地让代码支持本地化.</p>

<p>此时,我还在考虑的一点是,公司代码其实Model部分不是由我负责的,如果想继续引入MVVM改造项目,保留一个ViewModel层,也可以使我的代码对其他项目成员的影响降到最低.想来也是极好的!</p>

<h2>变革: 从MVC到MVVM</h2>

<p>接下来,会以第一篇文章的示例为基础,将逐步改造为MVVM模式.</p>

<h3>为View写的数据模型: Model --> Model + ViewModel</h3>

<p>我的观点是,尽量不要使用系统自带的数据类型,比如数组,字典等作为Model,要尽可能地使用自定义地类.使用自定义的类,方便后期维护,也可以避免一些基础错误,如:自定义的类,如果属性不匹配会编译失败,但是如果使用字典类型,key不匹配时,是不会有任何提示的(用过字典的童鞋,都懂我意思的吧).所以我们此处要:</p>

<ul>
<li>新增Model: YFCategoryArticleListModel,表示按分类分组的文章列表,其中有两个字段:category,分类;articles,此分类下的文章列表.</li>
<li>新增ViewModel: YFBlogDetailViewModel 表示文章的视图模型;YFBlogListViewModel 表示 分类文章列表的视图模型; YFBlogListItemViewModel 表示文章列表单个单元格的视图模型;</li>
</ul>

<p>Model仅用于存储数据,ViewModel的具体逻辑下面需要时,会具体分析.另外,必须提到一点的是 <a href="http://www.cnblogs.com/ludashi/">@青玉伏案</a>,给我推荐了一个RAC的VM框架<a href="https://github.com/ReactiveCocoa/ReactiveViewModel">ReactiveViewModel</a>,有兴趣的可以研究下.但是我不是很能理解这么做的必要性,所以暂时我还是按照我自己的理解,用最常规的方式来写ViewModel部分.</p>

<h3>使用ViewModel作为模块入口: M + C --> VM + C</h3>

<p>就像我开篇序言中提到的那样,MVVM系列的文章,不单单是关于MVVM的讨论,更是关于如何将已有MVC项目逐步过渡为MVVM架构的可行性以及方法步骤的探究.这里我采用的是一种折中的更具可行性的方案: 我对外暴露的接口是ViewModel,但是对应的会给这个ViewModel提供一个使用Model作为参数的便利初始化方法;控制器或模块内部,就直接使用传入的ViewModel.这样,我觉得才是极好的,一方面自己可以践行MVVM,提前踩踩坑,另一方面也基本不会对其他小伙伴的开发工作造成太多的困扰!具体到本文示例,具体指:</p>

<ul>
<li>文章列表控制器: 为了与MVC模式区分,新建控制器YFMVVMPostListViewController,并添加够公有属性viewModel,它是YFCategoryArticleListViewModel 类型.</li>
<li>文章详情控制器: 为了与MVC模式区分,新建控制器YF</li>
<li>MVVMPostListViewController,仅添加只读属性viewModel,它是YFArticleViewModel类型.</li>
</ul>

<p>关于ViewModel的自定义下面会具体谈到.</p>

<h3>实现ViewModel.</h3>

<p>必须指出的一点是: ViewModel是为View服务的,它的命名和字段定义应该根据View的需要来进行.本例是一个非常简单的场景.在复杂的场景中,一个model可能对应多个viewModel,此时多个视图可能都是同一种数据的不同展示方式;一个viewModel可能对应多个model,此时页面比较复杂,设计到多种数据的展示.简言之,应该是一个View对应一个ViewModel(这一点,可能也有待商榷,但暂时我会采取此种方式).所以,你的ViewModel中的属性不必和某个Model有真正意义上的对应关系,而是应该根据它服务的View来写和命名.</p>

<h4>YFBlogListItemViewModel 博客列表单个单元格的视图模型</h4>

<ul>
<li>添加属性intro: 这个viewModel 供展示博客列表中的单个单元格使用,但根据目前的UI显示,只需要一个字段即可,我们给它命名为 intro,字符串属性.这个后期可以根据UI变化动态更改.就像上面提到的,ViewModel是为Model服务的.</li>
<li>添加属性 blogId.</li>
<li>添加初始化方法 -initWithArticleModel: 以便于从一个YFArticleModel对象构建视图模型.</li>
<li>注意需要在初始化时设置 introl和model的title,desc属性的级联关系(我喜欢这么称呼,意会,有点重写getter方法的感觉).这一步本来是在Controller中完成的,现在挪到了 ViewModel中,Controller 不就瘦了一点了吗,而且把这个逻辑写到这里还更方便代码复用.</li>
</ul>

<pre><code class="objc">- (instancetype)initWithArticleModel:(YFArticleModel *)model
{
    self = [super init];

    if (nil != self) {
        // 设置intro属性和model的属性的级联关系.
        RAC(self, intro) = [RACSignal combineLatest:@[RACObserve(model, title), RACObserve(model, desc)] reduce:^id(NSString * title, NSString * desc){
            NSString * intro = [NSString stringWithFormat: @"标题:%@ 内容:%@", model.title, model.desc];

            return intro;
        }];

        // 设置self.blogId与model.id的相互关系.
        [RACObserve(model, id) subscribeNext:^(id x) {
            self.blogId = x;
        }];
    }

    return self;
}
</code></pre>

<h4>YFBlogListViewModel 博文列表的视图模型.</h4>

<ul>
<li>添加属性blogListItemViewModels,NSArray 类型,用于存储文章列表单元格的视图模型.视图部分检测它的变化,然后动态刷新视图即可.</li>
<li>添加工具方法: -first 与 -next,用于支持常见的数据分页操作,配合blogListItemViewModels,可以实现常见的上拉刷新与加载加载的操作.</li>
<li>添加初始化方法 -initWithCategoryArtilceListModel, 用于快速使用一个分类文章列表数据模型来快速初始化.再次强调一次: model 和 viewModel 并不是一一对应的关系,这里只是为了简化从一种Model生成此种ViewModel的操作;即,以后如果有其他种类的可以使用此种ViewModel的话,我们再为其添加一个从新Model初始化的方法即可.</li>
<li>初始化时,涉及到网络请求,在此处我们额外引入了一个AFN扩展 <a href="https://github.com/CodaFi/AFNetworking-RACExtensions">AFNetworking-RACExtensions</a>,用于使用RAC的语法格式使用AFN.</li>
</ul>

<pre><code class="objc">// 接口完整地址,肯定是受分类和页面的影响的.但是因为分类的变化最终会通过分页的变化来体现,所以此处仅需监测分页的变化情况即可.
[RACObserve(self, nextPageNumber) subscribeNext:^(NSNumber * nextPageNumber) {
    NSString * path = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostListViewController&amp;model[category]=%@&amp;model[page]=%@", self.category, nextPageNumber];

    self.requestPath = path;
}];

// 每次数据完整接口变化时,必然要同步更新 blogListItemViewModels 的值.
[RACObserve(self, requestPath) subscribeNext:^(NSString * path) {
    /**
     *  分两种情况: 如果是变为0,说明是重置数据;如果是大于0,说明是要加载更多数据;不处理向上翻页的情况.
     */

    NSMutableArray * articls = [NSMutableArray arrayWithCapacity: 42];

    if (YES != [self.nextPageNumber isEqualToNumber: @0]) {
        [articls addObjectsFromArray: self.blogListItemViewModels];
    }

    [[self.httpClient rac_GET:path parameters:nil] subscribeNext:^(RACTuple *JSONAndHeaders) {
        // 使用MJExtension将JSON转换为对应的数据模型.
        NSArray * newArticles = [YFArticleModel objectArrayWithKeyValuesArray: JSONAndHeaders.first];

        // RAC 风格的数组操作.
        RACSequence * newblogViewModels = [newArticles.rac_sequence
                                map:^(YFArticleModel * model) {
                                    YFBlogListItemViewModel * vm = [[YFBlogListItemViewModel alloc] initWithArticleModel: model];

                                    return vm;
                                }];


        [articls addObjectsFromArray: newblogViewModels.array];

        self.blogListItemViewModels = articls;
    }];
}];
</code></pre>

<p>关于MVVM的优势,此处已可见一斑!我们成功的从控制器中剥离了网络请求以及数据分页的相关代码.从整体代码量的角度,我们可能没少写几行代码;但是从代码复用性的角度考虑,我们的代码更具有可复用性,因为将来可能其他地方也会用到这个页面;与此同时,代码之间的耦合性也降低了很多;可扩展性大大提高![PS: 关于代码耦合性,可复用性什么的,真的很大程度上是由模式本身决定的!]</p>

<h4>YFBlogDetailViewModel 文章详情页的视图模型.</h4>

<ul>
<li>添加属性content,用于直接在网页视图上显示,View内检测这个属性值,动态刷新视图即可.</li>
<li>添加初始化方法 -initWithModel: 用于方便从一个 YFArticleModel 数据模型新建相应的视图模型.</li>
<li>设计到网络请求部分的核心代码如下:</li>
</ul>

<pre><code class="objc">/**
 *  公共的与Model无关的初始化.
 */
- (void)setup
{
    // 初始化网络请求相关的信息.
    self.httpClient = [AFHTTPRequestOperationManager manager];
    self.httpClient.requestSerializer = [AFJSONRequestSerializer serializer];
    self.httpClient.responseSerializer = [AFJSONResponseSerializer serializer];

    // 接口完整地址,肯定是受id影响.
    [RACObserve(self, blogId) subscribeNext:^(NSString * blogId) {
        NSString * path = [NSString stringWithFormat: @"http://www.ios122.com/find_php/index.php?viewController=YFPostViewController&amp;model[id]=%@", blogId];

        self.requestPath = path;
    }];

    // 每次完整的数据接口变化时,必然要同步更新 self.content 的值.
    [RACObserve(self, requestPath) subscribeNext:^(NSString * path) {
        [[self.httpClient rac_GET:path parameters:nil] subscribeNext:^(RACTuple *JSONAndHeaders) {
            // 使用MJExtension将JSON转换为对应的数据模型.
            YFArticleModel * model = [YFArticleModel objectWithKeyValues:JSONAndHeaders.first];

            self.content = model.body;
        }];
    }];
}
</code></pre>

<p>如果耐心比较下 -setup 方法中的代码,会发现与上个VM的-setup有许多共同之处,这就启发我们,或许应该将网络请求类从VM中进一步剥离出来,制作一个通用的网络请求类.通用网络请求类与单元测试的相关话题,会在下篇MVVM系列文章中专门讲述,在此不再继续讨论.</p>

<h3>不要为了RAC而RAC: 其实你可以使用你熟悉的方式写View的.</h3>

<p>坦白说,RAC真的让人很喜欢;但是,我在这里想说的是, RAC 只是简化编码的工具而已--所谓工具,就是那种你掌握了可以走的更快,不会也无伤大雅的东西!国内,部分文章过分渲染 RAC 与UIKit 的差异,甚至有人宣称是另一条完全不同的学习曲线--真的很扯,逻辑上无异于就像宣称没有MFC,所有人都会饿死一样!在此,就不过多吐槽了,反正我是很早就看过国内某些博主的关于RAC的文章,被博主忽悠忽悠的不行,最终得出的结论是,太难了,暂时不学!如果,你刚好看到这篇文章,我想对你说的是: 耐下心,花一两天结合自己的工程和基础的RAC语法,尝试用RAC写写代码试试,真的很赞,而且是有足够的姿势完全兼容以前的自己写法的!View部分,在此我就暂时不用RAC中的写法来替代block,代理等,尽可能地在MVC的代码上,适当修正,以证明二者的某种程度上的协同作用.</p>

<p>控制器中的代码,真的被精简了不少,以博客列表控制器为例,几乎占据1/2控制器代码量的网络请求与数据分页的代码,被简化为一句话:</p>

<pre><code class="objc">[RACObserve(self.viewModel, blogListItemViewModels) subscribeNext:^(id x) {
    [self updateView];
}];
</code></pre>

<p>同样的,博客详情也精简了非常多,忍不住想晒下完整代码:</p>

<pre><code class="objc">//
//  YFMVVMPostViewController.m
//  iOS122
//
//  Created by 颜风 on 15/10/21.
//  Copyright (c) 2015年 iOS122. All rights reserved.
//

#import "YFMVVMPostViewController.h"
#import "YFBlogDetailViewModel.h"
#import &lt;ReactiveCocoa.h&gt;

@interface YFMVVMPostViewController ()
@property (strong, nonatomic) UIWebView * webView;
@end

@implementation YFMVVMPostViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    [RACObserve(self.viewModel, content) subscribeNext:^(id x) {
        [self updateView];
    }];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}
- (UIWebView *)webView
{
    if (nil == _webView) {
        _webView = [[UIWebView alloc] init];

        [self.view addSubview: _webView];

        [_webView makeConstraints:^(MASConstraintMaker *make) {
            make.edges.equalTo(UIEdgeInsetsMake(0, 0, 0, 0));
        }];
    }

    return _webView;
}

/**
 * 更新视图.
 */
- (void) updateView
{
    [self.webView loadHTMLString: self.viewModel.content baseURL:nil];
}

@end
</code></pre>

<h2>附</h2>

<ul>
<li>示例完整代码: <a href="https://github.com/ios122/ios122">iOS122</a></li>
<li>推荐阅读: <a href="http://www.cocoachina.com/industry/20140126/7759.html">基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</a></li>
<li>下篇主题: MVVM系列的下一个主题,会对MVVM中网络请求的逻辑进一步从VM剥离以及单元测试的一些技术性讨论,欢迎回帖交流!</li>
</ul>
]]></content:encoded>
		<excerpt:encoded><![CDATA[在此工程中,本文将讨论将MVC改造为MVVM需要的一些基本方法,同时会适当穿插部分关于MVVM概念性的讨论!本文最大的意义在于,提供了一种读者可以复现的方式,逐步引出从MVC向MVVM尽可能平滑过渡的一种方案;此外,也是为数不多的ReactiveCocoa实例文章之一.本文是MVVM系列文文章的第二篇,在阅读之前,您可能需要先阅读下第一篇文章: 写给iOS小白的MVVM教程(一): 从MVC到MVVM之一个典型的MVC应用场景]]></excerpt:encoded>
		<wp:post_id>391</wp:post_id>
		<wp:post_date>2015-10-23 02:13:07</wp:post_date>
		<wp:post_date_gmt>2015-10-22 18:13:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mvvm_2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mvvm"><![CDATA[MVVM]]></category>
		<category domain="post_tag" nicename="reactivecocoa"><![CDATA[ReactiveCocoa]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_sd_is_markdown</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[%e5%86%99%e7%bb%99ios%e5%b0%8f%e7%99%bd%e7%9a%84mvvm%e6%95%99%e7%a8%8b%e4%ba%8c-%e4%bb%8emvc%e5%88%b0mvvm%e4%b9%8b%e4%b8%80%e4%b8%aa%e5%85%b8%e5%9e%8b%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e7%9a%84mv]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>34</wp:comment_id>
			<wp:comment_author><![CDATA[写给iOS小白的MVVM教程(序) | iOS122]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.ios122.com/2015/10/mvvm_start/</wp:comment_author_url>
			<wp:comment_author_IP>107.180.41.88</wp:comment_author_IP>
			<wp:comment_date>2015-10-26 14:38:10</wp:comment_date>
			<wp:comment_date_gmt>2015-10-26 06:38:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[&#8230;] 写给iOS小白的MVVM教程(二): 从MVC到MVVM之一个典型应用场景的MVVM版本实现 [&#8230;]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_error</wp:meta_key>
				<wp:meta_value><![CDATA[1445841490]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445841490.4373009204864501953125;s:5:"event";s:11:"check-error";s:4:"meta";a:1:{s:8:"response";s:7:"invalid";}}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:3:{s:4:"time";d:1445841506.210381984710693359375;s:5:"event";s:15:"status-approved";s:4:"user";s:12:"yanfengstyle";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
</channel>
</rss>
